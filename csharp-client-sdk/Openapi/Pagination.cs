//------------------------------------------------------------------------------
// <auto-generated>
// This code was generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
//
// Changes to this file may cause incorrect behavior and will be lost when
// the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
#nullable enable
namespace Openapi
{
    using Newtonsoft.Json;
    using Newtonsoft.Json.Linq;
    using Openapi.Hooks;
    using Openapi.Models.Errors;
    using Openapi.Models.Operations;
    using Openapi.Models.Shared;
    using Openapi.Utils;
    using Openapi.Utils.Retries;
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Net.Http;
    using System.Net.Http.Headers;
    using System.Threading.Tasks;

    /// <summary>
    /// Endpoints for testing the pagination extension
    /// </summary>
    public interface IPagination
    {

        /// <summary>
        /// This is a paginated operation where there is both a query parameter and<br/>
        /// request body field called &quot;cursor&quot;. This ambiguity is used to test that<br/>
        /// the generator only updates the appropriate field in the pagination code<br/>
        /// &quot;next()&quot; function.<br/>
        /// 
        /// </summary>
        Task<PaginationAmbiguousInputResponse> PaginationAmbiguousInputAsync(PaginationAmbiguousInputRequestBody requestBody, long? cursor = null, string? serverUrl = null);
        Task<PaginationBodyFlattenedOptionalSecurityResponse> PaginationBodyFlattenedOptionalSecurityAsync(long limit, long offset, PaginationBodyFlattenedOptionalSecuritySecurity? security = null, string? serverUrl = null);
        Task<PaginationBodyFlattenedWithSecurityResponse> PaginationBodyFlattenedWithSecurityAsync(PaginationBodyFlattenedWithSecuritySecurity security, long limit, long offset, string? serverUrl = null);

        /// <summary>
        /// This operation has a request wrapper type that encapsulates the<br/>
        /// parameters and request body. The pagination inputs are meant to go in<br/>
        /// the request body and we want to test that the generator correctly<br/>
        /// generates the next() function call preserving everything from the<br/>
        /// original request and interpolating the next pagination inputs.<br/>
        /// 
        /// </summary>
        Task<PaginationBodyWrappedRequestResponse> PaginationBodyWrappedRequestAsync(PaginationBodyWrappedRequestRequest request, string? serverUrl = null);
        Task<PaginationCursorBodyResponse> PaginationCursorBodyAsync(PaginationCursorBodyRequestBody request, string? serverUrl = null);
        Task<PaginationCursorNonNumericResponse> PaginationCursorNonNumericAsync(string? cursor = null, string? serverUrl = null);
        Task<PaginationCursorParamsResponse> PaginationCursorParamsAsync(long cursor, string? serverUrl = null);

        /// <summary>
        /// This is a paginated operation where the input is a query parameter<br/>
        /// but the number of arguments exceeds maxMethodParams so it ends up<br/>
        /// being encapsulated into a request object.<br/>
        /// 
        /// </summary>
        Task<PaginationEncapsulatedParameterResponse> PaginationEncapsulatedParameterAsync(PaginationEncapsulatedParameterRequest? request = null, string? serverUrl = null);
        Task<PaginationLimitOffsetDeepOutputsPageBodyResponse> PaginationLimitOffsetDeepOutputsPageBodyAsync(LimitOffsetConfig? request = null, string? serverUrl = null);
        Task<PaginationLimitOffsetDefaultOffsetBodyResponse> PaginationLimitOffsetDefaultOffsetBodyAsync(LimitOffsetConfigWithDefaults? request = null, string? serverUrl = null);
        Task<PaginationLimitOffsetDefaultOffsetParamsResponse> PaginationLimitOffsetDefaultOffsetParamsAsync(long? limit = null, long? offset = null, string? serverUrl = null);
        Task<PaginationLimitOffsetOffsetBodyResponse> PaginationLimitOffsetOffsetBodyAsync(LimitOffsetConfig? request = null, string? serverUrl = null);
        Task<PaginationLimitOffsetOffsetParamsResponse> PaginationLimitOffsetOffsetParamsAsync(long? limit = null, long? offset = null, string? serverUrl = null);
        Task<PaginationLimitOffsetOptionalPageParamsResponse> PaginationLimitOffsetOptionalPageParamsAsync(long? page = null, string? serverUrl = null);
        Task<PaginationLimitOffsetPageBodyResponse> PaginationLimitOffsetPageBodyAsync(LimitOffsetConfig? request = null, string? serverUrl = null);
        Task<PaginationLimitOffsetPageParamsResponse> PaginationLimitOffsetPageParamsAsync(long page, string? serverUrl = null);
        Task<PaginationURLParamsResponse> PaginationURLParamsAsync(long attempts, string? isReferencePath = null, string? serverUrl = null);
        Task<PaginationWithRetriesResponse> PaginationWithRetriesAsync(string? cursor = null, string? faultSettings = null, string? requestId = null, string? serverUrl = null, RetryConfig? retryConfig = null);
        Task<PaginationWrappedOptionalBodyResponse> PaginationWrappedOptionalBodyAsync(PaginationWrappedOptionalBodyRequest? request = null, PaginationWrappedOptionalBodySecurity? security = null, string? serverUrl = null);
    }

    /// <summary>
    /// Endpoints for testing the pagination extension
    /// </summary>
    public class Pagination: IPagination
    {
        /// <summary>
        /// List of server URLs available for the paginationAmbiguousInput operation.
        /// </summary>
        public static readonly string[] PaginationAmbiguousInputServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationBodyFlattenedOptionalSecurity operation.
        /// </summary>
        public static readonly string[] PaginationBodyFlattenedOptionalSecurityServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationBodyFlattenedWithSecurity operation.
        /// </summary>
        public static readonly string[] PaginationBodyFlattenedWithSecurityServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationBodyWrappedRequest operation.
        /// </summary>
        public static readonly string[] PaginationBodyWrappedRequestServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationCursorBody operation.
        /// </summary>
        public static readonly string[] PaginationCursorBodyServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationCursorNonNumeric operation.
        /// </summary>
        public static readonly string[] PaginationCursorNonNumericServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationCursorParams operation.
        /// </summary>
        public static readonly string[] PaginationCursorParamsServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationEncapsulatedParameter operation.
        /// </summary>
        public static readonly string[] PaginationEncapsulatedParameterServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationLimitOffsetDeepOutputsPageBody operation.
        /// </summary>
        public static readonly string[] PaginationLimitOffsetDeepOutputsPageBodyServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationLimitOffsetDefaultOffsetBody operation.
        /// </summary>
        public static readonly string[] PaginationLimitOffsetDefaultOffsetBodyServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationLimitOffsetDefaultOffsetParams operation.
        /// </summary>
        public static readonly string[] PaginationLimitOffsetDefaultOffsetParamsServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationLimitOffsetOffsetBody operation.
        /// </summary>
        public static readonly string[] PaginationLimitOffsetOffsetBodyServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationLimitOffsetOffsetParams operation.
        /// </summary>
        public static readonly string[] PaginationLimitOffsetOffsetParamsServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationLimitOffsetOptionalPageParams operation.
        /// </summary>
        public static readonly string[] PaginationLimitOffsetOptionalPageParamsServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationLimitOffsetPageBody operation.
        /// </summary>
        public static readonly string[] PaginationLimitOffsetPageBodyServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationLimitOffsetPageParams operation.
        /// </summary>
        public static readonly string[] PaginationLimitOffsetPageParamsServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationURLParams operation.
        /// </summary>
        public static readonly string[] PaginationURLParamsServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationWithRetries operation.
        /// </summary>
        public static readonly string[] PaginationWithRetriesServerList = {
            "http://localhost:35456",
        };
        /// <summary>
        /// List of server URLs available for the paginationWrappedOptionalBody operation.
        /// </summary>
        public static readonly string[] PaginationWrappedOptionalBodyServerList = {
            "http://localhost:35456",
        };
        public SDKConfig SDKConfiguration { get; private set; }
        private const string _language = "csharp";
        private const string _sdkVersion = "0.4.0";
        private const string _sdkGenVersion = "2.486.1";
        private const string _openapiDocVersion = "0.1.0";
        private const string _userAgent = "speakeasy-sdk/csharp 0.4.0 2.486.1 0.1.0 Openapi";
        private string _serverUrl = "";
        private ISpeakeasyHttpClient _client;
        private Func<Openapi.Models.Shared.Security>? _securitySource;

        public Pagination(ISpeakeasyHttpClient client, Func<Openapi.Models.Shared.Security>? securitySource, string serverUrl, SDKConfig config)
        {
            _client = client;
            _securitySource = securitySource;
            _serverUrl = serverUrl;
            SDKConfiguration = config;
        }

        public async Task<PaginationAmbiguousInputResponse> PaginationAmbiguousInputAsync(PaginationAmbiguousInputRequestBody requestBody, long? cursor = null, string? serverUrl = null)
        {
            var request = new PaginationAmbiguousInputRequest()
            {
                RequestBody = requestBody,
                Cursor = cursor,
            };
            string baseUrl = Utilities.TemplateUrl(PaginationAmbiguousInputServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/cursor#ambiguousInput", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Put, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "RequestBody", "json", false, false);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationAmbiguousInput", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationAmbiguousInputResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var nextCursorToken = body.SelectToken("$.resultArray[-1:]");

                if(nextCursorToken == null)
                {
                    return null;
                }
                var nextCursor = nextCursorToken.Value<long>();

                var newRequestBody = new PaginationAmbiguousInputRequestBody
                {
                    Cursor = nextCursor
                };

                return await PaginationAmbiguousInputAsync (
                    cursor: cursor,
                    requestBody: newRequestBody,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationAmbiguousInputRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    var response = new PaginationAmbiguousInputResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationBodyFlattenedOptionalSecurityResponse> PaginationBodyFlattenedOptionalSecurityAsync(long limit, long offset, PaginationBodyFlattenedOptionalSecuritySecurity? security = null, string? serverUrl = null)
        {
            var request = new PaginationBodyFlattenedOptionalSecurityRequest()
            {
                Limit = limit,
                Offset = offset,
            };
            string baseUrl = Utilities.TemplateUrl(PaginationBodyFlattenedOptionalSecurityServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/limitoffset/offset#paginationBodyFlattenedOptionalSecurity", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            Func<PaginationBodyFlattenedOptionalSecuritySecurity>? securitySource = null;
            if (security != null)
            {
                httpRequest = new SecurityMetadata(() => security).Apply(httpRequest);
                securitySource = () => security;
            }

            var hookCtx = new HookContext("paginationBodyFlattenedOptionalSecurity", null, securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationBodyFlattenedOptionalSecurityResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var offset = request.Offset;
                var firstResult = body.SelectToken("$.resultArray");
                if (firstResult == null)
                {
                    return null;
                }

                if (firstResult.Children().Count() == 0)
                {
                    return null;
                }
                var limit = request.Limit;
                if (firstResult.Children().Count() < limit)
                {
                    return null;
                }
                var newOffset = offset + firstResult.Children().Count();

                return await PaginationBodyFlattenedOptionalSecurityAsync (
                    limit: limit,
                    offset: newOffset,
                    security: security,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationBodyFlattenedOptionalSecurityRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    var response = new PaginationBodyFlattenedOptionalSecurityResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationBodyFlattenedWithSecurityResponse> PaginationBodyFlattenedWithSecurityAsync(PaginationBodyFlattenedWithSecuritySecurity security, long limit, long offset, string? serverUrl = null)
        {
            var request = new PaginationBodyFlattenedWithSecurityRequest()
            {
                Limit = limit,
                Offset = offset,
            };
            string baseUrl = Utilities.TemplateUrl(PaginationBodyFlattenedWithSecurityServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/limitoffset/offset#paginationBodyFlattenedWithSecurity", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            if (security == null)
            {
                throw new ArgumentNullException(nameof(security), "security cannot be null.");
            }

            httpRequest = new SecurityMetadata(() => security).Apply(httpRequest);
            var hookCtx = new HookContext("paginationBodyFlattenedWithSecurity", null, () => security);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationBodyFlattenedWithSecurityResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var offset = request.Offset;
                var firstResult = body.SelectToken("$.resultArray");
                if (firstResult == null)
                {
                    return null;
                }

                if (firstResult.Children().Count() == 0)
                {
                    return null;
                }
                var limit = request.Limit;
                if (firstResult.Children().Count() < limit)
                {
                    return null;
                }
                var newOffset = offset + firstResult.Children().Count();

                return await PaginationBodyFlattenedWithSecurityAsync (
                    limit: limit,
                    offset: newOffset,
                    security: security!,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationBodyFlattenedWithSecurityRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    var response = new PaginationBodyFlattenedWithSecurityResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationBodyWrappedRequestResponse> PaginationBodyWrappedRequestAsync(PaginationBodyWrappedRequestRequest request, string? serverUrl = null)
        {
            string baseUrl = Utilities.TemplateUrl(PaginationBodyWrappedRequestServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }

            var urlString = baseUrl + "/pagination/limitoffset/page#paginationBodyWrappedRequest";

            var httpRequest = new HttpRequestMessage(HttpMethod.Put, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);
            HeaderSerializer.PopulateHeaders(ref httpRequest, request);

            var serializedBody = RequestBodySerializer.Serialize(request, "LimitOffsetConfig", "json", false, false);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationBodyWrappedRequest", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationBodyWrappedRequestResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());

                var page = request.LimitOffsetConfig.Page;
                var newPage = page + 1;

                var numPages = body.SelectToken("$.numPages");

                if (numPages == null || numPages.Value<long>() <= page)
                {
                    return null;
                }

                var newRequest = new PaginationBodyWrappedRequestRequest
                {
                    LimitOffsetConfig = new LimitOffsetConfig
                    {
                        Limit = request.LimitOffsetConfig.Limit,
                        Offset = request.LimitOffsetConfig.Offset,
                        Page = newPage
                    },
                    IdempotencyKey = request.IdempotencyKey,
                    RequestId = request.RequestId
                };

                return await PaginationBodyWrappedRequestAsync (
                    request: newRequest,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationBodyWrappedRequestRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    var response = new PaginationBodyWrappedRequestResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationCursorBodyResponse> PaginationCursorBodyAsync(PaginationCursorBodyRequestBody request, string? serverUrl = null)
        {
            string baseUrl = Utilities.TemplateUrl(PaginationCursorBodyServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }

            var urlString = baseUrl + "/pagination/cursor";

            var httpRequest = new HttpRequestMessage(HttpMethod.Put, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "Request", "json", false, false);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationCursorBody", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationCursorBodyResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var nextCursorToken = body.SelectToken("$.resultArray[-1:]");

                if(nextCursorToken == null)
                {
                    return null;
                }
                var nextCursor = nextCursorToken.Value<long>();

                var newRequest = new PaginationCursorBodyRequestBody
                {
                    Cursor = nextCursor
                };

                return await PaginationCursorBodyAsync (
                    request: newRequest,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationCursorBodyRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    var response = new PaginationCursorBodyResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationCursorNonNumericResponse> PaginationCursorNonNumericAsync(string? cursor = null, string? serverUrl = null)
        {
            var request = new PaginationCursorNonNumericRequest()
            {
                Cursor = cursor,
            };
            string baseUrl = Utilities.TemplateUrl(PaginationCursorNonNumericServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/cursor_non_numeric", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationCursorNonNumeric", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationCursorNonNumericResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var nextCursorToken = body.SelectToken("$.resultArray[-1:]");

                if(nextCursorToken == null)
                {
                    return null;
                }
                var nextCursor = nextCursorToken.Value<string>();

                return await PaginationCursorNonNumericAsync (
                    cursor: nextCursor,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationCursorNonNumericRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Include);
                    var response = new PaginationCursorNonNumericResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationCursorParamsResponse> PaginationCursorParamsAsync(long cursor, string? serverUrl = null)
        {
            var request = new PaginationCursorParamsRequest()
            {
                Cursor = cursor,
            };
            string baseUrl = Utilities.TemplateUrl(PaginationCursorParamsServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/cursor", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationCursorParams", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationCursorParamsResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var nextCursorToken = body.SelectToken("$.resultArray[-1:]");

                if(nextCursorToken == null)
                {
                    return null;
                }
                var nextCursor = nextCursorToken.Value<long>();

                return await PaginationCursorParamsAsync (
                    cursor: nextCursor,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationCursorParamsRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    var response = new PaginationCursorParamsResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationEncapsulatedParameterResponse> PaginationEncapsulatedParameterAsync(PaginationEncapsulatedParameterRequest? request = null, string? serverUrl = null)
        {
            string baseUrl = Utilities.TemplateUrl(PaginationEncapsulatedParameterServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/cursor#encapsulatedParameter", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Put, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);
            HeaderSerializer.PopulateHeaders(ref httpRequest, request);

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationEncapsulatedParameter", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationEncapsulatedParameterResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var nextCursorToken = body.SelectToken("$.resultArray[-1:]");

                if(nextCursorToken == null)
                {
                    return null;
                }
                var nextCursor = nextCursorToken.Value<long>();

                var newRequest = new PaginationEncapsulatedParameterRequest
                {
                    Cursor = nextCursor,
                    HeaderParam = request?.HeaderParam
                };

                return await PaginationEncapsulatedParameterAsync (
                    request: newRequest,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationEncapsulatedParameterRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Include);
                    var response = new PaginationEncapsulatedParameterResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationLimitOffsetDeepOutputsPageBodyResponse> PaginationLimitOffsetDeepOutputsPageBodyAsync(LimitOffsetConfig? request = null, string? serverUrl = null)
        {
            string baseUrl = Utilities.TemplateUrl(PaginationLimitOffsetDeepOutputsPageBodyServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }

            var urlString = baseUrl + "/pagination/limitoffset/deep_outputs/page";

            var httpRequest = new HttpRequestMessage(HttpMethod.Put, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "Request", "json", false, true);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationLimitOffsetDeepOutputsPageBody", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationLimitOffsetDeepOutputsPageBodyResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());

                var page = request?.Page?? 0;
                var newPage = page + 1;

                var numPages = body.SelectToken("$.pageInfo.numPages");

                if (numPages == null || numPages.Value<long>() <= page)
                {
                    return null;
                }

                var newRequest = new LimitOffsetConfig
                {
                    Limit = request?.Limit,
                    Offset = request?.Offset,
                    Page = newPage
                };

                return await PaginationLimitOffsetDeepOutputsPageBodyAsync (
                    request: newRequest,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationLimitOffsetDeepOutputsPageBodyRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Include);
                    var response = new PaginationLimitOffsetDeepOutputsPageBodyResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationLimitOffsetDefaultOffsetBodyResponse> PaginationLimitOffsetDefaultOffsetBodyAsync(LimitOffsetConfigWithDefaults? request = null, string? serverUrl = null)
        {
            string baseUrl = Utilities.TemplateUrl(PaginationLimitOffsetDefaultOffsetBodyServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }

            var urlString = baseUrl + "/pagination/limitoffset/offset#WithDefaults";

            var httpRequest = new HttpRequestMessage(HttpMethod.Put, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "Request", "json", false, true);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationLimitOffsetDefaultOffsetBody", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationLimitOffsetDefaultOffsetBodyResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var offset = request?.Offset?? 0;
                var firstResult = body.SelectToken("$.resultArray");
                if (firstResult == null)
                {
                    return null;
                }

                if (firstResult.Children().Count() == 0)
                {
                    return null;
                }
                var limit = request?.Limit?? 0;
                if (firstResult.Children().Count() < limit)
                {
                    return null;
                }
                var newOffset = offset + firstResult.Children().Count();

                var newRequest = new LimitOffsetConfigWithDefaults
                {
                    Limit = request?.Limit,
                    Offset = newOffset,
                    Page = request?.Page
                };

                return await PaginationLimitOffsetDefaultOffsetBodyAsync (
                    request: newRequest,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationLimitOffsetDefaultOffsetBodyRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Include);
                    var response = new PaginationLimitOffsetDefaultOffsetBodyResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationLimitOffsetDefaultOffsetParamsResponse> PaginationLimitOffsetDefaultOffsetParamsAsync(long? limit = null, long? offset = null, string? serverUrl = null)
        {
            var request = new PaginationLimitOffsetDefaultOffsetParamsRequest()
            {
                Limit = limit,
                Offset = offset,
            };
            string baseUrl = Utilities.TemplateUrl(PaginationLimitOffsetDefaultOffsetParamsServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/limitoffset/offset#WithDefaults", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationLimitOffsetDefaultOffsetParams", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationLimitOffsetDefaultOffsetParamsResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var offset = request?.Offset?? 0;
                var firstResult = body.SelectToken("$.resultArray");
                if (firstResult == null)
                {
                    return null;
                }

                if (firstResult.Children().Count() == 0)
                {
                    return null;
                }
                var limit = request?.Limit?? 0;
                if (firstResult.Children().Count() < limit)
                {
                    return null;
                }
                var newOffset = offset + firstResult.Children().Count();

                return await PaginationLimitOffsetDefaultOffsetParamsAsync (
                    limit: limit,
                    offset: newOffset,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationLimitOffsetDefaultOffsetParamsRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Include);
                    var response = new PaginationLimitOffsetDefaultOffsetParamsResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationLimitOffsetOffsetBodyResponse> PaginationLimitOffsetOffsetBodyAsync(LimitOffsetConfig? request = null, string? serverUrl = null)
        {
            string baseUrl = Utilities.TemplateUrl(PaginationLimitOffsetOffsetBodyServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }

            var urlString = baseUrl + "/pagination/limitoffset/offset";

            var httpRequest = new HttpRequestMessage(HttpMethod.Put, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "Request", "json", false, true);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationLimitOffsetOffsetBody", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationLimitOffsetOffsetBodyResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var offset = request?.Offset?? 0;
                var firstResult = body.SelectToken("$.resultArray");
                if (firstResult == null)
                {
                    return null;
                }

                if (firstResult.Children().Count() == 0)
                {
                    return null;
                }
                var limit = request?.Limit?? 0;
                if (firstResult.Children().Count() < limit)
                {
                    return null;
                }
                var newOffset = offset + firstResult.Children().Count();

                var newRequest = new LimitOffsetConfig
                {
                    Limit = request?.Limit,
                    Offset = newOffset,
                    Page = request?.Page
                };

                return await PaginationLimitOffsetOffsetBodyAsync (
                    request: newRequest,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationLimitOffsetOffsetBodyRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Include);
                    var response = new PaginationLimitOffsetOffsetBodyResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationLimitOffsetOffsetParamsResponse> PaginationLimitOffsetOffsetParamsAsync(long? limit = null, long? offset = null, string? serverUrl = null)
        {
            var request = new PaginationLimitOffsetOffsetParamsRequest()
            {
                Limit = limit,
                Offset = offset,
            };
            string baseUrl = Utilities.TemplateUrl(PaginationLimitOffsetOffsetParamsServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/limitoffset/offset", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationLimitOffsetOffsetParams", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationLimitOffsetOffsetParamsResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var offset = request?.Offset?? 0;
                var firstResult = body.SelectToken("$.resultArray");
                if (firstResult == null)
                {
                    return null;
                }

                if (firstResult.Children().Count() == 0)
                {
                    return null;
                }
                var limit = request?.Limit?? 0;
                if (firstResult.Children().Count() < limit)
                {
                    return null;
                }
                var newOffset = offset + firstResult.Children().Count();

                return await PaginationLimitOffsetOffsetParamsAsync (
                    limit: limit,
                    offset: newOffset,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationLimitOffsetOffsetParamsRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Include);
                    var response = new PaginationLimitOffsetOffsetParamsResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationLimitOffsetOptionalPageParamsResponse> PaginationLimitOffsetOptionalPageParamsAsync(long? page = null, string? serverUrl = null)
        {
            var request = new PaginationLimitOffsetOptionalPageParamsRequest()
            {
                Page = page,
            };
            string baseUrl = Utilities.TemplateUrl(PaginationLimitOffsetOptionalPageParamsServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/limitoffset/page#optionalPageParams", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationLimitOffsetOptionalPageParams", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationLimitOffsetOptionalPageParamsResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());

                var page = request?.Page?? 0;
                var newPage = page + 1;
                var firstResult = body.SelectToken("$.resultArray");
                if (firstResult == null)
                {
                    return null;
                }

                if (firstResult.Children().Count() == 0)
                {
                    return null;
                }

                return await PaginationLimitOffsetOptionalPageParamsAsync (
                    page: newPage,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationLimitOffsetOptionalPageParamsRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Include);
                    var response = new PaginationLimitOffsetOptionalPageParamsResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationLimitOffsetPageBodyResponse> PaginationLimitOffsetPageBodyAsync(LimitOffsetConfig? request = null, string? serverUrl = null)
        {
            string baseUrl = Utilities.TemplateUrl(PaginationLimitOffsetPageBodyServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }

            var urlString = baseUrl + "/pagination/limitoffset/page";

            var httpRequest = new HttpRequestMessage(HttpMethod.Put, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            var serializedBody = RequestBodySerializer.Serialize(request, "Request", "json", false, true);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationLimitOffsetPageBody", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationLimitOffsetPageBodyResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());

                var page = request?.Page?? 0;
                var newPage = page + 1;

                var numPages = body.SelectToken("$.numPages");

                if (numPages == null || numPages.Value<long>() <= page)
                {
                    return null;
                }

                var newRequest = new LimitOffsetConfig
                {
                    Limit = request?.Limit,
                    Offset = request?.Offset,
                    Page = newPage
                };

                return await PaginationLimitOffsetPageBodyAsync (
                    request: newRequest,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationLimitOffsetPageBodyRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Include);
                    var response = new PaginationLimitOffsetPageBodyResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationLimitOffsetPageParamsResponse> PaginationLimitOffsetPageParamsAsync(long page, string? serverUrl = null)
        {
            var request = new PaginationLimitOffsetPageParamsRequest()
            {
                Page = page,
            };
            string baseUrl = Utilities.TemplateUrl(PaginationLimitOffsetPageParamsServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/limitoffset/page", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationLimitOffsetPageParams", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationLimitOffsetPageParamsResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());

                var page = request.Page;
                var newPage = page + 1;
                var firstResult = body.SelectToken("$.resultArray");
                if (firstResult == null)
                {
                    return null;
                }

                if (firstResult.Children().Count() == 0)
                {
                    return null;
                }

                return await PaginationLimitOffsetPageParamsAsync (
                    page: newPage,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationLimitOffsetPageParamsRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    var response = new PaginationLimitOffsetPageParamsResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationURLParamsResponse> PaginationURLParamsAsync(long attempts, string? isReferencePath = null, string? serverUrl = null)
        {
            var request = new PaginationURLParamsRequest()
            {
                Attempts = attempts,
                IsReferencePath = isReferencePath,
            };
            string baseUrl = Utilities.TemplateUrl(PaginationURLParamsServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/url", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationURLParams", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationURLParamsRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Ignore);
                    var response = new PaginationURLParamsResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationWithRetriesResponse> PaginationWithRetriesAsync(string? cursor = null, string? faultSettings = null, string? requestId = null, string? serverUrl = null, RetryConfig? retryConfig = null)
        {
            var request = new PaginationWithRetriesRequest()
            {
                Cursor = cursor,
                FaultSettings = faultSettings,
                RequestId = requestId,
            };
            string baseUrl = Utilities.TemplateUrl(PaginationWithRetriesServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }
            var urlString = URLBuilder.Build(baseUrl, "/pagination/cursor_non_numeric#withRetries", request);

            var httpRequest = new HttpRequestMessage(HttpMethod.Get, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);
            HeaderSerializer.PopulateHeaders(ref httpRequest, request);

            if (_securitySource != null)
            {
                httpRequest = new SecurityMetadata(_securitySource).Apply(httpRequest);
            }

            var hookCtx = new HookContext("paginationWithRetries", null, _securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);
            if (retryConfig == null)
            {
                if (this.SDKConfiguration.RetryConfig != null)
                {
                    retryConfig = this.SDKConfiguration.RetryConfig;
                }
                else
                {
                    var backoff = new BackoffStrategy(
                        initialIntervalMs: 10L,
                        maxIntervalMs: 100L,
                        maxElapsedTimeMs: 1000L,
                        exponent: 1.5
                    );
                    retryConfig = new RetryConfig(
                        strategy: RetryConfig.RetryStrategy.BACKOFF,
                        backoff: backoff,
                        retryConnectionErrors: false
                    );
                }
            }

            List<string> statusCodes = new List<string>
            {
                "503",
            };

            Func<Task<HttpResponseMessage>> retrySend = async () =>
            {
                var _httpRequest = await _client.CloneAsync(httpRequest);
                return await _client.SendAsync(_httpRequest);
            };
            var retries = new Openapi.Utils.Retries.Retries(retrySend, retryConfig, statusCodes);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await retries.Run();
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationWithRetriesResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var nextCursorToken = body.SelectToken("$.resultArray[-1:]");

                if(nextCursorToken == null)
                {
                    return null;
                }
                var nextCursor = nextCursorToken.Value<string>();

                return await PaginationWithRetriesAsync (
                    cursor: nextCursor,
                    faultSettings: faultSettings,
                    requestId: requestId,
                    serverUrl: serverUrl,
                    retryConfig: retryConfig
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationWithRetriesRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Include);
                    var response = new PaginationWithRetriesResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }

        public async Task<PaginationWrappedOptionalBodyResponse> PaginationWrappedOptionalBodyAsync(PaginationWrappedOptionalBodyRequest? request = null, PaginationWrappedOptionalBodySecurity? security = null, string? serverUrl = null)
        {
            string baseUrl = Utilities.TemplateUrl(PaginationWrappedOptionalBodyServerList[0], new Dictionary<string, string>(){
            });
            if (serverUrl != null)
            {
                baseUrl = serverUrl;
            }

            var urlString = baseUrl + "/pagination/limitoffset/offset#paginationWrappedOptionalBody";

            var httpRequest = new HttpRequestMessage(HttpMethod.Put, urlString);
            httpRequest.Headers.Add("x-speakeasy-user-agent", _userAgent);
            HeaderSerializer.PopulateHeaders(ref httpRequest, request);

            var serializedBody = RequestBodySerializer.Serialize(request, "LimitOffsetConfig", "json", false, true);
            if (serializedBody != null)
            {
                httpRequest.Content = serializedBody;
            }

            Func<PaginationWrappedOptionalBodySecurity>? securitySource = null;
            if (security != null)
            {
                httpRequest = new SecurityMetadata(() => security).Apply(httpRequest);
                securitySource = () => security;
            }

            var hookCtx = new HookContext("paginationWrappedOptionalBody", null, securitySource);

            httpRequest = await this.SDKConfiguration.Hooks.BeforeRequestAsync(new BeforeRequestContext(hookCtx), httpRequest);

            HttpResponseMessage httpResponse;
            try
            {
                httpResponse = await _client.SendAsync(httpRequest);
                int _statusCode = (int)httpResponse.StatusCode;

                if (_statusCode >= 400 && _statusCode < 500 || _statusCode >= 500 && _statusCode < 600)
                {
                    var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), httpResponse, null);
                    if (_httpResponse != null)
                    {
                        httpResponse = _httpResponse;
                    }
                }
            }
            catch (Exception error)
            {
                var _httpResponse = await this.SDKConfiguration.Hooks.AfterErrorAsync(new AfterErrorContext(hookCtx), null, error);
                if (_httpResponse != null)
                {
                    httpResponse = _httpResponse;
                }
                else
                {
                    throw;
                }
            }

            httpResponse = await this.SDKConfiguration.Hooks.AfterSuccessAsync(new AfterSuccessContext(hookCtx), httpResponse);

            
            Func<Task<PaginationWrappedOptionalBodyResponse?>> nextFunc = async delegate()
            {
                var body = JObject.Parse(await httpResponse.Content.ReadAsStringAsync());
                var offset = request?.LimitOffsetConfig?.Offset?? 0;
                var firstResult = body.SelectToken("$.resultArray");
                if (firstResult == null)
                {
                    return null;
                }

                if (firstResult.Children().Count() == 0)
                {
                    return null;
                }
                var limit = request?.LimitOffsetConfig?.Limit?? 0;
                if (firstResult.Children().Count() < limit)
                {
                    return null;
                }
                var newOffset = offset + firstResult.Children().Count();

                var newRequest = new PaginationWrappedOptionalBodyRequest
                {
                    IdempotencyKey = request?.IdempotencyKey,
                    LimitOffsetConfig = new LimitOffsetConfig
                    {
                        Limit = request?.LimitOffsetConfig?.Limit,
                        Offset = newOffset,
                        Page = request?.LimitOffsetConfig?.Page
                    },
                    RequestId = request?.RequestId
                };

                return await PaginationWrappedOptionalBodyAsync (
                    request: newRequest,
                    security: security,
                    serverUrl: serverUrl
                );
            };

            var contentType = httpResponse.Content.Headers.ContentType?.MediaType;
            int responseStatusCode = (int)httpResponse.StatusCode;
            if(responseStatusCode == 200)
            {
                if(Utilities.IsContentTypeMatch("application/json", contentType))
                {
                    var obj = ResponseBodyDeserializer.Deserialize<PaginationWrappedOptionalBodyRes>(await httpResponse.Content.ReadAsStringAsync(), NullValueHandling.Include);
                    var response = new PaginationWrappedOptionalBodyResponse()
                    {
                        StatusCode = responseStatusCode,
                        ContentType = contentType,
                        RawResponse = httpResponse,
                        Next = nextFunc
                    };
                    response.Res = obj;
                    return response;
                }

                throw new Models.Errors.SDKException("Unknown content type received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }
            else if(responseStatusCode >= 400 && responseStatusCode < 500 || responseStatusCode >= 500 && responseStatusCode < 600)
            {
                throw new Models.Errors.SDKException("API error occurred", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
            }

            throw new Models.Errors.SDKException("Unknown status code received", responseStatusCode, await httpResponse.Content.ReadAsStringAsync(), httpResponse);
        }
    }
}