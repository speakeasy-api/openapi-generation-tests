/* 
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

package org.openapis.openapi;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.math.BigInteger;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.Callable;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.openapis.openapi.utils.BigIntegerString;
import org.openapis.openapi.utils.JSON;
import org.openapis.openapi.utils.TypedObject;
import org.openapis.openapi.utils.Utils;
import org.openapis.openapi.utils.Utils.JsonShape;
import org.openapis.openapi.utils.Utils.TypeReferenceWithShape;
import org.openapitools.jackson.nullable.JsonNullable;

import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

public class UtilsTests {
    
    private static final ObjectMapper m = JSON.getMapper();

    @Test
    public void testOneOfDeserializerMatchesWhenStringIsSubSchema() throws JsonMappingException, JsonProcessingException {
        
        // invalid json
        assertThrows(JsonParseException.class, () -> m.readValue("a", Thing.class));
        assertThrows(JsonParseException.class, () -> m.readValue("\"", Thing.class));
        
        assertTrue(m.readValue("\"a\"", Thing.class).value() instanceof String);
        assertTrue(m.readValue("1", Thing.class).value() instanceof Long);
        assertTrue(m.readValue("1.0", Thing.class).value() instanceof Double);
        assertTrue(m.readValue("true", Thing.class).value() instanceof Boolean);
        
        // clashes with String
        try { 
            m.readValue("\"2022-10-02\"", Thing.class);
        } catch (JsonMappingException e) {
            assertTrue(e.getMessage().startsWith("json matched more than one of the possible type references, matches are: [java.lang.String, java.time.LocalDate]"));
        }
        
        assertTrue(m.readValue("0", Thing.class).value() instanceof Long);
        
    }
    
    @Test
    public void testOneOfDeserializerMatchesWhenNoStringSubSchema() throws JsonMappingException, JsonProcessingException {
        
        // invalid json
        assertThrows(JsonParseException.class, () -> m.readValue("a", Thing2.class));
        assertThrows(JsonParseException.class, () -> m.readValue("\"", Thing.class));
        
        try {
            m.readValue("\"abc\"", Thing2.class);
            Assertions.fail();
        } catch (JsonMappingException e) {
            assertTrue(e.getMessage().startsWith("json did not match any of the possible type references: [java.lang.Long, java.lang.Double, java.lang.Boolean, java.time.OffsetDateTime, java.time.LocalDate]"));
        }
        
        assertTrue(m.readValue("1", Thing2.class).value() instanceof Long);
        assertTrue(m.readValue("1.0", Thing2.class).value() instanceof Double);
        assertTrue(m.readValue("1e8", Thing2.class).value() instanceof Double);
        assertTrue(m.readValue("true", Thing2.class).value() instanceof Boolean);
        assertTrue(m.readValue("0", Thing2.class).value() instanceof Long);
        assertTrue(m.readValue("\"2022-10-02\"", Thing2.class).value() instanceof LocalDate);
        assertTrue(m.readValue("\"2022-10-02T23:59:59.000Z\"", Thing2.class).value() instanceof OffsetDateTime);
        
    }
    
    @Test
    public void testOneOfDeserializerLocalDateFromFullDateTime() throws JsonMappingException, JsonProcessingException {
        assertThrows(JsonMappingException.class, () -> m.readValue("\"2022-10-02T00:01:34.001Z\"", Thing3.class).value());
    }
    
    @Test
    public void testOneOfDeserializerIntegerFromDecimalWithExponentShouldThrow() throws JsonMappingException, JsonProcessingException {
        // asserts that deserialization is a bit forgiving
        assertThrows(JsonMappingException.class, () -> m.readValue("1.239e2", Thing4.class).value());
    }
    
    @Test
    public void testOneOfDeserializerBigIntegerString() throws JsonMappingException, JsonProcessingException {
        // asserts that deserialization is a bit forgiving
        long n =  ((BigInteger) m.readValue("\"123456789\"", Thing5.class).value()).longValue();
        // jackson will truncate digits after decimal point
        assertEquals(123456789L, n);
    }
    
    @JsonDeserialize(using = Thing._Deserializer.class)
    final static class Thing {
        
        @JsonValue
        @JsonSerialize(using = TypedObject.Serializer.class)
        public final TypedObject value;
        
        private Thing(TypedObject value) {
            this.value = value;
        }
        
        public Object value() {
            return value.value();
        }
        
        @SuppressWarnings("serial")
        public static final class _Deserializer extends org.openapis.openapi.utils.OneOfDeserializer<Thing> {

            public _Deserializer() {
                super(Thing.class,
                      TypeReferenceWithShape.of(new TypeReference<String>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<Long>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<Double>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<Boolean>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<OffsetDateTime>() {}, JsonShape.DEFAULT), 
                      TypeReferenceWithShape.of(new TypeReference<LocalDate>() {}, JsonShape.DEFAULT));
            }
        }
        
    }
    
    @JsonDeserialize(using = Thing2._Deserializer.class)
    final static class Thing2 {
        
        @JsonValue
        @JsonSerialize(using = TypedObject.Serializer.class)
        public final TypedObject value;
        
        private Thing2(TypedObject value) {
            this.value = value;
        }
        
        public Object value() {
            return value.value();
        }
        
        @SuppressWarnings("serial")
        public static final class _Deserializer extends org.openapis.openapi.utils.OneOfDeserializer<Thing2> {

            public _Deserializer() {
                super(Thing2.class,
                      TypeReferenceWithShape.of(new TypeReference<Long>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<Double>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<Boolean>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<OffsetDateTime>() {}, JsonShape.DEFAULT), 
                      TypeReferenceWithShape.of(new TypeReference<LocalDate>() {}, JsonShape.DEFAULT));
            }
        }
    }
    
    @JsonDeserialize(using = Thing3._Deserializer.class)
    final static class Thing3 {
        
        @JsonValue
        @JsonSerialize(using = TypedObject.Serializer.class)
        public final TypedObject value;
        
        private Thing3(TypedObject value) {
            this.value = value;
        }
        
        public Object value() {
            return value.value();
        }
        
        @SuppressWarnings("serial")
        public static final class _Deserializer extends org.openapis.openapi.utils.OneOfDeserializer<Thing3> {

            public _Deserializer() {
                super(Thing3.class,
                      TypeReferenceWithShape.of(new TypeReference<Long>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<LocalDate>() {}, JsonShape.DEFAULT));
            }
        }
    }
    
    @JsonDeserialize(using = Thing4._Deserializer.class)
    final static class Thing4 {
        
        @JsonValue
        @JsonSerialize(using = TypedObject.Serializer.class)
        public final TypedObject value;
        
        private Thing4(TypedObject value) {
            this.value = value;
        }
        
        public Object value() {
            return value.value();
        }
        
        @SuppressWarnings("serial")
        public static final class _Deserializer extends org.openapis.openapi.utils.OneOfDeserializer<Thing4> {

            public _Deserializer() {
                super(Thing4.class,
                        TypeReferenceWithShape.of(new TypeReference<Long>() {}, JsonShape.DEFAULT),
                        TypeReferenceWithShape.of(new TypeReference<String>() {}, JsonShape.DEFAULT));
            }
        }
    }
    
    @JsonDeserialize(using = Thing5._Deserializer.class)
    final static class Thing5 {
        
        @JsonValue
        @JsonSerialize(using = TypedObject.Serializer.class)
        public final TypedObject value;
        
        private Thing5(TypedObject value) {
            this.value = value;
        }
        
        public Object value() {
            return value.value();
        }
        
        @SuppressWarnings("serial")
        public static final class _Deserializer extends org.openapis.openapi.utils.OneOfDeserializer<Thing5> {

            public _Deserializer() {
                super(Thing5.class,
                        TypeReferenceWithShape.of(new TypeReference<BigInteger>() {}, JsonShape.STRING),
                        TypeReferenceWithShape.of(new TypeReference<LocalDate>() {}, JsonShape.DEFAULT));
            }
        }
    }
    
    @Test
    public void testBigIntegerString() throws JsonProcessingException {
        BigIntegerString s = new BigIntegerString(BigInteger.ONE);
        String json = "\"1\""; 
        assertEquals(json, JSON.getMapper().writeValueAsString(s));
        assertEquals(BigInteger.ONE, JSON.getMapper().readValue(json, BigIntegerString.class).value());
    }
    
    @Test
    public void testNestedReplacementOfBigIntegerWithBigIntegerStr() {
        List<List<Map<String, BigInteger>>> a = new ArrayList<>();
        a.add(List.of(Map.of("one", BigInteger.ONE, "two", BigInteger.TWO)));
        @SuppressWarnings("unchecked")
        List<List<Map<String, BigIntegerString>>> b = (List<List<Map<String, BigIntegerString>>>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<List<List<Map<String, BigInteger>>>>() {
                });
        assertEquals(a.get(0).get(0).get("one"), b.get(0).get(0).get("one").value());
        assertEquals(a.get(0).get(0).get("two"), b.get(0).get(0).get("two").value());
    }
    
    @Test
    public void testNestedReplacementOfIntegerDoesNothing() {
        List<List<Map<String, Integer>>> a = new ArrayList<>();
        a.add(List.of(Map.of("one", 1, "two", 2)));
        Object b =  Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<List<List<Map<String, Integer>>>>() {
                });
        assertEquals(a, b);
    }
    
    @Test
    public void testReplacementOfOptionalBigInteger() {
        Optional<BigInteger> a = Optional.of(BigInteger.ONE);
        @SuppressWarnings("unchecked")
        Optional<BigIntegerString> b =  (Optional<BigIntegerString>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<Optional<BigInteger>>() {
                });
        assertEquals(a.get(), b.get().value());
    }
    
    @Test
    public void testReplacementOfOptionalBigIntegerWhenEmpty() {
        Optional<BigInteger> a = Optional.empty();
        @SuppressWarnings("unchecked")
        Optional<BigIntegerString> b =  (Optional<BigIntegerString>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<Optional<BigInteger>>() {
                });
        assertFalse(b.isPresent());
    }
    
    @Test
    public void testReplacementOfJsonNullableBigInteger() {
        JsonNullable<BigInteger> a = JsonNullable.of(BigInteger.ONE);
        @SuppressWarnings("unchecked")
        JsonNullable<BigIntegerString> b =  (JsonNullable<BigIntegerString>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<JsonNullable<BigInteger>>() {
                });
        assertEquals(a.get(), b.get().value());
    }
    
    @Test
    public void testReplacementOfJsonNullableBigIntegerWhenNull() {
        JsonNullable<BigInteger> a = JsonNullable.of(null);
        @SuppressWarnings("unchecked")
        JsonNullable<BigIntegerString> b =  (JsonNullable<BigIntegerString>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<JsonNullable<BigInteger>>() {
                });
        assertNull(b.get());
    }
    
    @Test
    public void testReplacementOfJsonNullableBigIntegerWhenNotPresent() {
        JsonNullable<BigInteger> a = JsonNullable.undefined();
        @SuppressWarnings("unchecked")
        JsonNullable<BigIntegerString> b =  (JsonNullable<BigIntegerString>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<JsonNullable<BigInteger>>() {
                });
        assertFalse(b.isPresent());
    }
    
    @Test
    public void testTypedObjectSerializer() throws JsonProcessingException {
        TypedObject o = TypedObject.of(LocalDate.of(2024,  12, 23), JsonShape.DEFAULT, new TypeReference<LocalDate>() {});
        assertEquals("\"2024-12-23\"", JSON.getMapper().writeValueAsString(o));
    }

    @Test
    public void testStreamWithUnlimitedElements() {
        int[] n = new int[] {1};
        Callable<Optional<Integer>> c = () -> Optional.of(n[0]);
        Stream<Integer> stream = Utils.stream(c, x -> Optional.of(++n[0]));
        assertEquals(Arrays.asList(1, 2, 3, 4), stream.limit(4).collect(Collectors.toList()));
    }
    
    @Test
    public void testStreamWithLimitedElements() {
        int[] n = new int[] {1};
        Callable<Optional<Integer>> c = () ->  Optional.of(n[0]);
        Stream<Integer> stream = Utils.stream(c, x -> n[0] == 3 ? Optional.empty():Optional.of(++n[0]));
        assertEquals(Arrays.asList(1, 2, 3), stream.collect(Collectors.toList()));
    }
    
    @Test
    public void testStreamWithNoElements() {
        Callable<Optional<Integer>> c = () ->  Optional.empty();
        Stream<Integer> stream = Utils.stream(c, x -> Optional.of(1));
        assertTrue(stream.collect(Collectors.toList()).isEmpty());
    }
}
