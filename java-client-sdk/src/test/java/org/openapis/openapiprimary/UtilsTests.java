/* 
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

package org.openapis.openapi;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

import java.io.ByteArrayInputStream;
import java.io.InputStream;
import java.math.BigInteger;
import java.net.URI;
import java.net.URISyntaxException;
import java.net.http.HttpClient.Version;
import java.net.http.HttpHeaders;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.nio.charset.StandardCharsets;
import java.time.LocalDate;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.Callable;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import javax.net.ssl.SSLSession;

import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.openapis.openapi.utils.BigIntegerString;
import org.openapis.openapi.utils.Hook.AfterErrorContextImpl;
import org.openapis.openapi.utils.Hooks;
import org.openapis.openapi.utils.Hooks.FailEarlyException;
import org.openapis.openapi.utils.JSON;
import org.openapis.openapi.utils.TypedObject;
import org.openapis.openapi.utils.Utils;
import org.openapis.openapi.utils.Utils.JsonShape;
import org.openapis.openapi.utils.Utils.TypeReferenceWithShape;
import org.openapitools.jackson.nullable.JsonNullable;

import com.fasterxml.jackson.annotation.JsonValue;
import com.fasterxml.jackson.core.JsonParseException;
import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.JsonMappingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.fasterxml.jackson.databind.annotation.JsonSerialize;

public class UtilsTests {
    
    private static final ObjectMapper m = JSON.getMapper();

    @Test
    public void testOneOfDeserializerMatchesWhenStringIsSubSchema() throws JsonMappingException, JsonProcessingException {
        
        // invalid json
        assertThrows(JsonParseException.class, () -> m.readValue("a", Thing.class));
        assertThrows(JsonParseException.class, () -> m.readValue("\"", Thing.class));
        
        assertTrue(m.readValue("\"a\"", Thing.class).value() instanceof String);
        assertTrue(m.readValue("1", Thing.class).value() instanceof Long);
        assertTrue(m.readValue("1.0", Thing.class).value() instanceof Double);
        assertTrue(m.readValue("true", Thing.class).value() instanceof Boolean);
        
        // clashes with String
        try { 
            m.readValue("\"2022-10-02\"", Thing.class);
        } catch (JsonMappingException e) {
            assertTrue(e.getMessage().startsWith("json matched more than one of the possible type references, matches are: [java.lang.String, java.time.LocalDate]"));
        }
        
        assertTrue(m.readValue("0", Thing.class).value() instanceof Long);
        
    }
    
    @Test
    public void testOneOfDeserializerMatchesWhenNoStringSubSchema() throws JsonMappingException, JsonProcessingException {
        
        // invalid json
        assertThrows(JsonParseException.class, () -> m.readValue("a", Thing2.class));
        assertThrows(JsonParseException.class, () -> m.readValue("\"", Thing.class));
        
        try {
            m.readValue("\"abc\"", Thing2.class);
            Assertions.fail();
        } catch (JsonMappingException e) {
            assertTrue(e.getMessage().startsWith("json did not match any of the possible type references: [java.lang.Long, java.lang.Double, java.lang.Boolean, java.time.OffsetDateTime, java.time.LocalDate]"));
        }
        
        assertTrue(m.readValue("1", Thing2.class).value() instanceof Long);
        assertTrue(m.readValue("1.0", Thing2.class).value() instanceof Double);
        assertTrue(m.readValue("1e8", Thing2.class).value() instanceof Double);
        assertTrue(m.readValue("true", Thing2.class).value() instanceof Boolean);
        assertTrue(m.readValue("0", Thing2.class).value() instanceof Long);
        assertTrue(m.readValue("\"2022-10-02\"", Thing2.class).value() instanceof LocalDate);
        assertTrue(m.readValue("\"2022-10-02T23:59:59.000Z\"", Thing2.class).value() instanceof OffsetDateTime);
        
    }
    
    @Test
    public void testOneOfDeserializerLocalDateFromFullDateTime() throws JsonMappingException, JsonProcessingException {
        assertThrows(JsonMappingException.class, () -> m.readValue("\"2022-10-02T00:01:34.001Z\"", Thing3.class).value());
    }
    
    @Test
    public void testOneOfDeserializerIntegerFromDecimalWithExponentShouldThrow() throws JsonMappingException, JsonProcessingException {
        // asserts that deserialization is a bit forgiving
        assertThrows(JsonMappingException.class, () -> m.readValue("1.239e2", Thing4.class).value());
    }
    
    @Test
    public void testOneOfDeserializerBigIntegerString() throws JsonMappingException, JsonProcessingException {
        // asserts that deserialization is a bit forgiving
        long n =  ((BigInteger) m.readValue("\"123456789\"", Thing5.class).value()).longValue();
        // jackson will truncate digits after decimal point
        assertEquals(123456789L, n);
    }
    
    @JsonDeserialize(using = Thing._Deserializer.class)
    final static class Thing {
        
        @JsonValue
        @JsonSerialize(using = TypedObject.Serializer.class)
        public final TypedObject value;
        
        private Thing(TypedObject value) {
            this.value = value;
        }
        
        public Object value() {
            return value.value();
        }
        
        @SuppressWarnings("serial")
        public static final class _Deserializer extends org.openapis.openapi.utils.OneOfDeserializer<Thing> {

            public _Deserializer() {
                super(Thing.class,
                      true,
                      TypeReferenceWithShape.of(new TypeReference<String>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<Long>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<Double>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<Boolean>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<OffsetDateTime>() {}, JsonShape.DEFAULT), 
                      TypeReferenceWithShape.of(new TypeReference<LocalDate>() {}, JsonShape.DEFAULT));
            }
        }
        
    }
    
    @JsonDeserialize(using = Thing2._Deserializer.class)
    final static class Thing2 {
        
        @JsonValue
        @JsonSerialize(using = TypedObject.Serializer.class)
        public final TypedObject value;
        
        private Thing2(TypedObject value) {
            this.value = value;
        }
        
        public Object value() {
            return value.value();
        }
        
        @SuppressWarnings("serial")
        public static final class _Deserializer extends org.openapis.openapi.utils.OneOfDeserializer<Thing2> {

            public _Deserializer() {
                super(Thing2.class,
                      true,
                      TypeReferenceWithShape.of(new TypeReference<Long>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<Double>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<Boolean>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<OffsetDateTime>() {}, JsonShape.DEFAULT), 
                      TypeReferenceWithShape.of(new TypeReference<LocalDate>() {}, JsonShape.DEFAULT));
            }
        }
    }
    
    @JsonDeserialize(using = Thing3._Deserializer.class)
    final static class Thing3 {
        
        @JsonValue
        @JsonSerialize(using = TypedObject.Serializer.class)
        public final TypedObject value;
        
        private Thing3(TypedObject value) {
            this.value = value;
        }
        
        public Object value() {
            return value.value();
        }
        
        @SuppressWarnings("serial")
        public static final class _Deserializer extends org.openapis.openapi.utils.OneOfDeserializer<Thing3> {

            public _Deserializer() {
                super(Thing3.class,
                      true,
                      TypeReferenceWithShape.of(new TypeReference<Long>() {}, JsonShape.DEFAULT),
                      TypeReferenceWithShape.of(new TypeReference<LocalDate>() {}, JsonShape.DEFAULT));
            }
        }
    }
    
    @JsonDeserialize(using = Thing4._Deserializer.class)
    final static class Thing4 {
        
        @JsonValue
        @JsonSerialize(using = TypedObject.Serializer.class)
        public final TypedObject value;
        
        private Thing4(TypedObject value) {
            this.value = value;
        }
        
        public Object value() {
            return value.value();
        }
        
        @SuppressWarnings("serial")
        public static final class _Deserializer extends org.openapis.openapi.utils.OneOfDeserializer<Thing4> {

            public _Deserializer() {
                super(Thing4.class,
                        true,
                        TypeReferenceWithShape.of(new TypeReference<Long>() {}, JsonShape.DEFAULT),
                        TypeReferenceWithShape.of(new TypeReference<String>() {}, JsonShape.DEFAULT));
            }
        }
    }
    
    @JsonDeserialize(using = Thing5._Deserializer.class)
    final static class Thing5 {
        
        @JsonValue
        @JsonSerialize(using = TypedObject.Serializer.class)
        public final TypedObject value;
        
        private Thing5(TypedObject value) {
            this.value = value;
        }
        
        public Object value() {
            return value.value();
        }
        
        @SuppressWarnings("serial")
        public static final class _Deserializer extends org.openapis.openapi.utils.OneOfDeserializer<Thing5> {

            public _Deserializer() {
                super(Thing5.class,
                        true,
                        TypeReferenceWithShape.of(new TypeReference<BigInteger>() {}, JsonShape.STRING),
                        TypeReferenceWithShape.of(new TypeReference<LocalDate>() {}, JsonShape.DEFAULT));
            }
        }
    }
    
    @Test
    public void testBigIntegerString() throws JsonProcessingException {
        BigIntegerString s = new BigIntegerString(BigInteger.ONE);
        String json = "\"1\""; 
        assertEquals(json, JSON.getMapper().writeValueAsString(s));
        assertEquals(BigInteger.ONE, JSON.getMapper().readValue(json, BigIntegerString.class).value());
    }
    
    @Test
    public void testNestedReplacementOfBigIntegerWithBigIntegerStr() {
        List<List<Map<String, BigInteger>>> a = new ArrayList<>();
        a.add(List.of(Map.of("one", BigInteger.ONE, "two", BigInteger.TWO)));
        @SuppressWarnings("unchecked")
        List<List<Map<String, BigIntegerString>>> b = (List<List<Map<String, BigIntegerString>>>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<List<List<Map<String, BigInteger>>>>() {
                });
        assertEquals(a.get(0).get(0).get("one"), b.get(0).get(0).get("one").value());
        assertEquals(a.get(0).get(0).get("two"), b.get(0).get(0).get("two").value());
    }
    
    @Test
    public void testNestedReplacementOfIntegerDoesNothing() {
        List<List<Map<String, Integer>>> a = new ArrayList<>();
        a.add(List.of(Map.of("one", 1, "two", 2)));
        Object b =  Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<List<List<Map<String, Integer>>>>() {
                });
        assertEquals(a, b);
    }
    
    @Test
    public void testReplacementOfOptionalBigInteger() {
        Optional<BigInteger> a = Optional.of(BigInteger.ONE);
        @SuppressWarnings("unchecked")
        Optional<BigIntegerString> b =  (Optional<BigIntegerString>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<Optional<BigInteger>>() {
                });
        assertEquals(a.get(), b.get().value());
    }
    
    @Test
    public void testReplacementOfOptionalBigIntegerWhenEmpty() {
        Optional<BigInteger> a = Optional.empty();
        @SuppressWarnings("unchecked")
        Optional<BigIntegerString> b =  (Optional<BigIntegerString>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<Optional<BigInteger>>() {
                });
        assertFalse(b.isPresent());
    }
    
    @Test
    public void testReplacementOfJsonNullableBigInteger() {
        JsonNullable<BigInteger> a = JsonNullable.of(BigInteger.ONE);
        @SuppressWarnings("unchecked")
        JsonNullable<BigIntegerString> b =  (JsonNullable<BigIntegerString>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<JsonNullable<BigInteger>>() {
                });
        assertEquals(a.get(), b.get().value());
    }
    
    @Test
    public void testReplacementOfJsonNullableBigIntegerWhenNull() {
        JsonNullable<BigInteger> a = JsonNullable.of(null);
        @SuppressWarnings("unchecked")
        JsonNullable<BigIntegerString> b =  (JsonNullable<BigIntegerString>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<JsonNullable<BigInteger>>() {
                });
        assertNull(b.get());
    }
    
    @Test
    public void testReplacementOfJsonNullableBigIntegerWhenNotPresent() {
        JsonNullable<BigInteger> a = JsonNullable.undefined();
        @SuppressWarnings("unchecked")
        JsonNullable<BigIntegerString> b =  (JsonNullable<BigIntegerString>) Utils
                .convertToShape(a, Utils.JsonShape.STRING, new TypeReference<JsonNullable<BigInteger>>() {
                });
        assertFalse(b.isPresent());
    }
    
    @Test
    public void testTypedObjectSerializer() throws JsonProcessingException {
        TypedObject o = TypedObject.of(LocalDate.of(2024,  12, 23), JsonShape.DEFAULT, new TypeReference<LocalDate>() {});
        assertEquals("\"2024-12-23\"", JSON.getMapper().writeValueAsString(o));
    }

    @Test
    public void testStreamWithUnlimitedElements() {
        int[] n = new int[] {1};
        Callable<Optional<Integer>> c = () -> Optional.of(n[0]);
        Stream<Integer> stream = Utils.stream(c, x -> Optional.of(++n[0]));
        assertEquals(Arrays.asList(1, 2, 3, 4), stream.limit(4).collect(Collectors.toList()));
    }
    
    @Test
    public void testStreamWithLimitedElements() {
        int[] n = new int[] {1};
        Callable<Optional<Integer>> c = () ->  Optional.of(n[0]);
        Stream<Integer> stream = Utils.stream(c, x -> n[0] == 3 ? Optional.empty():Optional.of(++n[0]));
        assertEquals(Arrays.asList(1, 2, 3), stream.collect(Collectors.toList()));
    }
    
    @Test
    public void testStreamWithNoElements() {
        Callable<Optional<Integer>> c = () ->  Optional.empty();
        Stream<Integer> stream = Utils.stream(c, x -> Optional.of(1));
        assertTrue(stream.collect(Collectors.toList()).isEmpty());
    }
    
    @Test
    public void testHooksWhenAfterErrorNotRegistered() {
        Hooks hooks = new Hooks();
        assertThrows(RuntimeException.class, () -> 
            hooks.afterError(
                    new AfterErrorContextImpl("opId", Optional.empty(), Optional.empty()),
                    Optional.empty(),
                    Optional.of(new RuntimeException("there"))),
            "there");
    }
    
    @Test
    public void testHooksOneAfterErrorRegisteredThrows() throws Exception {
        Hooks hooks = new Hooks();
        hooks.registerAfterError((context, response, error) -> {
            throw new RuntimeException("hello");
        });
        assertThrows(RuntimeException.class, () -> 
            hooks.afterError(
                    new AfterErrorContextImpl("opId", Optional.empty(), Optional.empty()),
                    Optional.empty(),
                    Optional.of(new RuntimeException("there"))),
            "hello");
    }
    
    @Test
    public void testHooksOneAfterErrorRegisteredReturnsResponse() throws Exception {
        Hooks hooks = new Hooks();
        hooks.registerAfterError((context, response, error) -> {
            return new MyHttpResponse();
        });
        assertEquals(234, hooks.afterError(
                    new AfterErrorContextImpl("opId", Optional.empty(), Optional.empty()),
                    Optional.empty(),
                    Optional.of(new RuntimeException("there"))).statusCode());
    }
    
    @Test
    public void testHooksTwoAfterErrorRegisteredFirstThrows() throws Exception {
        Hooks hooks = new Hooks();
        hooks.registerAfterError((context, response, error) -> {
            throw new RuntimeException("hello");
        });
        hooks.registerAfterError((context, response, error) -> {
            throw new RuntimeException("you", error.get());
        });
        
        // ensure that 2nd hook is passed exception thrown by first
        try {
            hooks.afterError(
                    new AfterErrorContextImpl("opId", Optional.empty(), Optional.empty()),
                Optional.empty(),
                Optional.of(new RuntimeException("there")));
            Assertions.fail();
        } catch (RuntimeException e) {
            assertEquals("you", e.getMessage());
            assertEquals("hello", e.getCause().getMessage());
        }
    }
    
    @Test
    public void testHooksTwoAfterErrorRegisteredFirstThrowsEarlyFail() throws Exception {
        AtomicInteger count = new AtomicInteger();
        Hooks hooks = new Hooks();
        RuntimeException err = new RuntimeException("hi");
        
        //register two but first throws FailEarly
        hooks.registerAfterError((context, response, error) -> {
            throw new FailEarlyException(err);
        });
        hooks.registerAfterError((context, response, error) -> {
            count.incrementAndGet();
            throw new RuntimeException("you");
        });
        try {
            hooks.afterError(
                    new AfterErrorContextImpl("opId", Optional.empty(), Optional.empty()),
                Optional.empty(),
                Optional.of(new RuntimeException("there")));
            Assertions.fail();
        } catch (RuntimeException e) {
            assertTrue(e == err);
        }
        assertEquals(0, count.get());
    }
    
    private static final class MyHttpResponse implements HttpResponse<InputStream> {

        @Override
        public int statusCode() {
            return 234;
        }

        @Override
        public HttpRequest request() {
            throw new UnsupportedOperationException();
        }

        @Override
        public Optional<HttpResponse<InputStream>> previousResponse() {
            return Optional.empty();
        }

        @Override
        public HttpHeaders headers() {
            return HttpHeaders.of(Collections.emptyMap(), (k, v)-> true);
        }

        @Override
        public InputStream body() {
            return new ByteArrayInputStream("hello there".getBytes(StandardCharsets.UTF_8));
        }

        @Override
        public Optional<SSLSession> sslSession() {
            return Optional.empty();
        }

        @Override
        public URI uri() {
            try {
                return new URI("https://localhost");
            } catch (URISyntaxException e) {
                throw new RuntimeException(e);
            }
        }

        @Override
        public Version version() {
            return Version.HTTP_1_1;
        }
    }
    
    @Test
    public void testStatusCodeMatching() {
        assertFalse(Utils.statusCodeMatchesOne(100, "101"));
        assertFalse(Utils.statusCodeMatchesOne(100, "200"));
        assertTrue(Utils.statusCodeMatchesOne(100, "100"));
        assertTrue(Utils.statusCodeMatchesOne(123, "1XX"));
        assertFalse(Utils.statusCodeMatchesOne(123, "1YY"));
        assertTrue(Utils.statusCodeMatchesOne(345, "3XX"));
        
        assertFalse(Utils.statusCodeMatches(100));
        assertFalse(Utils.statusCodeMatches(100, "101", "200"));
        assertTrue(Utils.statusCodeMatches(200, "101", "200"));
    }
    
    @Test
    public void testToHex() {
        String hex = Utils.bytesToLowerCaseHex("hello there".getBytes(StandardCharsets.UTF_8));
        assertEquals("68656c6c6f207468657265", hex);
    }
    
    @Test
    public void testDiscriminatorToString() {
        assertEquals("boo", Utils.discriminatorToString("boo"));
        assertEquals("boo", Utils.discriminatorToString(Optional.of("boo")));
        assertNull(Utils.discriminatorToString(Optional.empty()));
        assertEquals("boo", Utils.discriminatorToString(Enum1.BOO));
    }
    
    public enum Enum1 {
        BOO("boo");
        private final String value;

        private Enum1(String value) {
            this.value = value;
        }
        
        public String value() {
            return value;
        }
    }
}
