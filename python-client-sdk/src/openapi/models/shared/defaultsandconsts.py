"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import date, datetime
import dateutil.parser
from decimal import Decimal
from enum import Enum
from openapi.types import BaseModel, Nullable, OptionalNullable, UNSET_SENTINEL
from openapi.utils import (
    serialize_decimal,
    serialize_int,
    validate_decimal,
    validate_int,
)
import pydantic
from pydantic import model_serializer
from pydantic.functional_serializers import PlainSerializer
from pydantic.functional_validators import BeforeValidator
from typing import Final, Literal, Optional, TypedDict
from typing_extensions import Annotated, NotRequired


class ConstEnumInt(int, Enum):
    ONE = 1
    TWO = 2
    THREE = 3


class ConstEnumStr(str, Enum):
    ONE = "one"
    TWO = "two"
    THREE = "three"


class DefaultEnumInt(int, Enum):
    ONE = 1
    TWO = 2
    THREE = 3


class DefaultEnumStr(str, Enum):
    ONE = "one"
    TWO = "two"
    THREE = "three"


class DefaultsAndConstsTypedDict(TypedDict):
    normal_field: str
    const_big_int: Literal[9007199254740991]
    const_big_int_str: Literal[9223372036854775807]
    const_bool: Literal[True]
    const_date: date
    const_date_time: datetime
    const_decimal: Decimal
    const_decimal_str: Decimal
    const_enum_int: ConstEnumInt
    const_enum_str: ConstEnumStr
    const_int: Literal[123]
    const_num: float
    const_str: Literal["const"]
    const_str_d_quotes: Literal['const with "double quotes"']
    const_str_null: Literal[None]
    const_str_s_quotes: Literal["const with 'single quotes'"]
    default_big_int: NotRequired[int]
    default_big_int_str: NotRequired[int]
    default_bool: NotRequired[bool]
    default_date: NotRequired[date]
    default_date_time: NotRequired[datetime]
    default_decimal: NotRequired[Decimal]
    default_decimal_str: NotRequired[Decimal]
    default_enum_int: NotRequired[DefaultEnumInt]
    default_enum_str: NotRequired[DefaultEnumStr]
    default_int: NotRequired[int]
    default_num: NotRequired[float]
    default_str: NotRequired[str]
    default_str_d_quotes: NotRequired[str]
    default_str_nullable: NotRequired[Nullable[str]]
    default_str_optional: NotRequired[str]
    default_str_s_quotes: NotRequired[str]


class DefaultsAndConsts(BaseModel):
    normal_field: Annotated[str, pydantic.Field(alias="normalField")]

    # fmt: off
    CONST_BIG_INT: Annotated[Final[Annotated[int, BeforeValidator(validate_int)]], pydantic.Field(alias="constBigInt")] = 9007199254740991 # type: ignore
    # fmt: on

    # fmt: off
    CONST_BIG_INT_STR: Annotated[Final[Annotated[int, BeforeValidator(validate_int), PlainSerializer(serialize_int(True))]], pydantic.Field(alias="constBigIntStr")] = 9223372036854775807 # type: ignore
    # fmt: on

    # fmt: off
    CONST_BOOL: Annotated[Final[bool], pydantic.Field(alias="constBool")] = True # type: ignore
    # fmt: on

    # fmt: off
    CONST_DATE: Annotated[Final[date], pydantic.Field(alias="constDate")] = dateutil.parser.parse("2020-01-01").date() # type: ignore
    # fmt: on

    # fmt: off
    CONST_DATE_TIME: Annotated[Final[datetime], pydantic.Field(alias="constDateTime")] = dateutil.parser.isoparse("2020-01-01T00:00:00Z") # type: ignore
    # fmt: on

    # fmt: off
    CONST_DECIMAL: Annotated[Final[Annotated[Decimal, BeforeValidator(validate_decimal), PlainSerializer(serialize_decimal(False))]], pydantic.Field(alias="constDecimal")] = Decimal("3.141592653589793") # type: ignore
    # fmt: on

    # fmt: off
    CONST_DECIMAL_STR: Annotated[Final[Annotated[Decimal, BeforeValidator(validate_decimal), PlainSerializer(serialize_decimal(True))]], pydantic.Field(alias="constDecimalStr")] = Decimal("3.141592653589793238462643383279") # type: ignore
    # fmt: on

    # fmt: off
    CONST_ENUM_INT: Annotated[Final[ConstEnumInt], pydantic.Field(alias="constEnumInt")] = ConstEnumInt.TWO # type: ignore
    # fmt: on

    # fmt: off
    CONST_ENUM_STR: Annotated[Final[ConstEnumStr], pydantic.Field(alias="constEnumStr")] = ConstEnumStr.TWO # type: ignore
    # fmt: on

    # fmt: off
    CONST_INT: Annotated[Final[int], pydantic.Field(alias="constInt")] = 123 # type: ignore
    # fmt: on

    # fmt: off
    CONST_NUM: Annotated[Final[float], pydantic.Field(alias="constNum")] = 123.456 # type: ignore
    # fmt: on

    # fmt: off
    CONST_STR: Annotated[Final[str], pydantic.Field(alias="constStr")] = "const" # type: ignore
    # fmt: on

    # fmt: off
    CONST_STR_D_QUOTES: Annotated[Final[str], pydantic.Field(alias="constStrDQuotes")] = "const with \"double quotes\"" # type: ignore
    # fmt: on

    # fmt: off
    CONST_STR_NULL: Annotated[Final[Nullable[str]], pydantic.Field(alias="constStrNull")] = None # type: ignore
    # fmt: on

    # fmt: off
    CONST_STR_S_QUOTES: Annotated[Final[str], pydantic.Field(alias="constStrSQuotes")] = "const with 'single quotes'" # type: ignore
    # fmt: on

    default_big_int: Annotated[
        Annotated[Optional[int], BeforeValidator(validate_int)],
        pydantic.Field(alias="defaultBigInt"),
    ] = 9007199254740991

    default_big_int_str: Annotated[
        Annotated[
            Optional[int],
            BeforeValidator(validate_int),
            PlainSerializer(serialize_int(True)),
        ],
        pydantic.Field(alias="defaultBigIntStr"),
    ] = 9223372036854775807

    default_bool: Annotated[Optional[bool], pydantic.Field(alias="defaultBool")] = True

    default_date: Annotated[Optional[date], pydantic.Field(alias="defaultDate")] = (
        dateutil.parser.parse("2020-01-01").date()
    )

    default_date_time: Annotated[
        Optional[datetime], pydantic.Field(alias="defaultDateTime")
    ] = dateutil.parser.isoparse("2020-01-01T00:00:00Z")

    default_decimal: Annotated[
        Annotated[
            Optional[Decimal],
            BeforeValidator(validate_decimal),
            PlainSerializer(serialize_decimal(False)),
        ],
        pydantic.Field(alias="defaultDecimal"),
    ] = Decimal("3.141592653589793")

    default_decimal_str: Annotated[
        Annotated[
            Optional[Decimal],
            BeforeValidator(validate_decimal),
            PlainSerializer(serialize_decimal(True)),
        ],
        pydantic.Field(alias="defaultDecimalStr"),
    ] = Decimal("3.141592653589793238462643383279")

    default_enum_int: Annotated[
        Optional[DefaultEnumInt], pydantic.Field(alias="defaultEnumInt")
    ] = DefaultEnumInt.TWO

    default_enum_str: Annotated[
        Optional[DefaultEnumStr], pydantic.Field(alias="defaultEnumStr")
    ] = DefaultEnumStr.TWO

    default_int: Annotated[Optional[int], pydantic.Field(alias="defaultInt")] = 123

    default_num: Annotated[Optional[float], pydantic.Field(alias="defaultNum")] = (
        123.456
    )

    default_str: Annotated[Optional[str], pydantic.Field(alias="defaultStr")] = (
        "default"
    )

    default_str_d_quotes: Annotated[
        Optional[str], pydantic.Field(alias="defaultStrDQuotes")
    ] = 'default with "double quotes"'

    default_str_nullable: Annotated[
        OptionalNullable[str], pydantic.Field(alias="defaultStrNullable")
    ] = None

    default_str_optional: Annotated[
        Optional[str], pydantic.Field(alias="defaultStrOptional")
    ] = "default"

    default_str_s_quotes: Annotated[
        Optional[str], pydantic.Field(alias="defaultStrSQuotes")
    ] = "default with 'single quotes'"

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "defaultBigInt",
            "defaultBigIntStr",
            "defaultBool",
            "defaultDate",
            "defaultDateTime",
            "defaultDecimal",
            "defaultDecimalStr",
            "defaultEnumInt",
            "defaultEnumStr",
            "defaultInt",
            "defaultNum",
            "defaultStr",
            "defaultStrDQuotes",
            "defaultStrNullable",
            "defaultStrOptional",
            "defaultStrSQuotes",
        ]
        nullable_fields = ["constStrNull", "defaultStrNullable"]
        null_default_fields = ["defaultStrNullable"]

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
