"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .enum import EnumT
from datetime import date, datetime
from decimal import Decimal
from enum import Enum
from openapi.types import BaseModel, Nullable, OptionalNullable, UNSET, UNSET_SENTINEL
from openapi.utils import (
    FieldMetadata,
    serialize_decimal,
    serialize_float,
    serialize_int,
    validate_decimal,
    validate_float,
    validate_int,
)
import pydantic
from pydantic import model_serializer
from pydantic.functional_serializers import PlainSerializer
from pydantic.functional_validators import BeforeValidator
from typing import Any, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class Int32Enum(int, Enum):
    r"""An int32 enum property."""

    FIFTY_FIVE = 55
    SIXTY_NINE = 69
    ONE_HUNDRED_AND_EIGHTY_ONE = 181


class IntEnum(int, Enum):
    r"""An integer enum property."""

    FIRST = 1
    SECOND = 2
    THIRD = 3


class SimpleObjectTypedDict(TypedDict):
    r"""A simple object that uses all our supported primitive types and enums and has optional properties.
    https://speakeasy.com/docs - A link to the external docs.
    """

    any: Any
    r"""An any property."""
    bool_: bool
    r"""A boolean property."""
    date_: date
    r"""A date property."""
    date_time: datetime
    r"""A date-time property."""
    enum: EnumT
    r"""A string based enum"""
    float32: float
    r"""A float32 property."""
    int_: int
    r"""An integer property."""
    int32: int
    r"""An int32 property."""
    int32_enum: Int32Enum
    r"""An int32 enum property."""
    int_enum: IntEnum
    r"""An integer enum property."""
    num: float
    r"""A number property."""
    str_: str
    r"""A string property."""
    bigint: NotRequired[int]
    bigint_str: NotRequired[int]
    bool_opt: NotRequired[bool]
    r"""An optional boolean property."""
    decimal: NotRequired[Decimal]
    decimal_nullable_opt: NotRequired[Nullable[Decimal]]
    decimal_str: NotRequired[Decimal]
    float64_str: NotRequired[float]
    r"""A float64 string"""
    int64_str: NotRequired[int]
    r"""An int64 string"""
    int_opt_null: NotRequired[int]
    r"""An optional integer property will be null for tests."""
    num_opt_null: NotRequired[float]
    r"""An optional number property will be null for tests."""
    str_opt: NotRequired[str]
    r"""An optional string property."""


class SimpleObject(BaseModel):
    r"""A simple object that uses all our supported primitive types and enums and has optional properties.
    https://speakeasy.com/docs - A link to the external docs.
    """

    any: Annotated[
        Any,
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""An any property."""

    bool_: Annotated[
        bool,
        pydantic.Field(alias="bool"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""A boolean property."""

    date_: Annotated[
        date,
        pydantic.Field(alias="date"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""A date property."""

    date_time: Annotated[
        datetime,
        pydantic.Field(alias="dateTime"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""A date-time property."""

    enum: Annotated[
        EnumT,
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""A string based enum"""

    float32: Annotated[
        float,
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""A float32 property."""

    int_: Annotated[
        int,
        pydantic.Field(alias="int"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""An integer property."""

    int32: Annotated[
        int,
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""An int32 property."""

    int32_enum: Annotated[
        Int32Enum,
        pydantic.Field(alias="int32Enum"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""An int32 enum property."""

    int_enum: Annotated[
        IntEnum,
        pydantic.Field(alias="intEnum"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""An integer enum property."""

    num: Annotated[
        float,
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""A number property."""

    str_: Annotated[
        str,
        pydantic.Field(alias="str"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ]
    r"""A string property."""

    bigint: Annotated[
        Annotated[Optional[int], BeforeValidator(validate_int)],
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ] = None

    bigint_str: Annotated[
        Annotated[
            Optional[int],
            BeforeValidator(validate_int),
            PlainSerializer(serialize_int(True)),
        ],
        pydantic.Field(alias="bigintStr"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ] = None

    bool_opt: Annotated[
        Optional[bool],
        pydantic.Field(alias="boolOpt"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ] = None
    r"""An optional boolean property."""

    decimal: Annotated[
        Annotated[
            Optional[Decimal],
            BeforeValidator(validate_decimal),
            PlainSerializer(serialize_decimal(False)),
        ],
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ] = None

    decimal_nullable_opt: Annotated[
        Annotated[
            OptionalNullable[Decimal],
            BeforeValidator(validate_decimal),
            PlainSerializer(serialize_decimal(False)),
        ],
        pydantic.Field(alias="decimalNullableOpt"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ] = UNSET

    decimal_str: Annotated[
        Annotated[
            Optional[Decimal],
            BeforeValidator(validate_decimal),
            PlainSerializer(serialize_decimal(True)),
        ],
        pydantic.Field(alias="decimalStr"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ] = None

    float64_str: Annotated[
        Annotated[
            Optional[float],
            BeforeValidator(validate_float),
            PlainSerializer(serialize_float(True)),
        ],
        pydantic.Field(alias="float64Str"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ] = None
    r"""A float64 string"""

    int64_str: Annotated[
        Annotated[
            Optional[int],
            BeforeValidator(validate_int),
            PlainSerializer(serialize_int(True)),
        ],
        pydantic.Field(alias="int64Str"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ] = None
    r"""An int64 string"""

    int_opt_null: Annotated[
        Optional[int],
        pydantic.Field(alias="intOptNull"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ] = None
    r"""An optional integer property will be null for tests."""

    num_opt_null: Annotated[
        Optional[float],
        pydantic.Field(alias="numOptNull"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ] = None
    r"""An optional number property will be null for tests."""

    str_opt: Annotated[
        Optional[str],
        pydantic.Field(alias="strOpt"),
        FieldMetadata(header=True, path=True, query=True, form=True, multipart=True),
    ] = None
    r"""An optional string property."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = [
            "bigint",
            "bigintStr",
            "boolOpt",
            "decimal",
            "decimalNullableOpt",
            "decimalStr",
            "float64Str",
            "int64Str",
            "intOptNull",
            "numOptNull",
            "strOpt",
        ]
        nullable_fields = ["decimalNullableOpt"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in self.model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
