"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from jsonpath import JSONPath
from openapi import utils
from openapi._hooks import HookContext
from openapi.models import errors, operations, shared
from openapi.types import BaseModel, OptionalNullable, UNSET
from typing import Any, Dict, Optional, Union, cast


class Pagination(BaseSDK):
    r"""Endpoints for testing the pagination extension"""

    def pagination_ambiguous_input(
        self,
        *,
        request_body: Union[
            operations.PaginationAmbiguousInputRequestBody,
            operations.PaginationAmbiguousInputRequestBodyTypedDict,
        ],
        cursor: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationAmbiguousInputResponse]:
        r"""This is a paginated operation where there is both a query parameter and
        request body field called \"cursor\". This ambiguity is used to test that
        the generator only updates the appropriate field in the pagination code
        \"next()\" function.

        :param request_body:
        :param cursor:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_AMBIGUOUS_INPUT_SERVERS[0]

        request = operations.PaginationAmbiguousInputRequest(
            cursor=cursor,
            request_body=utils.get_pydantic_model(
                request_body, operations.PaginationAmbiguousInputRequestBody
            ),
        )

        req = self.build_request(
            method="PUT",
            path="/pagination/cursor#ambiguousInput",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                operations.PaginationAmbiguousInputRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationAmbiguousInput",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationAmbiguousInputResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_ambiguous_input(
                cursor=cursor,
                request_body=operations.PaginationAmbiguousInputRequestBody(
                    cursor=next_cursor,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationAmbiguousInputResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationAmbiguousInputRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_ambiguous_input_async(
        self,
        *,
        request_body: Union[
            operations.PaginationAmbiguousInputRequestBody,
            operations.PaginationAmbiguousInputRequestBodyTypedDict,
        ],
        cursor: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationAmbiguousInputResponse]:
        r"""This is a paginated operation where there is both a query parameter and
        request body field called \"cursor\". This ambiguity is used to test that
        the generator only updates the appropriate field in the pagination code
        \"next()\" function.

        :param request_body:
        :param cursor:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_AMBIGUOUS_INPUT_SERVERS[0]

        request = operations.PaginationAmbiguousInputRequest(
            cursor=cursor,
            request_body=utils.get_pydantic_model(
                request_body, operations.PaginationAmbiguousInputRequestBody
            ),
        )

        req = self.build_request_async(
            method="PUT",
            path="/pagination/cursor#ambiguousInput",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.request_body,
                False,
                False,
                "json",
                operations.PaginationAmbiguousInputRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationAmbiguousInput",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationAmbiguousInputResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_ambiguous_input(
                cursor=cursor,
                request_body=operations.PaginationAmbiguousInputRequestBody(
                    cursor=next_cursor,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationAmbiguousInputResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationAmbiguousInputRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_body_flattened_optional_security(
        self,
        *,
        limit: int,
        offset: int,
        security: Optional[
            Union[
                operations.PaginationBodyFlattenedOptionalSecuritySecurity,
                operations.PaginationBodyFlattenedOptionalSecuritySecurityTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationBodyFlattenedOptionalSecurityResponse]:
        r"""
        :param limit:
        :param offset:
        :param security:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_BODY_FLATTENED_OPTIONAL_SECURITY_SERVERS[0]

        request = operations.PaginationBodyFlattenedOptionalSecurityRequest(
            limit=limit,
            offset=offset,
        )

        req = self.build_request(
            method="GET",
            path="/pagination/limitoffset/offset#paginationBodyFlattenedOptionalSecurity",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=utils.get_pydantic_model(
                security,
                Optional[operations.PaginationBodyFlattenedOptionalSecuritySecurity],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationBodyFlattenedOptionalSecurity",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.PaginationBodyFlattenedOptionalSecurityResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_body_flattened_optional_security(
                limit=limit,
                offset=next_offset,
                security=security,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationBodyFlattenedOptionalSecurityResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationBodyFlattenedOptionalSecurityRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_body_flattened_optional_security_async(
        self,
        *,
        limit: int,
        offset: int,
        security: Optional[
            Union[
                operations.PaginationBodyFlattenedOptionalSecuritySecurity,
                operations.PaginationBodyFlattenedOptionalSecuritySecurityTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationBodyFlattenedOptionalSecurityResponse]:
        r"""
        :param limit:
        :param offset:
        :param security:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_BODY_FLATTENED_OPTIONAL_SECURITY_SERVERS[0]

        request = operations.PaginationBodyFlattenedOptionalSecurityRequest(
            limit=limit,
            offset=offset,
        )

        req = self.build_request_async(
            method="GET",
            path="/pagination/limitoffset/offset#paginationBodyFlattenedOptionalSecurity",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=utils.get_pydantic_model(
                security,
                Optional[operations.PaginationBodyFlattenedOptionalSecuritySecurity],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationBodyFlattenedOptionalSecurity",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.PaginationBodyFlattenedOptionalSecurityResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_body_flattened_optional_security(
                limit=limit,
                offset=next_offset,
                security=security,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationBodyFlattenedOptionalSecurityResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationBodyFlattenedOptionalSecurityRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_body_flattened_with_security(
        self,
        *,
        security: Union[
            operations.PaginationBodyFlattenedWithSecuritySecurity,
            operations.PaginationBodyFlattenedWithSecuritySecurityTypedDict,
        ],
        limit: int,
        offset: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationBodyFlattenedWithSecurityResponse]:
        r"""
        :param security:
        :param limit:
        :param offset:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_BODY_FLATTENED_WITH_SECURITY_SERVERS[0]

        request = operations.PaginationBodyFlattenedWithSecurityRequest(
            limit=limit,
            offset=offset,
        )

        req = self.build_request(
            method="GET",
            path="/pagination/limitoffset/offset#paginationBodyFlattenedWithSecurity",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=utils.get_pydantic_model(
                security, operations.PaginationBodyFlattenedWithSecuritySecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationBodyFlattenedWithSecurity",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.PaginationBodyFlattenedWithSecurityResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_body_flattened_with_security(
                security=security,
                limit=limit,
                offset=next_offset,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationBodyFlattenedWithSecurityResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationBodyFlattenedWithSecurityRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_body_flattened_with_security_async(
        self,
        *,
        security: Union[
            operations.PaginationBodyFlattenedWithSecuritySecurity,
            operations.PaginationBodyFlattenedWithSecuritySecurityTypedDict,
        ],
        limit: int,
        offset: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationBodyFlattenedWithSecurityResponse]:
        r"""
        :param security:
        :param limit:
        :param offset:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_BODY_FLATTENED_WITH_SECURITY_SERVERS[0]

        request = operations.PaginationBodyFlattenedWithSecurityRequest(
            limit=limit,
            offset=offset,
        )

        req = self.build_request_async(
            method="GET",
            path="/pagination/limitoffset/offset#paginationBodyFlattenedWithSecurity",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=utils.get_pydantic_model(
                security, operations.PaginationBodyFlattenedWithSecuritySecurity
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationBodyFlattenedWithSecurity",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.PaginationBodyFlattenedWithSecurityResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_body_flattened_with_security(
                security=security,
                limit=limit,
                offset=next_offset,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationBodyFlattenedWithSecurityResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationBodyFlattenedWithSecurityRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_body_wrapped_request(
        self,
        *,
        request: Union[
            operations.PaginationBodyWrappedRequestRequest,
            operations.PaginationBodyWrappedRequestRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationBodyWrappedRequestResponse]:
        r"""This operation has a request wrapper type that encapsulates the
        parameters and request body. The pagination inputs are meant to go in
        the request body and we want to test that the generator correctly
        generates the next() function call preserving everything from the
        original request and interpolating the next pagination inputs.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_BODY_WRAPPED_REQUEST_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(
                request, operations.PaginationBodyWrappedRequestRequest
            )
        request = cast(operations.PaginationBodyWrappedRequestRequest, request)

        req = self.build_request(
            method="PUT",
            path="/pagination/limitoffset/page#paginationBodyWrappedRequest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.limit_offset_config,
                False,
                False,
                "json",
                shared.LimitOffsetConfig,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationBodyWrappedRequest",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationBodyWrappedRequestResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = (
                request.limit_offset_config.page
                if not request.limit_offset_config.page is None
                else 0
            )
            next_page = page + 1

            num_pages = JSONPath("$.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_body_wrapped_request(
                request=operations.PaginationBodyWrappedRequestRequest(
                    limit_offset_config=request.limit_offset_config,
                    idempotency_key=request.idempotency_key,
                    request_id=request.request_id,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationBodyWrappedRequestResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationBodyWrappedRequestRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_body_wrapped_request_async(
        self,
        *,
        request: Union[
            operations.PaginationBodyWrappedRequestRequest,
            operations.PaginationBodyWrappedRequestRequestTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationBodyWrappedRequestResponse]:
        r"""This operation has a request wrapper type that encapsulates the
        parameters and request body. The pagination inputs are meant to go in
        the request body and we want to test that the generator correctly
        generates the next() function call preserving everything from the
        original request and interpolating the next pagination inputs.

        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_BODY_WRAPPED_REQUEST_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(
                request, operations.PaginationBodyWrappedRequestRequest
            )
        request = cast(operations.PaginationBodyWrappedRequestRequest, request)

        req = self.build_request_async(
            method="PUT",
            path="/pagination/limitoffset/page#paginationBodyWrappedRequest",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.limit_offset_config,
                False,
                False,
                "json",
                shared.LimitOffsetConfig,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationBodyWrappedRequest",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationBodyWrappedRequestResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = (
                request.limit_offset_config.page
                if not request.limit_offset_config.page is None
                else 0
            )
            next_page = page + 1

            num_pages = JSONPath("$.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_body_wrapped_request(
                request=operations.PaginationBodyWrappedRequestRequest(
                    limit_offset_config=request.limit_offset_config,
                    idempotency_key=request.idempotency_key,
                    request_id=request.request_id,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationBodyWrappedRequestResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationBodyWrappedRequestRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_cursor_body(
        self,
        *,
        request: Union[
            operations.PaginationCursorBodyRequestBody,
            operations.PaginationCursorBodyRequestBodyTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationCursorBodyResponse]:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_BODY_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(
                request, operations.PaginationCursorBodyRequestBody
            )
        request = cast(operations.PaginationCursorBodyRequestBody, request)

        req = self.build_request(
            method="PUT",
            path="/pagination/cursor",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                operations.PaginationCursorBodyRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationCursorBody",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationCursorBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_body(
                request=operations.PaginationCursorBodyRequestBody(
                    cursor=next_cursor,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorBodyResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationCursorBodyRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_cursor_body_async(
        self,
        *,
        request: Union[
            operations.PaginationCursorBodyRequestBody,
            operations.PaginationCursorBodyRequestBodyTypedDict,
        ],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationCursorBodyResponse]:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_BODY_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(
                request, operations.PaginationCursorBodyRequestBody
            )
        request = cast(operations.PaginationCursorBodyRequestBody, request)

        req = self.build_request_async(
            method="PUT",
            path="/pagination/cursor",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request,
                False,
                False,
                "json",
                operations.PaginationCursorBodyRequestBody,
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationCursorBody",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationCursorBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_body(
                request=operations.PaginationCursorBodyRequestBody(
                    cursor=next_cursor,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorBodyResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationCursorBodyRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_cursor_non_numeric(
        self,
        *,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationCursorNonNumericResponse]:
        r"""
        :param cursor: The page token used to request a specific page of the search results
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_NON_NUMERIC_SERVERS[0]

        request = operations.PaginationCursorNonNumericRequest(
            cursor=cursor,
        )

        req = self.build_request(
            method="GET",
            path="/pagination/cursor_non_numeric",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationCursorNonNumeric",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationCursorNonNumericResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_non_numeric(
                cursor=next_cursor,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorNonNumericResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationCursorNonNumericRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_cursor_non_numeric_async(
        self,
        *,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationCursorNonNumericResponse]:
        r"""
        :param cursor: The page token used to request a specific page of the search results
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_NON_NUMERIC_SERVERS[0]

        request = operations.PaginationCursorNonNumericRequest(
            cursor=cursor,
        )

        req = self.build_request_async(
            method="GET",
            path="/pagination/cursor_non_numeric",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationCursorNonNumeric",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationCursorNonNumericResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_non_numeric(
                cursor=next_cursor,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorNonNumericResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationCursorNonNumericRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_cursor_params(
        self,
        *,
        cursor: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationCursorParamsResponse]:
        r"""
        :param cursor:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_PARAMS_SERVERS[0]

        request = operations.PaginationCursorParamsRequest(
            cursor=cursor,
        )

        req = self.build_request(
            method="GET",
            path="/pagination/cursor",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationCursorParams",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationCursorParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_params(
                cursor=next_cursor,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorParamsResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationCursorParamsRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_cursor_params_async(
        self,
        *,
        cursor: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationCursorParamsResponse]:
        r"""
        :param cursor:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_PARAMS_SERVERS[0]

        request = operations.PaginationCursorParamsRequest(
            cursor=cursor,
        )

        req = self.build_request_async(
            method="GET",
            path="/pagination/cursor",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationCursorParams",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationCursorParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_params(
                cursor=next_cursor,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorParamsResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationCursorParamsRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_limit_offset_deep_outputs_page_body(
        self,
        *,
        request: Union[
            shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict
        ] = shared.LimitOffsetConfig(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationLimitOffsetDeepOutputsPageBodyResponse]:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = (
                operations.PAGINATION_LIMIT_OFFSET_DEEP_OUTPUTS_PAGE_BODY_SERVERS[0]
            )

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)

        req = self.build_request(
            method="PUT",
            path="/pagination/limitoffset/deep_outputs/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[shared.LimitOffsetConfig]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationLimitOffsetDeepOutputsPageBody",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.PaginationLimitOffsetDeepOutputsPageBodyResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page if not request.page is None else 0
            next_page = page + 1

            num_pages = JSONPath("$.pageInfo.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_limit_offset_deep_outputs_page_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=request.offset,
                    page=next_page,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetDeepOutputsPageBodyResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationLimitOffsetDeepOutputsPageBodyRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_limit_offset_deep_outputs_page_body_async(
        self,
        *,
        request: Union[
            shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict
        ] = shared.LimitOffsetConfig(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationLimitOffsetDeepOutputsPageBodyResponse]:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = (
                operations.PAGINATION_LIMIT_OFFSET_DEEP_OUTPUTS_PAGE_BODY_SERVERS[0]
            )

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)

        req = self.build_request_async(
            method="PUT",
            path="/pagination/limitoffset/deep_outputs/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[shared.LimitOffsetConfig]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationLimitOffsetDeepOutputsPageBody",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.PaginationLimitOffsetDeepOutputsPageBodyResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page if not request.page is None else 0
            next_page = page + 1

            num_pages = JSONPath("$.pageInfo.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_limit_offset_deep_outputs_page_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=request.offset,
                    page=next_page,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetDeepOutputsPageBodyResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationLimitOffsetDeepOutputsPageBodyRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_limit_offset_offset_body(
        self,
        *,
        request: Union[
            shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict
        ] = shared.LimitOffsetConfig(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationLimitOffsetOffsetBodyResponse]:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_OFFSET_BODY_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)

        req = self.build_request(
            method="PUT",
            path="/pagination/limitoffset/offset",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[shared.LimitOffsetConfig]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationLimitOffsetOffsetBody",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationLimitOffsetOffsetBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset if not request.offset is None else 0

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit if not request.limit is None else 0
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=next_offset,
                    page=request.page,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetOffsetBodyResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationLimitOffsetOffsetBodyRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_limit_offset_offset_body_async(
        self,
        *,
        request: Union[
            shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict
        ] = shared.LimitOffsetConfig(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationLimitOffsetOffsetBodyResponse]:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_OFFSET_BODY_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)

        req = self.build_request_async(
            method="PUT",
            path="/pagination/limitoffset/offset",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[shared.LimitOffsetConfig]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationLimitOffsetOffsetBody",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationLimitOffsetOffsetBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset if not request.offset is None else 0

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit if not request.limit is None else 0
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=next_offset,
                    page=request.page,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetOffsetBodyResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationLimitOffsetOffsetBodyRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_limit_offset_offset_params(
        self,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationLimitOffsetOffsetParamsResponse]:
        r"""
        :param limit:
        :param offset:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_OFFSET_PARAMS_SERVERS[0]

        request = operations.PaginationLimitOffsetOffsetParamsRequest(
            limit=limit,
            offset=offset,
        )

        req = self.build_request(
            method="GET",
            path="/pagination/limitoffset/offset",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationLimitOffsetOffsetParams",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.PaginationLimitOffsetOffsetParamsResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset if not request.offset is None else 0

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit if not request.limit is None else 0
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_params(
                limit=limit,
                offset=next_offset,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetOffsetParamsResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationLimitOffsetOffsetParamsRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_limit_offset_offset_params_async(
        self,
        *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationLimitOffsetOffsetParamsResponse]:
        r"""
        :param limit:
        :param offset:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_OFFSET_PARAMS_SERVERS[0]

        request = operations.PaginationLimitOffsetOffsetParamsRequest(
            limit=limit,
            offset=offset,
        )

        req = self.build_request_async(
            method="GET",
            path="/pagination/limitoffset/offset",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationLimitOffsetOffsetParams",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> (
            Optional[operations.PaginationLimitOffsetOffsetParamsResponse]
        ):
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset if not request.offset is None else 0

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit if not request.limit is None else 0
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_params(
                limit=limit,
                offset=next_offset,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetOffsetParamsResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationLimitOffsetOffsetParamsRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_limit_offset_page_body(
        self,
        *,
        request: Union[
            shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict
        ] = shared.LimitOffsetConfig(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationLimitOffsetPageBodyResponse]:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_PAGE_BODY_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)

        req = self.build_request(
            method="PUT",
            path="/pagination/limitoffset/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[shared.LimitOffsetConfig]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationLimitOffsetPageBody",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationLimitOffsetPageBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page if not request.page is None else 0
            next_page = page + 1

            num_pages = JSONPath("$.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_limit_offset_page_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=request.offset,
                    page=next_page,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetPageBodyResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationLimitOffsetPageBodyRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_limit_offset_page_body_async(
        self,
        *,
        request: Union[
            shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict
        ] = shared.LimitOffsetConfig(),
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationLimitOffsetPageBodyResponse]:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_PAGE_BODY_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)

        req = self.build_request_async(
            method="PUT",
            path="/pagination/limitoffset/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request, False, True, "json", Optional[shared.LimitOffsetConfig]
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationLimitOffsetPageBody",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationLimitOffsetPageBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page if not request.page is None else 0
            next_page = page + 1

            num_pages = JSONPath("$.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_limit_offset_page_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=request.offset,
                    page=next_page,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetPageBodyResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationLimitOffsetPageBodyRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_limit_offset_page_params(
        self,
        *,
        page: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationLimitOffsetPageParamsResponse]:
        r"""
        :param page:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_PAGE_PARAMS_SERVERS[0]

        request = operations.PaginationLimitOffsetPageParamsRequest(
            page=page,
        )

        req = self.build_request(
            method="GET",
            path="/pagination/limitoffset/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationLimitOffsetPageParams",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationLimitOffsetPageParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page
            next_page = page + 1

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None

            return self.pagination_limit_offset_page_params(
                page=next_page,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetPageParamsResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationLimitOffsetPageParamsRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_limit_offset_page_params_async(
        self,
        *,
        page: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationLimitOffsetPageParamsResponse]:
        r"""
        :param page:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_PAGE_PARAMS_SERVERS[0]

        request = operations.PaginationLimitOffsetPageParamsRequest(
            page=page,
        )

        req = self.build_request_async(
            method="GET",
            path="/pagination/limitoffset/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationLimitOffsetPageParams",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationLimitOffsetPageParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page
            next_page = page + 1

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None

            return self.pagination_limit_offset_page_params(
                page=next_page,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetPageParamsResponse(
                result=utils.unmarshal_json(
                    http_res.text,
                    Optional[operations.PaginationLimitOffsetPageParamsRes],
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_url_params(
        self,
        *,
        attempts: int,
        is_reference_path: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        url_override: Optional[str] = None,
    ) -> Optional[operations.PaginationURLParamsResponse]:
        r"""
        :param attempts:
        :param is_reference_path:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_URL_PARAMS_SERVERS[0]

        request = operations.PaginationURLParamsRequest(
            attempts=attempts,
            is_reference_path=is_reference_path,
        )

        req = self.build_request(
            method="GET",
            path="/pagination/url",
            base_url=base_url,
            url_variables=url_variables,
            url_override=url_override,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationURLParams",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationURLParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_url_match = JSONPath("$.next").parse(body)
            if len(next_url_match) == 0:
                return None

            next_url = next_url_match[0]
            if not next_url:
                return None

            if next_url[0] == "/":
                url = self.get_url(base_url, url_variables)
                next_url = url + next_url

            return self.pagination_url_params(
                attempts=attempts,
                is_reference_path=is_reference_path,
                retries=retries,
                server_url=server_url,
                url_override=next_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationURLParamsResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationURLParamsRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_url_params_async(
        self,
        *,
        attempts: int,
        is_reference_path: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        url_override: Optional[str] = None,
    ) -> Optional[operations.PaginationURLParamsResponse]:
        r"""
        :param attempts:
        :param is_reference_path:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_URL_PARAMS_SERVERS[0]

        request = operations.PaginationURLParamsRequest(
            attempts=attempts,
            is_reference_path=is_reference_path,
        )

        req = self.build_request_async(
            method="GET",
            path="/pagination/url",
            base_url=base_url,
            url_variables=url_variables,
            url_override=url_override,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationURLParams",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationURLParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_url_match = JSONPath("$.next").parse(body)
            if len(next_url_match) == 0:
                return None

            next_url = next_url_match[0]
            if not next_url:
                return None

            if next_url[0] == "/":
                url = self.get_url(base_url, url_variables)
                next_url = url + next_url

            return self.pagination_url_params(
                attempts=attempts,
                is_reference_path=is_reference_path,
                retries=retries,
                server_url=server_url,
                url_override=next_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationURLParamsResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationURLParamsRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_with_retries(
        self,
        *,
        cursor: Optional[str] = None,
        fault_settings: Optional[str] = '{"error_code": 503, "error_count": 3}',
        request_id: Optional[str] = "paginationWithRetries",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationWithRetriesResponse]:
        r"""
        :param cursor: The page token used to request a specific page of the search results
        :param fault_settings:
        :param request_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_WITH_RETRIES_SERVERS[0]

        request = operations.PaginationWithRetriesRequest(
            cursor=cursor,
            fault_settings=fault_settings,
            request_id=request_id,
        )

        req = self.build_request(
            method="GET",
            path="/pagination/cursor_non_numeric#withRetries",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(10, 100, 1.5, 1000), False
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["503"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationWithRetries",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationWithRetriesResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_with_retries(
                cursor=next_cursor,
                fault_settings=fault_settings,
                request_id=request_id,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationWithRetriesResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationWithRetriesRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_with_retries_async(
        self,
        *,
        cursor: Optional[str] = None,
        fault_settings: Optional[str] = '{"error_code": 503, "error_count": 3}',
        request_id: Optional[str] = "paginationWithRetries",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationWithRetriesResponse]:
        r"""
        :param cursor: The page token used to request a specific page of the search results
        :param fault_settings:
        :param request_id:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_WITH_RETRIES_SERVERS[0]

        request = operations.PaginationWithRetriesRequest(
            cursor=cursor,
            fault_settings=fault_settings,
            request_id=request_id,
        )

        req = self.build_request_async(
            method="GET",
            path="/pagination/cursor_non_numeric#withRetries",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff", utils.BackoffStrategy(10, 100, 1.5, 1000), False
                )

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["503"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationWithRetries",
                oauth2_scopes=[],
                security_source=self.sdk_configuration.security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationWithRetriesResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_with_retries(
                cursor=next_cursor,
                fault_settings=fault_settings,
                request_id=request_id,
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationWithRetriesResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationWithRetriesRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    def pagination_wrapped_optional_body(
        self,
        *,
        request: Union[
            operations.PaginationWrappedOptionalBodyRequest,
            operations.PaginationWrappedOptionalBodyRequestTypedDict,
        ] = operations.PaginationWrappedOptionalBodyRequest(),
        security: Optional[
            Union[
                operations.PaginationWrappedOptionalBodySecurity,
                operations.PaginationWrappedOptionalBodySecurityTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationWrappedOptionalBodyResponse]:
        r"""
        :param request: The request object to send.
        :param security:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_WRAPPED_OPTIONAL_BODY_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(
                request, operations.PaginationWrappedOptionalBodyRequest
            )
        request = cast(operations.PaginationWrappedOptionalBodyRequest, request)

        req = self.build_request(
            method="PUT",
            path="/pagination/limitoffset/offset#paginationWrappedOptionalBody",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=utils.get_pydantic_model(
                security, Optional[operations.PaginationWrappedOptionalBodySecurity]
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.limit_offset_config,
                False,
                True,
                "json",
                Optional[shared.LimitOffsetConfig],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = self.do_request(
            hook_ctx=HookContext(
                operation_id="paginationWrappedOptionalBody",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationWrappedOptionalBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = (
                request.limit_offset_config.offset
                if not request.limit_offset_config.offset is None
                else 0
            )

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = (
                request.limit_offset_config.limit
                if not request.limit_offset_config.limit is None
                else 0
            )
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_wrapped_optional_body(
                request=operations.PaginationWrappedOptionalBodyRequest(
                    idempotency_key=request.idempotency_key,
                    limit_offset_config=request.limit_offset_config,
                    request_id=request.request_id,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationWrappedOptionalBodyResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationWrappedOptionalBodyRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = utils.stream_to_text(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )

    async def pagination_wrapped_optional_body_async(
        self,
        *,
        request: Union[
            operations.PaginationWrappedOptionalBodyRequest,
            operations.PaginationWrappedOptionalBodyRequestTypedDict,
        ] = operations.PaginationWrappedOptionalBodyRequest(),
        security: Optional[
            Union[
                operations.PaginationWrappedOptionalBodySecurity,
                operations.PaginationWrappedOptionalBodySecurityTypedDict,
            ]
        ] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> Optional[operations.PaginationWrappedOptionalBodyResponse]:
        r"""
        :param request: The request object to send.
        :param security:
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms

        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_WRAPPED_OPTIONAL_BODY_SERVERS[0]

        if not isinstance(request, BaseModel):
            request = utils.unmarshal(
                request, operations.PaginationWrappedOptionalBodyRequest
            )
        request = cast(operations.PaginationWrappedOptionalBodyRequest, request)

        req = self.build_request_async(
            method="PUT",
            path="/pagination/limitoffset/offset#paginationWrappedOptionalBody",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=utils.get_pydantic_model(
                security, Optional[operations.PaginationWrappedOptionalBodySecurity]
            ),
            get_serialized_body=lambda: utils.serialize_request_body(
                request.limit_offset_config,
                False,
                True,
                "json",
                Optional[shared.LimitOffsetConfig],
            ),
            timeout_ms=timeout_ms,
        )

        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])

        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                operation_id="paginationWrappedOptionalBody",
                oauth2_scopes=[],
                security_source=security,
            ),
            request=req,
            error_status_codes=["4XX", "5XX"],
            retry_config=retry_config,
        )

        def next_func() -> Optional[operations.PaginationWrappedOptionalBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = (
                request.limit_offset_config.offset
                if not request.limit_offset_config.offset is None
                else 0
            )

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = (
                request.limit_offset_config.limit
                if not request.limit_offset_config.limit is None
                else 0
            )
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_wrapped_optional_body(
                request=operations.PaginationWrappedOptionalBodyRequest(
                    idempotency_key=request.idempotency_key,
                    limit_offset_config=request.limit_offset_config,
                    request_id=request.request_id,
                ),
                retries=retries,
                server_url=server_url,
            )

        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationWrappedOptionalBodyResponse(
                result=utils.unmarshal_json(
                    http_res.text, Optional[operations.PaginationWrappedOptionalBodyRes]
                ),
                next=next_func,
            )
        if utils.match_response(http_res, ["4XX", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise errors.SDKError(
                "API error occurred", http_res.status_code, http_res_text, http_res
            )

        content_type = http_res.headers.get("Content-Type")
        http_res_text = await utils.stream_to_text_async(http_res)
        raise errors.SDKError(
            f"Unexpected response received (code: {http_res.status_code}, type: {content_type})",
            http_res.status_code,
            http_res_text,
            http_res,
        )
