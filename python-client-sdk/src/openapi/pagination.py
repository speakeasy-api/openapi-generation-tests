"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from jsonpath import JSONPath
from openapi import utils
from openapi._hooks import HookContext
from openapi.models import errors, operations, shared
from openapi.types import BaseModel, OptionalNullable, UNSET
from typing import Any, Dict, Optional, Union, cast

class Pagination(BaseSDK):
    r"""Endpoints for testing the pagination extension"""
    
    
    def pagination_cursor_body(
        self, *,
        request: Union[operations.PaginationCursorBodyRequestBody, operations.PaginationCursorBodyRequestBodyTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationCursorBodyResponse:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_BODY_SERVERS[0]
        
        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, operations.PaginationCursorBodyRequestBody)
        request = cast(operations.PaginationCursorBodyRequestBody, request)
        
        req = self.build_request(
            method="PUT",
            path="/pagination/cursor",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, False, "json", operations.PaginationCursorBodyRequestBody),
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="paginationCursorBody", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationCursorBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_body(
                request=operations.PaginationCursorBodyRequestBody(
                    cursor=next_cursor,
                ),
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorBodyResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationCursorBodyRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    async def pagination_cursor_body_async(
        self, *,
        request: Union[operations.PaginationCursorBodyRequestBody, operations.PaginationCursorBodyRequestBodyTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationCursorBodyResponse:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_BODY_SERVERS[0]
        
        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, operations.PaginationCursorBodyRequestBody)
        request = cast(operations.PaginationCursorBodyRequestBody, request)
        
        req = self.build_request(
            method="PUT",
            path="/pagination/cursor",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, False, "json", operations.PaginationCursorBodyRequestBody),
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="paginationCursorBody", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationCursorBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_body(
                request=operations.PaginationCursorBodyRequestBody(
                    cursor=next_cursor,
                ),
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorBodyResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationCursorBodyRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    def pagination_cursor_non_numeric(
        self, *,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationCursorNonNumericResponse:
        r"""
        :param cursor: The page token used to request a specific page of the search results
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_NON_NUMERIC_SERVERS[0]
        
        request = operations.PaginationCursorNonNumericRequest(
            cursor=cursor,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/cursor_non_numeric",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="paginationCursorNonNumeric", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationCursorNonNumericResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_non_numeric(
                cursor=next_cursor,
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorNonNumericResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationCursorNonNumericRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    async def pagination_cursor_non_numeric_async(
        self, *,
        cursor: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationCursorNonNumericResponse:
        r"""
        :param cursor: The page token used to request a specific page of the search results
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_NON_NUMERIC_SERVERS[0]
        
        request = operations.PaginationCursorNonNumericRequest(
            cursor=cursor,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/cursor_non_numeric",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="paginationCursorNonNumeric", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationCursorNonNumericResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_non_numeric(
                cursor=next_cursor,
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorNonNumericResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationCursorNonNumericRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    def pagination_cursor_params(
        self, *,
        cursor: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationCursorParamsResponse:
        r"""
        :param cursor: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_PARAMS_SERVERS[0]
        
        request = operations.PaginationCursorParamsRequest(
            cursor=cursor,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/cursor",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="paginationCursorParams", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationCursorParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_params(
                cursor=next_cursor,
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorParamsResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationCursorParamsRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    async def pagination_cursor_params_async(
        self, *,
        cursor: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationCursorParamsResponse:
        r"""
        :param cursor: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_CURSOR_PARAMS_SERVERS[0]
        
        request = operations.PaginationCursorParamsRequest(
            cursor=cursor,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/cursor",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="paginationCursorParams", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationCursorParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_params(
                cursor=next_cursor,
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationCursorParamsResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationCursorParamsRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    def pagination_limit_offset_deep_outputs_page_body(
        self, *,
        request: Union[shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationLimitOffsetDeepOutputsPageBodyResponse:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_DEEP_OUTPUTS_PAGE_BODY_SERVERS[0]
        
        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)
        
        req = self.build_request(
            method="PUT",
            path="/pagination/limitoffset/deep_outputs/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, False, "json", shared.LimitOffsetConfig),
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="paginationLimitOffsetDeepOutputsPageBody", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationLimitOffsetDeepOutputsPageBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page if not request.page is None else 0
            next_page = page + 1
            
            num_pages = JSONPath("$.pageInfo.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_limit_offset_deep_outputs_page_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=request.offset,
                    page=next_page,
                ),
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetDeepOutputsPageBodyResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetDeepOutputsPageBodyRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    async def pagination_limit_offset_deep_outputs_page_body_async(
        self, *,
        request: Union[shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationLimitOffsetDeepOutputsPageBodyResponse:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_DEEP_OUTPUTS_PAGE_BODY_SERVERS[0]
        
        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)
        
        req = self.build_request(
            method="PUT",
            path="/pagination/limitoffset/deep_outputs/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, False, "json", shared.LimitOffsetConfig),
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="paginationLimitOffsetDeepOutputsPageBody", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationLimitOffsetDeepOutputsPageBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page if not request.page is None else 0
            next_page = page + 1
            
            num_pages = JSONPath("$.pageInfo.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_limit_offset_deep_outputs_page_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=request.offset,
                    page=next_page,
                ),
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetDeepOutputsPageBodyResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetDeepOutputsPageBodyRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    def pagination_limit_offset_offset_body(
        self, *,
        request: Union[shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationLimitOffsetOffsetBodyResponse:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_OFFSET_BODY_SERVERS[0]
        
        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)
        
        req = self.build_request(
            method="PUT",
            path="/pagination/limitoffset/offset",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, False, "json", shared.LimitOffsetConfig),
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="paginationLimitOffsetOffsetBody", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationLimitOffsetOffsetBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset if not request.offset is None else 0

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit if not request.limit is None else 0
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=next_offset,
                    page=request.page,
                ),
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetOffsetBodyResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetOffsetBodyRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    async def pagination_limit_offset_offset_body_async(
        self, *,
        request: Union[shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationLimitOffsetOffsetBodyResponse:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_OFFSET_BODY_SERVERS[0]
        
        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)
        
        req = self.build_request(
            method="PUT",
            path="/pagination/limitoffset/offset",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, False, "json", shared.LimitOffsetConfig),
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="paginationLimitOffsetOffsetBody", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationLimitOffsetOffsetBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset if not request.offset is None else 0

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit if not request.limit is None else 0
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=next_offset,
                    page=request.page,
                ),
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetOffsetBodyResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetOffsetBodyRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    def pagination_limit_offset_offset_params(
        self, *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationLimitOffsetOffsetParamsResponse:
        r"""
        :param limit: 
        :param offset: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_OFFSET_PARAMS_SERVERS[0]
        
        request = operations.PaginationLimitOffsetOffsetParamsRequest(
            limit=limit,
            offset=offset,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/limitoffset/offset",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="paginationLimitOffsetOffsetParams", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationLimitOffsetOffsetParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset if not request.offset is None else 0

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit if not request.limit is None else 0
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_params(
                limit=limit,
                offset=next_offset,
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetOffsetParamsResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetOffsetParamsRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    async def pagination_limit_offset_offset_params_async(
        self, *,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationLimitOffsetOffsetParamsResponse:
        r"""
        :param limit: 
        :param offset: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_OFFSET_PARAMS_SERVERS[0]
        
        request = operations.PaginationLimitOffsetOffsetParamsRequest(
            limit=limit,
            offset=offset,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/limitoffset/offset",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="paginationLimitOffsetOffsetParams", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationLimitOffsetOffsetParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset if not request.offset is None else 0

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit = request.limit if not request.limit is None else 0
            if len(results[0]) < limit:
                return None
            next_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_params(
                limit=limit,
                offset=next_offset,
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetOffsetParamsResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetOffsetParamsRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    def pagination_limit_offset_page_body(
        self, *,
        request: Union[shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationLimitOffsetPageBodyResponse:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_PAGE_BODY_SERVERS[0]
        
        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)
        
        req = self.build_request(
            method="PUT",
            path="/pagination/limitoffset/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, False, "json", shared.LimitOffsetConfig),
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="paginationLimitOffsetPageBody", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationLimitOffsetPageBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page if not request.page is None else 0
            next_page = page + 1
            
            num_pages = JSONPath("$.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_limit_offset_page_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=request.offset,
                    page=next_page,
                ),
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetPageBodyResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetPageBodyRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    async def pagination_limit_offset_page_body_async(
        self, *,
        request: Union[shared.LimitOffsetConfig, shared.LimitOffsetConfigTypedDict],
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationLimitOffsetPageBodyResponse:
        r"""
        :param request: The request object to send.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_PAGE_BODY_SERVERS[0]
        
        if not isinstance(request, BaseModel):
            request = utils.unmarshal(request, shared.LimitOffsetConfig)
        request = cast(shared.LimitOffsetConfig, request)
        
        req = self.build_request(
            method="PUT",
            path="/pagination/limitoffset/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(request, False, False, "json", shared.LimitOffsetConfig),
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="paginationLimitOffsetPageBody", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationLimitOffsetPageBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page if not request.page is None else 0
            next_page = page + 1
            
            num_pages = JSONPath("$.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_limit_offset_page_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=request.offset,
                    page=next_page,
                ),
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetPageBodyResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetPageBodyRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    def pagination_limit_offset_page_params(
        self, *,
        page: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationLimitOffsetPageParamsResponse:
        r"""
        :param page: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_PAGE_PARAMS_SERVERS[0]
        
        request = operations.PaginationLimitOffsetPageParamsRequest(
            page=page,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/limitoffset/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="paginationLimitOffsetPageParams", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationLimitOffsetPageParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page
            next_page = page + 1
            

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None

            return self.pagination_limit_offset_page_params(
                page=next_page,
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetPageParamsResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetPageParamsRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    async def pagination_limit_offset_page_params_async(
        self, *,
        page: int,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationLimitOffsetPageParamsResponse:
        r"""
        :param page: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_LIMIT_OFFSET_PAGE_PARAMS_SERVERS[0]
        
        request = operations.PaginationLimitOffsetPageParamsRequest(
            page=page,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/limitoffset/page",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="paginationLimitOffsetPageParams", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationLimitOffsetPageParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page
            next_page = page + 1
            

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None

            return self.pagination_limit_offset_page_params(
                page=next_page,
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationLimitOffsetPageParamsResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetPageParamsRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    def pagination_url_params(
        self, *,
        attempts: int,
        is_reference_path: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        url_override: Optional[str] = None,
    ) -> operations.PaginationURLParamsResponse:
        r"""
        :param attempts: 
        :param is_reference_path: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_URL_PARAMS_SERVERS[0]
        
        request = operations.PaginationURLParamsRequest(
            attempts=attempts,
            is_reference_path=is_reference_path,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/url",
            base_url=base_url,
            url_variables=url_variables,
            url_override=url_override,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="paginationURLParams", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationURLParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_url_match = JSONPath("$.next").parse(body)
            if len(next_url_match) == 0:
                return None

            next_url = next_url_match[0]
            if not next_url:
                return None
            
            if next_url[0] == "/":
                url = self.get_url(base_url, url_variables)
                next_url = url + next_url

            return self.pagination_url_params(
                attempts=attempts,
                is_reference_path=is_reference_path,
                retries=retries,
                server_url=server_url,
                url_override=next_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationURLParamsResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationURLParamsRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    async def pagination_url_params_async(
        self, *,
        attempts: int,
        is_reference_path: Optional[str] = None,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        url_override: Optional[str] = None,
    ) -> operations.PaginationURLParamsResponse:
        r"""
        :param attempts: 
        :param is_reference_path: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_URL_PARAMS_SERVERS[0]
        
        request = operations.PaginationURLParamsRequest(
            attempts=attempts,
            is_reference_path=is_reference_path,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/url",
            base_url=base_url,
            url_variables=url_variables,
            url_override=url_override,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "429",
                "500",
                "502",
                "503",
                "504"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="paginationURLParams", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationURLParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_url_match = JSONPath("$.next").parse(body)
            if len(next_url_match) == 0:
                return None

            next_url = next_url_match[0]
            if not next_url:
                return None
            
            if next_url[0] == "/":
                url = self.get_url(base_url, url_variables)
                next_url = url + next_url

            return self.pagination_url_params(
                attempts=attempts,
                is_reference_path=is_reference_path,
                retries=retries,
                server_url=server_url,
                url_override=next_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationURLParamsResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationURLParamsRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    def pagination_with_retries(
        self, *,
        cursor: Optional[str] = None,
        fault_settings: Optional[str] = "{\"error_code\": 503, \"error_count\": 3}",
        request_id: Optional[str] = "paginationWithRetries",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationWithRetriesResponse:
        r"""
        :param cursor: The page token used to request a specific page of the search results
        :param fault_settings: 
        :param request_id: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_WITH_RETRIES_SERVERS[0]
        
        request = operations.PaginationWithRetriesRequest(
            cursor=cursor,
            fault_settings=fault_settings,
            request_id=request_id,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/cursor_non_numeric#withRetries",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig("backoff", utils.BackoffStrategy(10, 100, 1.5, 1000), False)

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "503"
            ])                
        
        http_res = self.do_request(
            hook_ctx=HookContext(operation_id="paginationWithRetries", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationWithRetriesResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_with_retries(
                cursor=next_cursor,
                fault_settings=fault_settings,
                request_id=request_id,
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationWithRetriesResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationWithRetriesRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
    
    async def pagination_with_retries_async(
        self, *,
        cursor: Optional[str] = None,
        fault_settings: Optional[str] = "{\"error_code\": 503, \"error_count\": 3}",
        request_id: Optional[str] = "paginationWithRetries",
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
    ) -> operations.PaginationWithRetriesResponse:
        r"""
        :param cursor: The page token used to request a specific page of the search results
        :param fault_settings: 
        :param request_id: 
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        
        if server_url is not None:
            base_url = server_url
        else:
            base_url = operations.PAGINATION_WITH_RETRIES_SERVERS[0]
        
        request = operations.PaginationWithRetriesRequest(
            cursor=cursor,
            fault_settings=fault_settings,
            request_id=request_id,
        )
        
        req = self.build_request(
            method="GET",
            path="/pagination/cursor_non_numeric#withRetries",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="x-speakeasy-user-agent",
            accept_header_value="application/json",
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig("backoff", utils.BackoffStrategy(10, 100, 1.5, 1000), False)

        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, [
                "503"
            ])                
        
        http_res = await self.do_request_async(
            hook_ctx=HookContext(operation_id="paginationWithRetries", oauth2_scopes=[], security_source=self.sdk_configuration.security),
            request=req,
            error_status_codes=["4XX","5XX"],
            retry_config=retry_config
        )
        
        def next_func() -> Optional[operations.PaginationWithRetriesResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_with_retries(
                cursor=next_cursor,
                fault_settings=fault_settings,
                request_id=request_id,
                retries=retries,
                server_url=server_url,
            )
        
        if utils.match_response(http_res, "200", "application/json"):
            return operations.PaginationWithRetriesResponse(result=utils.unmarshal_json(http_res.text, Optional[operations.PaginationWithRetriesRes]), next=next_func)
        if utils.match_response(http_res, ["4XX","5XX"], "*"):
            raise errors.SDKError("API error occurred", http_res.status_code, http_res.text, http_res)
        
        content_type = http_res.headers.get("Content-Type")
        raise errors.SDKError(f"Unexpected response received (code: {http_res.status_code}, type: {content_type})", http_res.status_code, http_res.text, http_res)

    
