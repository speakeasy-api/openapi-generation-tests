"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from .sdkconfiguration import SDKConfiguration
from sdk import utils
from sdk._hooks import HookContext
from sdk.models import errors, operations, shared
from typing import Optional

class AuthNew:
    r"""Endpoints for testing authentication."""
    sdk_configuration: SDKConfiguration

    def __init__(self, sdk_config: SDKConfiguration) -> None:
        self.sdk_configuration = sdk_config
        
    
    
    def auth_global(self, request: shared.AuthServiceRequestBody, server_url: Optional[str] = None) -> operations.AuthGlobalResponse:
        hook_ctx = HookContext(operation_id='authGlobal', oauth2_scopes=[], security_source=self.sdk_configuration.security)
        base_url = utils.template_url(operations.AUTH_GLOBAL_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/auth#authGlobal'
        
        if callable(self.sdk_configuration.security):
            headers, query_params = utils.get_security(self.sdk_configuration.security())
        else:
            headers, query_params = utils.get_security(self.sdk_configuration.security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.AuthServiceRequestBody, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = '*/*'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = self.sdk_configuration.get_hooks().before_request(
                hook_ctx, 
                requests_http.Request('POST', url, params=query_params, data=data, files=form, headers=headers).prepare(),
            )
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, None, e)
            raise e

        if utils.match_status_codes(['401','4XX','5XX'], http_res.status_code):
            http_res, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, http_res, None)
            if e:
                raise e
        else:
            result = self.sdk_configuration.get_hooks().after_success(hook_ctx, http_res)
            if isinstance(result, Exception):
                raise result
            http_res = result
        
        
        res = operations.AuthGlobalResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type'), raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 401 or http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def basic_auth_new(self, request: shared.AuthServiceRequestBody, security: operations.BasicAuthNewSecurity, server_url: Optional[str] = None) -> operations.BasicAuthNewResponse:
        hook_ctx = HookContext(operation_id='basicAuthNew', oauth2_scopes=[], security_source=security)
        base_url = utils.template_url(operations.BASIC_AUTH_NEW_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/auth#basicAuth'
        
        headers, query_params = utils.get_security(security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.AuthServiceRequestBody, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = '*/*'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = self.sdk_configuration.get_hooks().before_request(
                hook_ctx, 
                requests_http.Request('POST', url, params=query_params, data=data, files=form, headers=headers).prepare(),
            )
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, None, e)
            raise e

        if utils.match_status_codes(['401','4XX','5XX'], http_res.status_code):
            http_res, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, http_res, None)
            if e:
                raise e
        else:
            result = self.sdk_configuration.get_hooks().after_success(hook_ctx, http_res)
            if isinstance(result, Exception):
                raise result
            http_res = result
        
        
        res = operations.BasicAuthNewResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type'), raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 401 or http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def multiple_mixed_options_auth(self, request: shared.AuthServiceRequestBody, security: operations.MultipleMixedOptionsAuthSecurity, server_url: Optional[str] = None) -> operations.MultipleMixedOptionsAuthResponse:
        hook_ctx = HookContext(operation_id='multipleMixedOptionsAuth', oauth2_scopes=[], security_source=security)
        base_url = utils.template_url(operations.MULTIPLE_MIXED_OPTIONS_AUTH_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/auth#multipleMixedOptionsAuth'
        
        headers, query_params = utils.get_security(security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.AuthServiceRequestBody, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = '*/*'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = self.sdk_configuration.get_hooks().before_request(
                hook_ctx, 
                requests_http.Request('POST', url, params=query_params, data=data, files=form, headers=headers).prepare(),
            )
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, None, e)
            raise e

        if utils.match_status_codes(['401','4XX','5XX'], http_res.status_code):
            http_res, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, http_res, None)
            if e:
                raise e
        else:
            result = self.sdk_configuration.get_hooks().after_success(hook_ctx, http_res)
            if isinstance(result, Exception):
                raise result
            http_res = result
        
        
        res = operations.MultipleMixedOptionsAuthResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type'), raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 401 or http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def multiple_mixed_scheme_auth(self, request: shared.AuthServiceRequestBody, security: operations.MultipleMixedSchemeAuthSecurity, server_url: Optional[str] = None) -> operations.MultipleMixedSchemeAuthResponse:
        hook_ctx = HookContext(operation_id='multipleMixedSchemeAuth', oauth2_scopes=[], security_source=security)
        base_url = utils.template_url(operations.MULTIPLE_MIXED_SCHEME_AUTH_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/auth#multipleMixedSchemeAuth'
        
        headers, query_params = utils.get_security(security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.AuthServiceRequestBody, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = '*/*'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = self.sdk_configuration.get_hooks().before_request(
                hook_ctx, 
                requests_http.Request('POST', url, params=query_params, data=data, files=form, headers=headers).prepare(),
            )
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, None, e)
            raise e

        if utils.match_status_codes(['401','4XX','5XX'], http_res.status_code):
            http_res, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, http_res, None)
            if e:
                raise e
        else:
            result = self.sdk_configuration.get_hooks().after_success(hook_ctx, http_res)
            if isinstance(result, Exception):
                raise result
            http_res = result
        
        
        res = operations.MultipleMixedSchemeAuthResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type'), raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 401 or http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def multiple_options_with_mixed_schemes_auth(self, request: shared.AuthServiceRequestBody, security: operations.MultipleOptionsWithMixedSchemesAuthSecurity, server_url: Optional[str] = None) -> operations.MultipleOptionsWithMixedSchemesAuthResponse:
        hook_ctx = HookContext(operation_id='multipleOptionsWithMixedSchemesAuth', oauth2_scopes=[], security_source=security)
        base_url = utils.template_url(operations.MULTIPLE_OPTIONS_WITH_MIXED_SCHEMES_AUTH_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/auth#multipleOptionsWithMixedSchemesAuth'
        
        headers, query_params = utils.get_security(security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.AuthServiceRequestBody, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = '*/*'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = self.sdk_configuration.get_hooks().before_request(
                hook_ctx, 
                requests_http.Request('POST', url, params=query_params, data=data, files=form, headers=headers).prepare(),
            )
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, None, e)
            raise e

        if utils.match_status_codes(['401','4XX','5XX'], http_res.status_code):
            http_res, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, http_res, None)
            if e:
                raise e
        else:
            result = self.sdk_configuration.get_hooks().after_success(hook_ctx, http_res)
            if isinstance(result, Exception):
                raise result
            http_res = result
        
        
        res = operations.MultipleOptionsWithMixedSchemesAuthResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type'), raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 401 or http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def multiple_options_with_simple_schemes_auth(self, request: shared.AuthServiceRequestBody, security: operations.MultipleOptionsWithSimpleSchemesAuthSecurity, server_url: Optional[str] = None) -> operations.MultipleOptionsWithSimpleSchemesAuthResponse:
        hook_ctx = HookContext(operation_id='multipleOptionsWithSimpleSchemesAuth', oauth2_scopes=[], security_source=security)
        base_url = utils.template_url(operations.MULTIPLE_OPTIONS_WITH_SIMPLE_SCHEMES_AUTH_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/auth#multipleOptionsWithSimpleSchemesAuth'
        
        headers, query_params = utils.get_security(security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.AuthServiceRequestBody, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = '*/*'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = self.sdk_configuration.get_hooks().before_request(
                hook_ctx, 
                requests_http.Request('POST', url, params=query_params, data=data, files=form, headers=headers).prepare(),
            )
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, None, e)
            raise e

        if utils.match_status_codes(['401','4XX','5XX'], http_res.status_code):
            http_res, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, http_res, None)
            if e:
                raise e
        else:
            result = self.sdk_configuration.get_hooks().after_success(hook_ctx, http_res)
            if isinstance(result, Exception):
                raise result
            http_res = result
        
        
        res = operations.MultipleOptionsWithSimpleSchemesAuthResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type'), raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 401 or http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def multiple_simple_options_auth(self, request: shared.AuthServiceRequestBody, security: operations.MultipleSimpleOptionsAuthSecurity, server_url: Optional[str] = None) -> operations.MultipleSimpleOptionsAuthResponse:
        hook_ctx = HookContext(operation_id='multipleSimpleOptionsAuth', oauth2_scopes=[], security_source=security)
        base_url = utils.template_url(operations.MULTIPLE_SIMPLE_OPTIONS_AUTH_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/auth#multipleSimpleOptionsAuth'
        
        headers, query_params = utils.get_security(security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.AuthServiceRequestBody, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = '*/*'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = self.sdk_configuration.get_hooks().before_request(
                hook_ctx, 
                requests_http.Request('POST', url, params=query_params, data=data, files=form, headers=headers).prepare(),
            )
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, None, e)
            raise e

        if utils.match_status_codes(['401','4XX','5XX'], http_res.status_code):
            http_res, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, http_res, None)
            if e:
                raise e
        else:
            result = self.sdk_configuration.get_hooks().after_success(hook_ctx, http_res)
            if isinstance(result, Exception):
                raise result
            http_res = result
        
        
        res = operations.MultipleSimpleOptionsAuthResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type'), raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 401 or http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def multiple_simple_scheme_auth(self, request: shared.AuthServiceRequestBody, security: operations.MultipleSimpleSchemeAuthSecurity, server_url: Optional[str] = None) -> operations.MultipleSimpleSchemeAuthResponse:
        hook_ctx = HookContext(operation_id='multipleSimpleSchemeAuth', oauth2_scopes=[], security_source=security)
        base_url = utils.template_url(operations.MULTIPLE_SIMPLE_SCHEME_AUTH_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/auth#multipleSimpleSchemeAuth'
        
        headers, query_params = utils.get_security(security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.AuthServiceRequestBody, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = '*/*'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = self.sdk_configuration.get_hooks().before_request(
                hook_ctx, 
                requests_http.Request('POST', url, params=query_params, data=data, files=form, headers=headers).prepare(),
            )
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, None, e)
            raise e

        if utils.match_status_codes(['401','4XX','5XX'], http_res.status_code):
            http_res, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, http_res, None)
            if e:
                raise e
        else:
            result = self.sdk_configuration.get_hooks().after_success(hook_ctx, http_res)
            if isinstance(result, Exception):
                raise result
            http_res = result
        
        
        res = operations.MultipleSimpleSchemeAuthResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type'), raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 401 or http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def oauth2_auth_new(self, request: shared.AuthServiceRequestBody, security: operations.Oauth2AuthNewSecurity, server_url: Optional[str] = None) -> operations.Oauth2AuthNewResponse:
        hook_ctx = HookContext(operation_id='oauth2AuthNew', oauth2_scopes=[], security_source=security)
        base_url = utils.template_url(operations.OAUTH2_AUTH_NEW_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/auth#oauth2Auth'
        
        headers, query_params = utils.get_security(security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.AuthServiceRequestBody, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = '*/*'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = self.sdk_configuration.get_hooks().before_request(
                hook_ctx, 
                requests_http.Request('POST', url, params=query_params, data=data, files=form, headers=headers).prepare(),
            )
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, None, e)
            raise e

        if utils.match_status_codes(['401','4XX','5XX'], http_res.status_code):
            http_res, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, http_res, None)
            if e:
                raise e
        else:
            result = self.sdk_configuration.get_hooks().after_success(hook_ctx, http_res)
            if isinstance(result, Exception):
                raise result
            http_res = result
        
        
        res = operations.Oauth2AuthNewResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type'), raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 401 or http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def open_id_connect_auth_new(self, request: shared.AuthServiceRequestBody, security: operations.OpenIDConnectAuthNewSecurity, server_url: Optional[str] = None) -> operations.OpenIDConnectAuthNewResponse:
        hook_ctx = HookContext(operation_id='openIdConnectAuthNew', oauth2_scopes=[], security_source=security)
        base_url = utils.template_url(operations.OPEN_ID_CONNECT_AUTH_NEW_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/auth#openIdConnectAuth'
        
        headers, query_params = utils.get_security(security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.AuthServiceRequestBody, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = '*/*'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = self.sdk_configuration.get_hooks().before_request(
                hook_ctx, 
                requests_http.Request('POST', url, params=query_params, data=data, files=form, headers=headers).prepare(),
            )
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, None, e)
            raise e

        if utils.match_status_codes(['401','4XX','5XX'], http_res.status_code):
            http_res, e = self.sdk_configuration.get_hooks().after_error(hook_ctx, http_res, None)
            if e:
                raise e
        else:
            result = self.sdk_configuration.get_hooks().after_success(hook_ctx, http_res)
            if isinstance(result, Exception):
                raise result
            http_res = result
        
        
        res = operations.OpenIDConnectAuthNewResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type'), raw_response=http_res)
        
        if http_res.status_code == 200:
            pass
        elif http_res.status_code == 401 or http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    