"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

from .sdkconfiguration import SDKConfiguration
from jsonpath import JSONPath
from sdk import utils
from sdk.models import errors, operations, shared
from typing import Any, Dict, Optional

class Pagination:
    r"""Endpoints for testing the pagination extension"""
    sdk_configuration: SDKConfiguration

    def __init__(self, sdk_config: SDKConfiguration) -> None:
        self.sdk_configuration = sdk_config
        
    
    
    def pagination_cursor_body(self, request: operations.PaginationCursorBodyRequestBody, server_url: Optional[str] = None) -> operations.PaginationCursorBodyResponse:
        base_url = utils.template_url(operations.PAGINATION_CURSOR_BODY_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/cursor'
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, operations.PaginationCursorBodyRequestBody, "request", False, False, 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        
        if callable(self.sdk_configuration.security):
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security())
        else:
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')
        
        def next_func() -> Optional[operations.PaginationCursorBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_body(
                request=operations.PaginationCursorBodyRequestBody(
                    cursor=next_cursor,
                ),
                server_url=server_url,
            )
        
        res = operations.PaginationCursorBodyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationCursorBodyRes])
                res.res = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_cursor_params(self, cursor: int, server_url: Optional[str] = None) -> operations.PaginationCursorParamsResponse:
        request = operations.PaginationCursorParamsRequest(
            cursor=cursor,
        )
        
        base_url = utils.template_url(operations.PAGINATION_CURSOR_PARAMS_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/cursor'
        headers = {}
        query_params = utils.get_query_params(operations.PaginationCursorParamsRequest, request, self.sdk_configuration.globals)
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        
        if callable(self.sdk_configuration.security):
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security())
        else:
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security)
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')
        
        def next_func() -> Optional[operations.PaginationCursorParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_params(
                cursor=next_cursor,
                server_url=server_url,
            )
        
        res = operations.PaginationCursorParamsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationCursorParamsRes])
                res.res = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_limit_offset_offset_body(self, request: shared.LimitOffsetConfig, server_url: Optional[str] = None) -> operations.PaginationLimitOffsetOffsetBodyResponse:
        base_url = utils.template_url(operations.PAGINATION_LIMIT_OFFSET_OFFSET_BODY_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/limitoffset/offset'
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, shared.LimitOffsetConfig, "request", False, False, 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        
        if callable(self.sdk_configuration.security):
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security())
        else:
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')
        
        def next_func() -> Optional[operations.PaginationLimitOffsetOffsetBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit =request.limit
            if len(results[0]) < limit:
                return None
            new_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=new_offset,
                    page=request.page,
                ),
                server_url=server_url,
            )
        
        res = operations.PaginationLimitOffsetOffsetBodyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetOffsetBodyRes])
                res.res = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_limit_offset_offset_params(self, limit: Optional[int] = None, offset: Optional[int] = None, server_url: Optional[str] = None) -> operations.PaginationLimitOffsetOffsetParamsResponse:
        request = operations.PaginationLimitOffsetOffsetParamsRequest(
            limit=limit,
            offset=offset,
        )
        
        base_url = utils.template_url(operations.PAGINATION_LIMIT_OFFSET_OFFSET_PARAMS_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/limitoffset/offset'
        headers = {}
        query_params = utils.get_query_params(operations.PaginationLimitOffsetOffsetParamsRequest, request, self.sdk_configuration.globals)
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        
        if callable(self.sdk_configuration.security):
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security())
        else:
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security)
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')
        
        def next_func() -> Optional[operations.PaginationLimitOffsetOffsetParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit =request.limit
            if len(results[0]) < limit:
                return None
            new_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_params(
                limit=limit,
                offset=new_offset,
                server_url=server_url,
            )
        
        res = operations.PaginationLimitOffsetOffsetParamsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetOffsetParamsRes])
                res.res = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_limit_offset_page_body(self, request: shared.LimitOffsetConfig, server_url: Optional[str] = None) -> operations.PaginationLimitOffsetPageBodyResponse:
        base_url = utils.template_url(operations.PAGINATION_LIMIT_OFFSET_PAGE_BODY_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/limitoffset/page'
        headers = {}
        req_content_type, data, form = utils.serialize_request_body(request, shared.LimitOffsetConfig, "request", False, False, 'json')
        if req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        
        if callable(self.sdk_configuration.security):
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security())
        else:
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security)
        
        http_res = client.request('PUT', url, data=data, files=form, headers=headers)
        content_type = http_res.headers.get('Content-Type')
        
        def next_func() -> Optional[operations.PaginationLimitOffsetPageBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page
            new_page = page + 1
            
            num_pages = JSONPath("$.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_limit_offset_page_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=request.offset,
                    page=new_page,
                ),
                server_url=server_url,
            )
        
        res = operations.PaginationLimitOffsetPageBodyResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetPageBodyRes])
                res.res = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_limit_offset_page_params(self, page: int, server_url: Optional[str] = None) -> operations.PaginationLimitOffsetPageParamsResponse:
        request = operations.PaginationLimitOffsetPageParamsRequest(
            page=page,
        )
        
        base_url = utils.template_url(operations.PAGINATION_LIMIT_OFFSET_PAGE_PARAMS_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/limitoffset/page'
        headers = {}
        query_params = utils.get_query_params(operations.PaginationLimitOffsetPageParamsRequest, request, self.sdk_configuration.globals)
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        
        if callable(self.sdk_configuration.security):
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security())
        else:
            client = utils.configure_security_client(self.sdk_configuration.client, self.sdk_configuration.security)
        
        http_res = client.request('GET', url, params=query_params, headers=headers)
        content_type = http_res.headers.get('Content-Type')
        
        def next_func() -> Optional[operations.PaginationLimitOffsetPageParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page
            new_page = page + 1
            

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None

            return self.pagination_limit_offset_page_params(
                page=new_page,
                server_url=server_url,
            )
        
        res = operations.PaginationLimitOffsetPageParamsResponse(status_code=http_res.status_code, content_type=content_type, raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            if utils.match_content_type(content_type, 'application/json'):
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetPageParamsRes])
                res.res = out
            else:
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)

        return res

    