"""Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT."""

import requests as requests_http
from .sdkconfiguration import SDKConfiguration
from jsonpath import JSONPath
from sdk import utils
from sdk._hooks import AfterErrorContext, AfterSuccessContext, BeforeRequestContext, HookContext
from sdk.models import errors, operations, shared
from typing import Any, Dict, Optional

class Pagination:
    r"""Endpoints for testing the pagination extension"""
    sdk_configuration: SDKConfiguration

    def __init__(self, sdk_config: SDKConfiguration) -> None:
        self.sdk_configuration = sdk_config
        
    
    
    def pagination_cursor_body(self, request: operations.PaginationCursorBodyRequestBody, server_url: Optional[str] = None) -> operations.PaginationCursorBodyResponse:
        hook_ctx = HookContext(operation_id='paginationCursorBody', oauth2_scopes=[], security_source=self.sdk_configuration.security)
        base_url = utils.template_url(operations.PAGINATION_CURSOR_BODY_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/cursor'
        
        if callable(self.sdk_configuration.security):
            headers, query_params = utils.get_security(self.sdk_configuration.security())
        else:
            headers, query_params = utils.get_security(self.sdk_configuration.security)
        
        req_content_type, data, form = utils.serialize_request_body(request, operations.PaginationCursorBodyRequestBody, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = client.prepare_request(requests_http.Request('PUT', url, params=query_params, data=data, files=form, headers=headers))
            req = self.sdk_configuration.get_hooks().before_request(BeforeRequestContext(hook_ctx), req)
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), None, e)
            if e is not None:
                raise e

        if utils.match_status_codes(['4XX','5XX'], http_res.status_code):
            result, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), http_res, None)
            if e is not None:
                raise e
            if result is not None:
                http_res = result
        else:
            http_res = self.sdk_configuration.get_hooks().after_success(AfterSuccessContext(hook_ctx), http_res)
            
        
        
        def next_func() -> Optional[operations.PaginationCursorBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_body(
                request=operations.PaginationCursorBodyRequestBody(
                    cursor=next_cursor,
                ),
                server_url=server_url,
            )
        
        res = operations.PaginationCursorBodyResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type') or '', raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get('Content-Type') or '', 'application/json'):                
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationCursorBodyRes])
                res.res = out
            else:
                content_type = http_res.headers.get('Content-Type')
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_cursor_non_numeric(self, cursor: Optional[str] = None, server_url: Optional[str] = None) -> operations.PaginationCursorNonNumericResponse:
        hook_ctx = HookContext(operation_id='paginationCursorNonNumeric', oauth2_scopes=[], security_source=self.sdk_configuration.security)
        request = operations.PaginationCursorNonNumericRequest(
            cursor=cursor,
        )
        
        base_url = utils.template_url(operations.PAGINATION_CURSOR_NON_NUMERIC_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/cursor_non_numeric'
        
        if callable(self.sdk_configuration.security):
            headers, query_params = utils.get_security(self.sdk_configuration.security())
        else:
            headers, query_params = utils.get_security(self.sdk_configuration.security)
        
        query_params = { **utils.get_query_params(request), **query_params }
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = client.prepare_request(requests_http.Request('GET', url, params=query_params, headers=headers))
            req = self.sdk_configuration.get_hooks().before_request(BeforeRequestContext(hook_ctx), req)
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), None, e)
            if e is not None:
                raise e

        if utils.match_status_codes(['4XX','5XX'], http_res.status_code):
            result, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), http_res, None)
            if e is not None:
                raise e
            if result is not None:
                http_res = result
        else:
            http_res = self.sdk_configuration.get_hooks().after_success(AfterSuccessContext(hook_ctx), http_res)
            
        
        
        def next_func() -> Optional[operations.PaginationCursorNonNumericResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_non_numeric(
                cursor=next_cursor,
                server_url=server_url,
            )
        
        res = operations.PaginationCursorNonNumericResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type') or '', raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get('Content-Type') or '', 'application/json'):                
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationCursorNonNumericRes])
                res.res = out
            else:
                content_type = http_res.headers.get('Content-Type')
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_cursor_params(self, cursor: int, server_url: Optional[str] = None) -> operations.PaginationCursorParamsResponse:
        hook_ctx = HookContext(operation_id='paginationCursorParams', oauth2_scopes=[], security_source=self.sdk_configuration.security)
        request = operations.PaginationCursorParamsRequest(
            cursor=cursor,
        )
        
        base_url = utils.template_url(operations.PAGINATION_CURSOR_PARAMS_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/cursor'
        
        if callable(self.sdk_configuration.security):
            headers, query_params = utils.get_security(self.sdk_configuration.security())
        else:
            headers, query_params = utils.get_security(self.sdk_configuration.security)
        
        query_params = { **utils.get_query_params(request), **query_params }
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = client.prepare_request(requests_http.Request('GET', url, params=query_params, headers=headers))
            req = self.sdk_configuration.get_hooks().before_request(BeforeRequestContext(hook_ctx), req)
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), None, e)
            if e is not None:
                raise e

        if utils.match_status_codes(['4XX','5XX'], http_res.status_code):
            result, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), http_res, None)
            if e is not None:
                raise e
            if result is not None:
                http_res = result
        else:
            http_res = self.sdk_configuration.get_hooks().after_success(AfterSuccessContext(hook_ctx), http_res)
            
        
        
        def next_func() -> Optional[operations.PaginationCursorParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_cursor_params(
                cursor=next_cursor,
                server_url=server_url,
            )
        
        res = operations.PaginationCursorParamsResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type') or '', raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get('Content-Type') or '', 'application/json'):                
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationCursorParamsRes])
                res.res = out
            else:
                content_type = http_res.headers.get('Content-Type')
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_limit_offset_offset_body(self, request: shared.LimitOffsetConfig, server_url: Optional[str] = None) -> operations.PaginationLimitOffsetOffsetBodyResponse:
        hook_ctx = HookContext(operation_id='paginationLimitOffsetOffsetBody', oauth2_scopes=[], security_source=self.sdk_configuration.security)
        base_url = utils.template_url(operations.PAGINATION_LIMIT_OFFSET_OFFSET_BODY_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/limitoffset/offset'
        
        if callable(self.sdk_configuration.security):
            headers, query_params = utils.get_security(self.sdk_configuration.security())
        else:
            headers, query_params = utils.get_security(self.sdk_configuration.security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.LimitOffsetConfig, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = client.prepare_request(requests_http.Request('PUT', url, params=query_params, data=data, files=form, headers=headers))
            req = self.sdk_configuration.get_hooks().before_request(BeforeRequestContext(hook_ctx), req)
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), None, e)
            if e is not None:
                raise e

        if utils.match_status_codes(['4XX','5XX'], http_res.status_code):
            result, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), http_res, None)
            if e is not None:
                raise e
            if result is not None:
                http_res = result
        else:
            http_res = self.sdk_configuration.get_hooks().after_success(AfterSuccessContext(hook_ctx), http_res)
            
        
        
        def next_func() -> Optional[operations.PaginationLimitOffsetOffsetBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit =request.limit
            if len(results[0]) < limit:
                return None
            new_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=new_offset,
                    page=request.page,
                ),
                server_url=server_url,
            )
        
        res = operations.PaginationLimitOffsetOffsetBodyResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type') or '', raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get('Content-Type') or '', 'application/json'):                
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetOffsetBodyRes])
                res.res = out
            else:
                content_type = http_res.headers.get('Content-Type')
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_limit_offset_offset_params(self, limit: Optional[int] = None, offset: Optional[int] = None, server_url: Optional[str] = None) -> operations.PaginationLimitOffsetOffsetParamsResponse:
        hook_ctx = HookContext(operation_id='paginationLimitOffsetOffsetParams', oauth2_scopes=[], security_source=self.sdk_configuration.security)
        request = operations.PaginationLimitOffsetOffsetParamsRequest(
            limit=limit,
            offset=offset,
        )
        
        base_url = utils.template_url(operations.PAGINATION_LIMIT_OFFSET_OFFSET_PARAMS_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/limitoffset/offset'
        
        if callable(self.sdk_configuration.security):
            headers, query_params = utils.get_security(self.sdk_configuration.security())
        else:
            headers, query_params = utils.get_security(self.sdk_configuration.security)
        
        query_params = { **utils.get_query_params(request), **query_params }
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = client.prepare_request(requests_http.Request('GET', url, params=query_params, headers=headers))
            req = self.sdk_configuration.get_hooks().before_request(BeforeRequestContext(hook_ctx), req)
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), None, e)
            if e is not None:
                raise e

        if utils.match_status_codes(['4XX','5XX'], http_res.status_code):
            result, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), http_res, None)
            if e is not None:
                raise e
            if result is not None:
                http_res = result
        else:
            http_res = self.sdk_configuration.get_hooks().after_success(AfterSuccessContext(hook_ctx), http_res)
            
        
        
        def next_func() -> Optional[operations.PaginationLimitOffsetOffsetParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            offset = request.offset

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None
            limit =request.limit
            if len(results[0]) < limit:
                return None
            new_offset = offset + len(results[0])

            return self.pagination_limit_offset_offset_params(
                limit=limit,
                offset=new_offset,
                server_url=server_url,
            )
        
        res = operations.PaginationLimitOffsetOffsetParamsResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type') or '', raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get('Content-Type') or '', 'application/json'):                
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetOffsetParamsRes])
                res.res = out
            else:
                content_type = http_res.headers.get('Content-Type')
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_limit_offset_page_body(self, request: shared.LimitOffsetConfig, server_url: Optional[str] = None) -> operations.PaginationLimitOffsetPageBodyResponse:
        hook_ctx = HookContext(operation_id='paginationLimitOffsetPageBody', oauth2_scopes=[], security_source=self.sdk_configuration.security)
        base_url = utils.template_url(operations.PAGINATION_LIMIT_OFFSET_PAGE_BODY_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/limitoffset/page'
        
        if callable(self.sdk_configuration.security):
            headers, query_params = utils.get_security(self.sdk_configuration.security())
        else:
            headers, query_params = utils.get_security(self.sdk_configuration.security)
        
        req_content_type, data, form = utils.serialize_request_body(request, shared.LimitOffsetConfig, "request", False, False, 'json')
        if req_content_type is not None and req_content_type not in ('multipart/form-data', 'multipart/mixed'):
            headers['content-type'] = req_content_type
        if data is None and form is None:
            raise Exception('request body is required')
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = client.prepare_request(requests_http.Request('PUT', url, params=query_params, data=data, files=form, headers=headers))
            req = self.sdk_configuration.get_hooks().before_request(BeforeRequestContext(hook_ctx), req)
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), None, e)
            if e is not None:
                raise e

        if utils.match_status_codes(['4XX','5XX'], http_res.status_code):
            result, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), http_res, None)
            if e is not None:
                raise e
            if result is not None:
                http_res = result
        else:
            http_res = self.sdk_configuration.get_hooks().after_success(AfterSuccessContext(hook_ctx), http_res)
            
        
        
        def next_func() -> Optional[operations.PaginationLimitOffsetPageBodyResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page
            new_page = page + 1
            
            num_pages = JSONPath("$.numPages").parse(body)
            if len(num_pages) == 0 or num_pages[0] <= page:
                return None

            if not http_res.text:
                return None

            return self.pagination_limit_offset_page_body(
                request=shared.LimitOffsetConfig(
                    limit=request.limit,
                    offset=request.offset,
                    page=new_page,
                ),
                server_url=server_url,
            )
        
        res = operations.PaginationLimitOffsetPageBodyResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type') or '', raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get('Content-Type') or '', 'application/json'):                
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetPageBodyRes])
                res.res = out
            else:
                content_type = http_res.headers.get('Content-Type')
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_limit_offset_page_params(self, page: int, server_url: Optional[str] = None) -> operations.PaginationLimitOffsetPageParamsResponse:
        hook_ctx = HookContext(operation_id='paginationLimitOffsetPageParams', oauth2_scopes=[], security_source=self.sdk_configuration.security)
        request = operations.PaginationLimitOffsetPageParamsRequest(
            page=page,
        )
        
        base_url = utils.template_url(operations.PAGINATION_LIMIT_OFFSET_PAGE_PARAMS_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/limitoffset/page'
        
        if callable(self.sdk_configuration.security):
            headers, query_params = utils.get_security(self.sdk_configuration.security())
        else:
            headers, query_params = utils.get_security(self.sdk_configuration.security)
        
        query_params = { **utils.get_query_params(request), **query_params }
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = client.prepare_request(requests_http.Request('GET', url, params=query_params, headers=headers))
            req = self.sdk_configuration.get_hooks().before_request(BeforeRequestContext(hook_ctx), req)
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), None, e)
            if e is not None:
                raise e

        if utils.match_status_codes(['4XX','5XX'], http_res.status_code):
            result, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), http_res, None)
            if e is not None:
                raise e
            if result is not None:
                http_res = result
        else:
            http_res = self.sdk_configuration.get_hooks().after_success(AfterSuccessContext(hook_ctx), http_res)
            
        
        
        def next_func() -> Optional[operations.PaginationLimitOffsetPageParamsResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            page = request.page
            new_page = page + 1
            

            if not http_res.text:
                return None
            results = JSONPath("$.resultArray").parse(body)
            if len(results) == 0 or len(results[0]) == 0:
                return None

            return self.pagination_limit_offset_page_params(
                page=new_page,
                server_url=server_url,
            )
        
        res = operations.PaginationLimitOffsetPageParamsResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type') or '', raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get('Content-Type') or '', 'application/json'):                
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationLimitOffsetPageParamsRes])
                res.res = out
            else:
                content_type = http_res.headers.get('Content-Type')
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_url_params(self, attempts: int, is_reference_path: Optional[str] = None, server_url: Optional[str] = None) -> operations.PaginationURLParamsResponse:
        hook_ctx = HookContext(operation_id='paginationURLParams', oauth2_scopes=[], security_source=self.sdk_configuration.security)
        request = operations.PaginationURLParamsRequest(
            attempts=attempts,
            is_reference_path=is_reference_path,
        )
        
        base_url = utils.template_url(operations.PAGINATION_URL_PARAMS_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/url'
        
        if callable(self.sdk_configuration.security):
            headers, query_params = utils.get_security(self.sdk_configuration.security())
        else:
            headers, query_params = utils.get_security(self.sdk_configuration.security)
        
        query_params = { **utils.get_query_params(request), **query_params }
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        try:
            req = client.prepare_request(requests_http.Request('GET', url, params=query_params, headers=headers))
            req = self.sdk_configuration.get_hooks().before_request(BeforeRequestContext(hook_ctx), req)
            http_res = client.send(req)
        except Exception as e:
            _, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), None, e)
            if e is not None:
                raise e

        if utils.match_status_codes(['4XX','5XX'], http_res.status_code):
            result, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), http_res, None)
            if e is not None:
                raise e
            if result is not None:
                http_res = result
        else:
            http_res = self.sdk_configuration.get_hooks().after_success(AfterSuccessContext(hook_ctx), http_res)
            
        
        
        res = operations.PaginationURLParamsResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type') or '', raw_response=http_res)
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get('Content-Type') or '', 'application/json'):                
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationURLParamsRes])
                res.res = out
            else:
                content_type = http_res.headers.get('Content-Type')
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    
    
    def pagination_with_retries(self, cursor: Optional[str] = None, fault_settings: Optional[str] = None, request_id: Optional[str] = None, retries: Optional[utils.RetryConfig] = None, server_url: Optional[str] = None) -> operations.PaginationWithRetriesResponse:
        hook_ctx = HookContext(operation_id='paginationWithRetries', oauth2_scopes=[], security_source=self.sdk_configuration.security)
        request = operations.PaginationWithRetriesRequest(
            cursor=cursor,
            fault_settings=fault_settings,
            request_id=request_id,
        )
        
        base_url = utils.template_url(operations.PAGINATION_WITH_RETRIES_SERVERS[0], {
        })
        if server_url is not None:
            base_url = server_url
        
        url = base_url + '/pagination/cursor_non_numeric#withRetries'
        
        if callable(self.sdk_configuration.security):
            headers, query_params = utils.get_security(self.sdk_configuration.security())
        else:
            headers, query_params = utils.get_security(self.sdk_configuration.security)
        
        headers = { **utils.get_headers(request), **headers }
        query_params = { **utils.get_query_params(request), **query_params }
        headers['Accept'] = 'application/json'
        headers['x-speakeasy-user-agent'] = self.sdk_configuration.user_agent
        client = self.sdk_configuration.client
        
        global_retry_config = self.sdk_configuration.retry_config
        retry_config = retries
        if retry_config is None:
            if global_retry_config:
                retry_config = global_retry_config
            else:
                retry_config = utils.RetryConfig('backoff', utils.BackoffStrategy(10, 100, 1.5, 1000), False)

        req = None
        def do_request():
            nonlocal req
            try:
                req = client.prepare_request(requests_http.Request('GET', url, params=query_params, headers=headers))
                req = self.sdk_configuration.get_hooks().before_request(BeforeRequestContext(hook_ctx), req)
                http_res = client.send(req)
            except Exception as e:
                _, err = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), None, e)
                if err is not None:
                    raise err from e
                raise e

            if utils.match_status_codes(['4XX','5XX'], http_res.status_code):
                result, e = self.sdk_configuration.get_hooks().after_error(AfterErrorContext(hook_ctx), http_res, None)
                if e is not None:
                    raise e
                if result is not None:
                    http_res = result
                else:
                    raise errors.SDKError('Unexpected error occurred', -1, '', None)
            else:
                http_res = self.sdk_configuration.get_hooks().after_success(AfterSuccessContext(hook_ctx), http_res)

            return http_res

        http_res = utils.retry(do_request, utils.Retries(retry_config, [
            '503'
        ]))
        
        
        def next_func() -> Optional[operations.PaginationWithRetriesResponse]:
            body = utils.unmarshal_json(http_res.text, Dict[Any, Any])
            next_cursor = JSONPath("$.resultArray[-1:]").parse(body)

            if len(next_cursor) == 0:
                return None
            next_cursor = next_cursor[0]

            return self.pagination_with_retries(
                cursor=next_cursor,
                fault_settings=fault_settings,
                request_id=request_id,
                retries=retries,
                server_url=server_url,
            )
        
        res = operations.PaginationWithRetriesResponse(status_code=http_res.status_code, content_type=http_res.headers.get('Content-Type') or '', raw_response=http_res, next=next_func)
        
        if http_res.status_code == 200:
            # pylint: disable=no-else-return
            if utils.match_content_type(http_res.headers.get('Content-Type') or '', 'application/json'):                
                out = utils.unmarshal_json(http_res.text, Optional[operations.PaginationWithRetriesRes])
                res.res = out
            else:
                content_type = http_res.headers.get('Content-Type')
                raise errors.SDKError(f'unknown content-type received: {content_type}', http_res.status_code, http_res.text, http_res)
        elif http_res.status_code >= 400 and http_res.status_code < 500 or http_res.status_code >= 500 and http_res.status_code < 600:
            raise errors.SDKError('API error occurred', http_res.status_code, http_res.text, http_res)
        else:
            raise errors.SDKError('unknown status code received', http_res.status_code, http_res.text, http_res)

        return res

    

