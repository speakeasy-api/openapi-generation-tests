# Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

# typed: true
# frozen_string_literal: true

require 'faraday'
require 'faraday/multipart'
require 'sorbet-runtime'

module OpenApiSDK
  extend T::Sig
  class RequestBodies
    extend T::Sig
    sig { params(sdk: OpenApiSDK::SDK, client: Faraday::Connection, server_url: String, language: String, sdk_version: String, gen_version: String, gbls: T::Hash[Symbol, T::Hash[Symbol, T::Hash[Symbol, Object]]]).void }
    def initialize(sdk, client, server_url, language, sdk_version, gen_version, gbls)
      @sdk = sdk
      @client = client
      @server_url = server_url
      @language = language
      @sdk_version = sdk_version
      @gen_version = gen_version
      @globals = gbls
    end

    sig { params(request: T::Array[Shared::SimpleObject], server_url: T.nilable(String)).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_array(request, server_url = nil)

      base_url = Operations::REQUEST_BODY_POST_APPLICATION_JSON_ARRAY_SERVERS[0]
      base_url = server_url if !server_url.nil?
      url = "#{base_url.delete_suffix('/')}/requestbody#array"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonArrayResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Array[Shared::SimpleObject])
          res.simple_objects = out
        end
      end
      res
    end

    sig { params(request: T::Array[Shared::SimpleObject]).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_array_obj(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/application/json/array/objResponse"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonArrayObjResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Shared::ArrObjValue)
          res.arr_obj_value = out
        end
      end
      res
    end

    sig { params(request: T::Array[T::Array[Shared::SimpleObject]], server_url: T.nilable(String)).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_array_of_array(request, server_url = nil)

      base_url = Operations::REQUEST_BODY_POST_APPLICATION_JSON_ARRAY_OF_ARRAY_SERVERS[0]
      base_url = server_url if !server_url.nil?
      url = "#{base_url.delete_suffix('/')}/requestbody#arrayOfArrays"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonArrayOfArrayResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Array[T::Array[Shared::SimpleObject]])
          res.arrs = out
        end
      end
      res
    end

    sig { params(request: T::Array[T::Array[String]], server_url: T.nilable(String)).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_array_of_array_of_primitive(request, server_url = nil)

      base_url = Operations::REQUEST_BODY_POST_APPLICATION_JSON_ARRAY_OF_ARRAY_OF_PRIMITIVE_SERVERS[0]
      base_url = server_url if !server_url.nil?
      url = "#{base_url.delete_suffix('/')}/requestbody#arrayOfArraysOfPrimitives"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Array[T::Array[String]])
          res.arrs = out
        end
      end
      res
    end

    sig { params(request: T::Array[T::Hash[Symbol, Shared::SimpleObject]], server_url: T.nilable(String)).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_array_of_map(request, server_url = nil)

      base_url = Operations::REQUEST_BODY_POST_APPLICATION_JSON_ARRAY_OF_MAP_SERVERS[0]
      base_url = server_url if !server_url.nil?
      url = "#{base_url.delete_suffix('/')}/requestbody#arrayOfMaps"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonArrayOfMapResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Array[T::Hash[Symbol, Shared::SimpleObject]])
          res.maps = out
        end
      end
      res
    end

    sig { params(request: T::Array[String], server_url: T.nilable(String)).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_array_of_primitive(request, server_url = nil)

      base_url = Operations::REQUEST_BODY_POST_APPLICATION_JSON_ARRAY_OF_PRIMITIVE_SERVERS[0]
      base_url = server_url if !server_url.nil?
      url = "#{base_url.delete_suffix('/')}/requestbody#arrayOfPrimitives"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonArrayOfPrimitiveResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Array[String])
          res.strings = out
        end
      end
      res
    end

    sig { params(request: Shared::DeepObject).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_deep(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/application/json/deep"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonDeepResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostApplicationJsonDeepRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: T::Hash[Symbol, Shared::SimpleObject], server_url: T.nilable(String)).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_map(request, server_url = nil)

      base_url = Operations::REQUEST_BODY_POST_APPLICATION_JSON_MAP_SERVERS[0]
      base_url = server_url if !server_url.nil?
      url = "#{base_url.delete_suffix('/')}/requestbody#map"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonMapResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Hash[Symbol, Shared::SimpleObject])
          res.res = out
        end
      end
      res
    end

    sig { params(request: T::Hash[Symbol, Shared::SimpleObject]).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_map_obj(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/application/json/map/objResponse"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonMapObjResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Shared::MapObjValue)
          res.map_obj_value = out
        end
      end
      res
    end

    sig { params(request: T::Hash[Symbol, T::Array[Shared::SimpleObject]], server_url: T.nilable(String)).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_map_of_array(request, server_url = nil)

      base_url = Operations::REQUEST_BODY_POST_APPLICATION_JSON_MAP_OF_ARRAY_SERVERS[0]
      base_url = server_url if !server_url.nil?
      url = "#{base_url.delete_suffix('/')}/requestbody#mapOfArrays"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonMapOfArrayResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Hash[Symbol, T::Array[Shared::SimpleObject]])
          res.res = out
        end
      end
      res
    end

    sig { params(request: T::Hash[Symbol, T::Hash[Symbol, Shared::SimpleObject]], server_url: T.nilable(String)).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_map_of_map(request, server_url = nil)

      base_url = Operations::REQUEST_BODY_POST_APPLICATION_JSON_MAP_OF_MAP_SERVERS[0]
      base_url = server_url if !server_url.nil?
      url = "#{base_url.delete_suffix('/')}/requestbody#mapOfMaps"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonMapOfMapResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Hash[Symbol, T::Hash[Symbol, Shared::SimpleObject]])
          res.res = out
        end
      end
      res
    end

    sig { params(request: T::Hash[Symbol, T::Hash[Symbol, String]], server_url: T.nilable(String)).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_map_of_map_of_primitive(request, server_url = nil)

      base_url = Operations::REQUEST_BODY_POST_APPLICATION_JSON_MAP_OF_MAP_OF_PRIMITIVE_SERVERS[0]
      base_url = server_url if !server_url.nil?
      url = "#{base_url.delete_suffix('/')}/requestbody#mapOfMapsOfPrimitives"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonMapOfMapOfPrimitiveResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Hash[Symbol, T::Hash[Symbol, String]])
          res.res = out
        end
      end
      res
    end

    sig { params(request: T::Hash[Symbol, String], server_url: T.nilable(String)).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_map_of_primitive(request, server_url = nil)

      base_url = Operations::REQUEST_BODY_POST_APPLICATION_JSON_MAP_OF_PRIMITIVE_SERVERS[0]
      base_url = server_url if !server_url.nil?
      url = "#{base_url.delete_suffix('/')}/requestbody#mapOfPrimitives"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonMapOfPrimitiveResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, T::Hash[Symbol, String])
          res.res = out
        end
      end
      res
    end

    sig { params(request: Shared::SimpleObject).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_multiple_json_filtered(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/application/json/multiple/json/filtered"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonMultipleJsonFilteredResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostApplicationJsonMultipleJsonFilteredRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: Shared::SimpleObject).returns(Utils::FieldAugmented) }
    def request_body_post_application_json_simple(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/application/json/simple"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostApplicationJsonSimpleResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostApplicationJsonSimpleRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: Shared::DeepObject).returns(Utils::FieldAugmented) }
    def request_body_post_form_deep(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/form/deep"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :form)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostFormDeepResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostFormDeepRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: T::Hash[Symbol, String]).returns(Utils::FieldAugmented) }
    def request_body_post_form_map_primitive(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/form/map/primitive"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :form)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostFormMapPrimitiveResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostFormMapPrimitiveRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: Shared::SimpleObject).returns(Utils::FieldAugmented) }
    def request_body_post_form_simple(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/form/simple"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :form)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostFormSimpleResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostFormSimpleRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: Shared::SimpleObject).returns(Utils::FieldAugmented) }
    def request_body_post_multiple_content_types_component_filtered(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/multiple/contentTypes/component/filtered"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostMultipleContentTypesComponentFilteredResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostMultipleContentTypesComponentFilteredRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: Operations::RequestBodyPostMultipleContentTypesInlineFilteredApplicationJSON).returns(Utils::FieldAugmented) }
    def request_body_post_multiple_content_types_inline_filtered(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/multiple/contentTypes/inline/filtered"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostMultipleContentTypesInlineFilteredResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostMultipleContentTypesInlineFilteredRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request_body: Operations::RequestBodyPostMultipleContentTypesSplitParamApplicationXWwwFormUrlencoded, param_str: String).returns(Utils::FieldAugmented) }
    def request_body_post_multiple_content_types_split_param_form(request_body, param_str)

      request = Operations::RequestBodyPostMultipleContentTypesSplitParamFormRequest.new(
        request_body: request_body,
        param_str: param_str,
      )
      
      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/multiple/contentTypes/split/param"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request_body, :form)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      query_params = Utils.get_query_params(Operations::RequestBodyPostMultipleContentTypesSplitParamFormRequest, request, @globals)
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        req.params = query_params
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostMultipleContentTypesSplitParamFormResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostMultipleContentTypesSplitParamFormRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request_body: Operations::RequestBodyPostMultipleContentTypesSplitParamApplicationJSON, param_str: String).returns(Utils::FieldAugmented) }
    def request_body_post_multiple_content_types_split_param_json(request_body, param_str)

      request = Operations::RequestBodyPostMultipleContentTypesSplitParamJsonRequest.new(
        request_body: request_body,
        param_str: param_str,
      )
      
      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/multiple/contentTypes/split/param"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request_body, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      query_params = Utils.get_query_params(Operations::RequestBodyPostMultipleContentTypesSplitParamJsonRequest, request, @globals)
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        req.params = query_params
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostMultipleContentTypesSplitParamJsonResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostMultipleContentTypesSplitParamJsonRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request_body: Operations::RequestBodyPostMultipleContentTypesSplitParamMultipartFormData, param_str: String).returns(Utils::FieldAugmented) }
    def request_body_post_multiple_content_types_split_param_multipart(request_body, param_str)

      request = Operations::RequestBodyPostMultipleContentTypesSplitParamMultipartRequest.new(
        request_body: request_body,
        param_str: param_str,
      )
      
      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/multiple/contentTypes/split/param"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request_body, :multipart)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      query_params = Utils.get_query_params(Operations::RequestBodyPostMultipleContentTypesSplitParamMultipartRequest, request, @globals)
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        req.params = query_params
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostMultipleContentTypesSplitParamMultipartResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostMultipleContentTypesSplitParamMultipartRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: Operations::RequestBodyPostMultipleContentTypesSplitApplicationXWwwFormUrlencoded).returns(Utils::FieldAugmented) }
    def request_body_post_multiple_content_types_split_form(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/multiple/contentTypes/split"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :form)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostMultipleContentTypesSplitFormResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostMultipleContentTypesSplitFormRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: Operations::RequestBodyPostMultipleContentTypesSplitApplicationJSON).returns(Utils::FieldAugmented) }
    def request_body_post_multiple_content_types_split_json(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/multiple/contentTypes/split"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :json)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostMultipleContentTypesSplitJsonResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostMultipleContentTypesSplitJsonRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: Operations::RequestBodyPostMultipleContentTypesSplitMultipartFormData).returns(Utils::FieldAugmented) }
    def request_body_post_multiple_content_types_split_multipart(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/post/multiple/contentTypes/split"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :multipart)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.post(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPostMultipleContentTypesSplitMultipartResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPostMultipleContentTypesSplitMultipartRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: String).returns(Utils::FieldAugmented) }
    def request_body_put_bytes(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/put/bytes"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :raw)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.put(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPutBytesResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPutBytesRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: Shared::DeepObject).returns(Utils::FieldAugmented) }
    def request_body_put_multipart_deep(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/put/multipart/deep"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :multipart)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.put(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPutMultipartDeepResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPutMultipartDeepRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: Operations::RequestBodyPutMultipartFileRequestBody).returns(Utils::FieldAugmented) }
    def request_body_put_multipart_file(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/put/multipart/file"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :multipart)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.put(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPutMultipartFileResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPutMultipartFileRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: Shared::SimpleObject).returns(Utils::FieldAugmented) }
    def request_body_put_multipart_simple(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/put/multipart/simple"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :multipart)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.put(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPutMultipartSimpleResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPutMultipartSimpleRes)
          res.res = out
        end
      end
      res
    end

    sig { params(request: String).returns(Utils::FieldAugmented) }
    def request_body_put_string(request)

      base_url = @server_url
      url = "#{base_url.delete_suffix('/')}/anything/requestBodies/put/string"
      headers = {}
      req_content_type, data, form = Utils.serialize_request_body(request, :request, :string)
      headers['content-type'] = req_content_type
      raise StandardError, 'request body is required' if data.nil? && form.nil?
      headers['x-speakeasy-user-agent'] = "speakeasy-sdk/#{@language} #{@sdk_version} #{@gen_version}"

      r = @client.put(url) do |req|
        req.headers = headers
        Utils.configure_request_security(req, @sdk.security) if !@sdk.nil? && !@sdk.security.nil?
        if form
          req.body = Utils.encode_form(form)
        elsif Utils.match_content_type(req_content_type, 'application/x-www-form-urlencoded')
          req.body = URI.encode_www_form(data)
        else
          req.body = data
        end
      end

      content_type = r.headers.fetch('Content-Type', 'application/octet-stream')

      res = Operations::RequestBodyPutStringResponse.new(
        status_code: r.status, content_type: content_type, raw_response: r
      )
      if r.status == 200
        if Utils.match_content_type(content_type, 'application/json')
          out = Utils.unmarshal_complex(r.env.response_body, Operations::RequestBodyPutStringRes)
          res.res = out
        end
      end
      res
    end
  end
end
