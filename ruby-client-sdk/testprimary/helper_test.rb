# Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

# frozen_string_literal: true

require_relative '../lib/openapi'
require 'date'
require 'cgi'

def create_simple_object
  OpenApiSDK::Shared::SimpleObject.new(
    str_: 'test',
    bool: true,
    int: 1,
    int32: 1,
    int32_enum: OpenApiSDK::Shared::Int32Enum::FIFTY_FIVE,
    int_enum: OpenApiSDK::Shared::IntEnum::SECOND,
    num: 1.1,
    float32: 1.1,
    enum: OpenApiSDK::Shared::Enum::ONE,
    any: 'any',
    date: Date.new(2020, 1, 1),
    date_time: DateTime.new(2020, 1, 1, 0, 0, 1 / 1_000_000_000.0),
    bool_opt: true,
    str_opt: 'testOptional',
    int_opt_null: nil,
    num_opt_null: nil
  )
end

def create_deep_object
  OpenApiSDK::Shared::DeepObject.new(
    any: create_simple_object,
    arr: [create_simple_object, create_simple_object],
    bool: true,
    int: 1,
    map: { 'key' => create_simple_object },
    num: 1.1,
    obj: create_simple_object,
    str_: 'test'
  )
end

# sig { params(to_replace: String, match: String).returns(String) }
def unsure(to_replace, match)
  if match.include? '='
    pairs = match.split ','

  else
    values = match.split ','
    pairs = []
    0.step(values.length - 1, 2) do |i|
      pairs[i / 2] = "#{values[i]},#{values[i + 1]}"
    end

  end

  pairs.sort_by { |pair| pair.split('=')[0] }

  updated_pairs = pairs.join ','

  to_replace.sub(match, updated_pairs)
end

# sig { params(input: String, regex: String).returns(String) }
def sort_serialized_map(input, regex)
  input = CGI.unescape(input)

  r = Regexp.new(regex)

  replace_all_string_submatch_fx(r, input)
end

# sig { params(re: Regexp, str: String).returns(String) }
def replace_all_string_submatch_fx(re, str)
  result = ''
  last_index = 0
  matches = re.match(str)


  last_index = 0
  (1..matches.length - 1).each do |i|
    result += unsure(str[last_index..matches.end(i) - 1], matches[i])
    last_index = matches.end(i)
  end

  result + str[last_index..str.length]
end

def compare_simple_object(obj1, obj2)
  assert_equal obj1.bool, obj2.bool
  assert_equal obj1.bool_opt, obj2.bool_opt
  assert_equal obj1.date, obj2.date
  assert_equal obj1.date_time, obj2.date_time
  assert_equal obj1.enum, obj2.enum
  assert_equal obj1.float32, obj2.float32
  assert_equal obj1.int, obj2.int
  assert_equal obj1.int32, obj2.int32
  assert_nil obj1.int_opt_null
  assert_nil obj2.int_opt_null
  assert_equal obj1.num, obj2.num
  assert_nil obj1.num_opt_null
  assert_nil obj2.num_opt_null
  assert_equal obj1.str_, obj2.str_
  assert_equal obj1.str_opt, obj2.str_opt
end

def compare_deep_object(obj1, obj2)
  assert_equal obj1.arr.length, obj2.arr.length
  (0..obj1.arr.length - 1).each do |i|
    compare_simple_object(obj1.arr[i], obj2.arr[i])
  end
  assert_equal obj1.bool, obj2.bool
  assert_equal obj1.int, obj2.int
  assert_equal obj1.map.size, obj2.map.size
  obj1.map.each_key do |key|
    compare_simple_object(obj1.map[key], obj2.map[key])
  end
  assert_equal obj1.num, obj2.num
  compare_simple_object(obj1.obj, obj2.obj)
  assert_equal obj1.str_, obj2.str_
end

def compare_hashes(hash1, hash2)
  hash1 = hash1.transform_keys(&:to_sym)
  hash2 = hash2.transform_keys(&:to_sym)
  hash1.each_key do |key|
    assert_equal hash1[key], hash2[key]
  end
end
