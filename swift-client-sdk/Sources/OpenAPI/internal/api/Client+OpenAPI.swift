// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

import Foundation

extension Client: OpenAPI {
    // MARK: - Root operations 
    
    /// Tests conflict with C# System namespace
    /// 
    /// - Parameter request: A ``Operations/AmbiguousQueryParamRequest`` object describing the input to the API operation
    /// - Returns: A ``Operations/AmbiguousQueryParamResponse`` object describing the result of the API operation
    /// - Throws: An error of type ``OpenAPIError``
    public func ambiguousQueryParam(request: Operations.AmbiguousQueryParamRequest) async throws -> Response<Operations.AmbiguousQueryParamResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureAmbiguousQueryParamRequest(with: configuration, request: request)
            },
            handleResponse: handleAmbiguousQueryParamResponse
        )
    }
    
    public func authenticatedRequest(request: Operations.AuthenticatedRequestRequestBody, security: Operations.AuthenticatedRequestSecurity) async throws -> Response<Operations.AuthenticatedRequestResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureAuthenticatedRequestRequest(with: configuration, request: request, security: security)
            },
            handleResponse: handleAuthenticatedRequestResponse
        )
    }
    
    /// Test potential namespace conflicts with java.lang.Object
    /// 
    /// - Parameter request: A ``Shared/ConflictingEnum`` object describing the input to the API operation
    /// - Returns: A ``Operations/ConflictingEnumResponse`` object describing the result of the API operation
    /// - Throws: An error of type ``OpenAPIError``
    public func conflictingEnum(request: Shared.ConflictingEnum) async throws -> Response<Operations.ConflictingEnumResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureConflictingEnumRequest(with: configuration, request: request)
            },
            handleResponse: handleConflictingEnumResponse
        )
    }
    
    public func ignoredGenerationPut(request: String) async throws -> Response<Operations.IgnoredGenerationPutResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureIgnoredGenerationPutRequest(with: configuration, request: request)
            },
            handleResponse: handleIgnoredGenerationPutResponse
        )
    }
    
    public func multilineExample(request: Operations.MultilineExampleRequestBody) async throws -> Response<Operations.MultilineExampleResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureMultilineExampleRequest(with: configuration, request: request)
            },
            handleResponse: handleMultilineExampleResponse
        )
    }
    
    public func responseBodyJsonGet() async throws -> Response<Operations.ResponseBodyJsonGetResponse> {
        return try await makeRequest(
            configureRequest: { configuration in
                try configureResponseBodyJsonGetRequest(with: configuration)
            },
            handleResponse: handleResponseBodyJsonGetResponse
        )
    }

    // MARK: - Scoped API operations

    public var generation: GenerationAPI {
        return _GenerationAPI(client: self)
    }

    public var unions: UnionsAPI {
        return _UnionsAPI(client: self)
    }

    public var errors: ErrorsAPI {
        return _ErrorsAPI(client: self)
    }

    public var customClient: CustomClientAPI {
        return _CustomClientAPI(client: self)
    }

    public var responseBodies: ResponseBodiesAPI {
        return _ResponseBodiesAPI(client: self)
    }

    public var flattening: FlatteningAPI {
        return _FlatteningAPI(client: self)
    }

    public var globals: GlobalsAPI {
        return _GlobalsAPI(client: self)
    }

    public var parameters: ParametersAPI {
        return _ParametersAPI(client: self)
    }

    public var hooks: HooksAPI {
        return _HooksAPI(client: self)
    }

    public var nestFirst: NestFirstAPI {
        return _NestFirstAPI(client: self)
    }

    public var nested: NestedAPI {
        return _NestedAPI(client: self)
    }

    public var nestedFirst: NestedFirstAPI {
        return _NestedFirstAPI(client: self)
    }

    public var nestedSecond: NestedSecondAPI {
        return _NestedSecondAPI(client: self)
    }

    public var auth: AuthAPI {
        return _AuthAPI(client: self)
    }

    public var openEnums: OpenEnumsAPI {
        return _OpenEnumsAPI(client: self)
    }

    public var requestBodies: RequestBodiesAPI {
        return _RequestBodiesAPI(client: self)
    }

    public var servers: ServersAPI {
        return _ServersAPI(client: self)
    }

    public var telemetry: TelemetryAPI {
        return _TelemetryAPI(client: self)
    }

    public var authNew: AuthNewAPI {
        return _AuthNewAPI(client: self)
    }

    public var resource: ResourceAPI {
        return _ResourceAPI(client: self)
    }

    public var documentation: DocumentationAPI {
        return _DocumentationAPI(client: self)
    }

    public var first: FirstAPI {
        return _FirstAPI(client: self)
    }

    public var second: SecondAPI {
        return _SecondAPI(client: self)
    }

    public var methods: MethodsAPI {
        return _MethodsAPI(client: self)
    }

    public var pagination: PaginationAPI {
        return _PaginationAPI(client: self)
    }

    public var retries: RetriesAPI {
        return _RetriesAPI(client: self)
    }
}

// MARK: - Request Configuration

private func configureAmbiguousQueryParamRequest(with configuration: URLRequestConfiguration, request: Operations.AmbiguousQueryParamRequest) throws {
    configuration.path = "/anything/queryParams/namespaceConflict"
    configuration.method = .get
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configureAuthenticatedRequestRequest(with configuration: URLRequestConfiguration, request: Operations.AuthenticatedRequestRequestBody, security: Operations.AuthenticatedRequestSecurity) throws {
    configuration.path = "/clientcredentials/authenticatedrequest"
    configuration.method = .post
    configuration.securityParameterProviding = security
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request)
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configureConflictingEnumRequest(with configuration: URLRequestConfiguration, request: Shared.ConflictingEnum) throws {
    configuration.path = "/anything/conflictingEnum/"
    configuration.method = .post
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request)
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configureIgnoredGenerationPutRequest(with configuration: URLRequestConfiguration, request: String) throws {
    configuration.path = "/anything/ignoredGeneration"
    configuration.method = .put
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request)
    if configuration.body == nil {
        throw SerializationError.missingRequiredRequestBody
    }
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configureMultilineExampleRequest(with configuration: URLRequestConfiguration, request: Operations.MultilineExampleRequestBody) throws {
    configuration.path = "/anything/multilineExample"
    configuration.method = .get
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request)
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configureResponseBodyJsonGetRequest(with configuration: URLRequestConfiguration) throws {
    configuration.path = "/json"
    configuration.method = .get
    configuration.telemetryHeader = .speakeasyUserAgent
}

// MARK: - Response Handlers

private func handleAmbiguousQueryParamResponse(response: Client.APIResponse) throws -> Operations.AmbiguousQueryParamResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        return .empty
    }

    return .empty
}

private func handleAuthenticatedRequestResponse(response: Client.APIResponse) throws -> Operations.AuthenticatedRequestResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        return .empty
    }

    return .empty
}

private func handleConflictingEnumResponse(response: Client.APIResponse) throws -> Operations.ConflictingEnumResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        return .empty
    }

    return .empty
}

private func handleIgnoredGenerationPutResponse(response: Client.APIResponse) throws -> Operations.IgnoredGenerationPutResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .object(try JSONDecoder().decode(Operations.IgnoredGenerationPutResponseBody.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handleMultilineExampleResponse(response: Client.APIResponse) throws -> Operations.MultilineExampleResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 201 { 
        return .empty
    }

    return .empty
}

private func handleResponseBodyJsonGetResponse(response: Client.APIResponse) throws -> Operations.ResponseBodyJsonGetResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .httpBinSimpleJsonObject(try JSONDecoder().decode(Shared.HttpBinSimpleJsonObject.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

