// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.


import Foundation

class _PaginationAPI: PaginationAPI {
    private let client: Client

    init(client: Client) {
        self.client = client
    }
    
    public func paginationAmbiguousInput(request: Operations.PaginationAmbiguousInputRequest, server: PaginationServers.PaginationAmbiguousInput?) async throws -> Response<Operations.PaginationAmbiguousInputResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationAmbiguousInput.default(),
            configureRequest: { configuration in
                try configurePaginationAmbiguousInputRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationAmbiguousInputResponse
        )
    }
    
    public func paginationBodyFlattenedOptionalSecurity(security: Operations.PaginationBodyFlattenedOptionalSecuritySecurity, limit: Int, offset: Int, server: PaginationServers.PaginationBodyFlattenedOptionalSecurity?) async throws -> Response<Operations.PaginationBodyFlattenedOptionalSecurityResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationBodyFlattenedOptionalSecurity.default(),
            configureRequest: { configuration in
                try configurePaginationBodyFlattenedOptionalSecurityRequest(with: configuration, request: request, security: security)
            },
            handleResponse: handlePaginationBodyFlattenedOptionalSecurityResponse
        )
    }
    
    public func paginationBodyFlattenedWithSecurity(security: Operations.PaginationBodyFlattenedWithSecuritySecurity, limit: Int, offset: Int, server: PaginationServers.PaginationBodyFlattenedWithSecurity?) async throws -> Response<Operations.PaginationBodyFlattenedWithSecurityResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationBodyFlattenedWithSecurity.default(),
            configureRequest: { configuration in
                try configurePaginationBodyFlattenedWithSecurityRequest(with: configuration, request: request, security: security)
            },
            handleResponse: handlePaginationBodyFlattenedWithSecurityResponse
        )
    }
    
    public func paginationBodyWrappedRequest(request: Operations.PaginationBodyWrappedRequestRequest, server: PaginationServers.PaginationBodyWrappedRequest?) async throws -> Response<Operations.PaginationBodyWrappedRequestResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationBodyWrappedRequest.default(),
            configureRequest: { configuration in
                try configurePaginationBodyWrappedRequestRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationBodyWrappedRequestResponse
        )
    }
    
    public func paginationCursorBody(request: Operations.PaginationCursorBodyRequestBody, server: PaginationServers.PaginationCursorBody?) async throws -> Response<Operations.PaginationCursorBodyResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationCursorBody.default(),
            configureRequest: { configuration in
                try configurePaginationCursorBodyRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationCursorBodyResponse
        )
    }
    
    public func paginationCursorNonNumeric(request: Operations.PaginationCursorNonNumericRequest, server: PaginationServers.PaginationCursorNonNumeric?) async throws -> Response<Operations.PaginationCursorNonNumericResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationCursorNonNumeric.default(),
            configureRequest: { configuration in
                try configurePaginationCursorNonNumericRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationCursorNonNumericResponse
        )
    }
    
    public func paginationCursorParams(request: Operations.PaginationCursorParamsRequest, server: PaginationServers.PaginationCursorParams?) async throws -> Response<Operations.PaginationCursorParamsResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationCursorParams.default(),
            configureRequest: { configuration in
                try configurePaginationCursorParamsRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationCursorParamsResponse
        )
    }
    
    public func paginationLimitOffsetDeepOutputsPageBody(request: Shared.LimitOffsetConfig, server: PaginationServers.PaginationLimitOffsetDeepOutputsPageBody?) async throws -> Response<Operations.PaginationLimitOffsetDeepOutputsPageBodyResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationLimitOffsetDeepOutputsPageBody.default(),
            configureRequest: { configuration in
                try configurePaginationLimitOffsetDeepOutputsPageBodyRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationLimitOffsetDeepOutputsPageBodyResponse
        )
    }
    
    public func paginationLimitOffsetOffsetBody(request: Shared.LimitOffsetConfig, server: PaginationServers.PaginationLimitOffsetOffsetBody?) async throws -> Response<Operations.PaginationLimitOffsetOffsetBodyResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationLimitOffsetOffsetBody.default(),
            configureRequest: { configuration in
                try configurePaginationLimitOffsetOffsetBodyRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationLimitOffsetOffsetBodyResponse
        )
    }
    
    public func paginationLimitOffsetOffsetParams(request: Operations.PaginationLimitOffsetOffsetParamsRequest, server: PaginationServers.PaginationLimitOffsetOffsetParams?) async throws -> Response<Operations.PaginationLimitOffsetOffsetParamsResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationLimitOffsetOffsetParams.default(),
            configureRequest: { configuration in
                try configurePaginationLimitOffsetOffsetParamsRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationLimitOffsetOffsetParamsResponse
        )
    }
    
    public func paginationLimitOffsetPageBody(request: Shared.LimitOffsetConfig, server: PaginationServers.PaginationLimitOffsetPageBody?) async throws -> Response<Operations.PaginationLimitOffsetPageBodyResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationLimitOffsetPageBody.default(),
            configureRequest: { configuration in
                try configurePaginationLimitOffsetPageBodyRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationLimitOffsetPageBodyResponse
        )
    }
    
    public func paginationLimitOffsetPageParams(request: Operations.PaginationLimitOffsetPageParamsRequest, server: PaginationServers.PaginationLimitOffsetPageParams?) async throws -> Response<Operations.PaginationLimitOffsetPageParamsResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationLimitOffsetPageParams.default(),
            configureRequest: { configuration in
                try configurePaginationLimitOffsetPageParamsRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationLimitOffsetPageParamsResponse
        )
    }
    
    public func paginationURLParams(request: Operations.PaginationURLParamsRequest, server: PaginationServers.PaginationURLParams?) async throws -> Response<Operations.PaginationURLParamsResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationURLParams.default(),
            configureRequest: { configuration in
                try configurePaginationURLParamsRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationURLParamsResponse
        )
    }
    
    public func paginationWithRetries(request: Operations.PaginationWithRetriesRequest, server: PaginationServers.PaginationWithRetries?) async throws -> Response<Operations.PaginationWithRetriesResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationWithRetries.default(),
            configureRequest: { configuration in
                try configurePaginationWithRetriesRequest(with: configuration, request: request)
            },
            handleResponse: handlePaginationWithRetriesResponse
        )
    }
    
    public func paginationWrappedOptionalBody(request: Operations.PaginationWrappedOptionalBodyRequest, security: Operations.PaginationWrappedOptionalBodySecurity, server: PaginationServers.PaginationWrappedOptionalBody?) async throws -> Response<Operations.PaginationWrappedOptionalBodyResponse> {
        return try await client.makeRequest(
            with: try server?.server() ?? PaginationServers.PaginationWrappedOptionalBody.default(),
            configureRequest: { configuration in
                try configurePaginationWrappedOptionalBodyRequest(with: configuration, request: request, security: security)
            },
            handleResponse: handlePaginationWrappedOptionalBodyResponse
        )
    }

}

// MARK: - Request Configuration

private func configurePaginationAmbiguousInputRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationAmbiguousInputRequest) throws {
    configuration.path = "/pagination/cursor#ambiguousInput"
    configuration.method = .put
    configuration.queryParameterSerializable = request
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request.requestBody)
    if configuration.body == nil {
        throw SerializationError.missingRequiredRequestBody
    }
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationBodyFlattenedOptionalSecurityRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationBodyFlattenedOptionalSecurityRequest, security: Operations.PaginationBodyFlattenedOptionalSecuritySecurity) throws {
    configuration.path = "/pagination/limitoffset/offset#paginationBodyFlattenedOptionalSecurity"
    configuration.method = .get
    configuration.securityParameterProviding = security
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationBodyFlattenedWithSecurityRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationBodyFlattenedWithSecurityRequest, security: Operations.PaginationBodyFlattenedWithSecuritySecurity) throws {
    configuration.path = "/pagination/limitoffset/offset#paginationBodyFlattenedWithSecurity"
    configuration.method = .get
    configuration.securityParameterProviding = security
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationBodyWrappedRequestRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationBodyWrappedRequestRequest) throws {
    configuration.path = "/pagination/limitoffset/page#paginationBodyWrappedRequest"
    configuration.method = .put
    configuration.headerParameterSerializable = request
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request.limitOffsetConfig)
    if configuration.body == nil {
        throw SerializationError.missingRequiredRequestBody
    }
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationCursorBodyRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationCursorBodyRequestBody) throws {
    configuration.path = "/pagination/cursor"
    configuration.method = .put
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request)
    if configuration.body == nil {
        throw SerializationError.missingRequiredRequestBody
    }
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationCursorNonNumericRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationCursorNonNumericRequest) throws {
    configuration.path = "/pagination/cursor_non_numeric"
    configuration.method = .get
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationCursorParamsRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationCursorParamsRequest) throws {
    configuration.path = "/pagination/cursor"
    configuration.method = .get
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationLimitOffsetDeepOutputsPageBodyRequest(with configuration: URLRequestConfiguration, request: Shared.LimitOffsetConfig) throws {
    configuration.path = "/pagination/limitoffset/deep_outputs/page"
    configuration.method = .put
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request)
    if configuration.body == nil {
        throw SerializationError.missingRequiredRequestBody
    }
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationLimitOffsetOffsetBodyRequest(with configuration: URLRequestConfiguration, request: Shared.LimitOffsetConfig) throws {
    configuration.path = "/pagination/limitoffset/offset"
    configuration.method = .put
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request)
    if configuration.body == nil {
        throw SerializationError.missingRequiredRequestBody
    }
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationLimitOffsetOffsetParamsRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationLimitOffsetOffsetParamsRequest) throws {
    configuration.path = "/pagination/limitoffset/offset"
    configuration.method = .get
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationLimitOffsetPageBodyRequest(with configuration: URLRequestConfiguration, request: Shared.LimitOffsetConfig) throws {
    configuration.path = "/pagination/limitoffset/page"
    configuration.method = .put
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request)
    if configuration.body == nil {
        throw SerializationError.missingRequiredRequestBody
    }
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationLimitOffsetPageParamsRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationLimitOffsetPageParamsRequest) throws {
    configuration.path = "/pagination/limitoffset/page"
    configuration.method = .get
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationURLParamsRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationURLParamsRequest) throws {
    configuration.path = "/pagination/url"
    configuration.method = .get
    configuration.queryParameterSerializable = request
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationWithRetriesRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationWithRetriesRequest) throws {
    configuration.path = "/pagination/cursor_non_numeric#withRetries"
    configuration.method = .get
    configuration.queryParameterSerializable = request
    configuration.headerParameterSerializable = request
    configuration.telemetryHeader = .speakeasyUserAgent
}

private func configurePaginationWrappedOptionalBodyRequest(with configuration: URLRequestConfiguration, request: Operations.PaginationWrappedOptionalBodyRequest, security: Operations.PaginationWrappedOptionalBodySecurity) throws {
    configuration.path = "/pagination/limitoffset/offset#paginationWrappedOptionalBody"
    configuration.method = .put
    configuration.securityParameterProviding = security
    configuration.headerParameterSerializable = request
    configuration.contentType = "application/json"
    configuration.body = try jsonEncoder().encode(request.limitOffsetConfig)
    configuration.telemetryHeader = .speakeasyUserAgent
}

// MARK: - Response Handlers

private func handlePaginationAmbiguousInputResponse(response: Client.APIResponse) throws -> Operations.PaginationAmbiguousInputResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationAmbiguousInputRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationBodyFlattenedOptionalSecurityResponse(response: Client.APIResponse) throws -> Operations.PaginationBodyFlattenedOptionalSecurityResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationBodyFlattenedOptionalSecurityRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationBodyFlattenedWithSecurityResponse(response: Client.APIResponse) throws -> Operations.PaginationBodyFlattenedWithSecurityResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationBodyFlattenedWithSecurityRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationBodyWrappedRequestResponse(response: Client.APIResponse) throws -> Operations.PaginationBodyWrappedRequestResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationBodyWrappedRequestRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationCursorBodyResponse(response: Client.APIResponse) throws -> Operations.PaginationCursorBodyResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationCursorBodyRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationCursorNonNumericResponse(response: Client.APIResponse) throws -> Operations.PaginationCursorNonNumericResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationCursorNonNumericRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationCursorParamsResponse(response: Client.APIResponse) throws -> Operations.PaginationCursorParamsResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationCursorParamsRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationLimitOffsetDeepOutputsPageBodyResponse(response: Client.APIResponse) throws -> Operations.PaginationLimitOffsetDeepOutputsPageBodyResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationLimitOffsetDeepOutputsPageBodyRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationLimitOffsetOffsetBodyResponse(response: Client.APIResponse) throws -> Operations.PaginationLimitOffsetOffsetBodyResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationLimitOffsetOffsetBodyRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationLimitOffsetOffsetParamsResponse(response: Client.APIResponse) throws -> Operations.PaginationLimitOffsetOffsetParamsResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationLimitOffsetOffsetParamsRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationLimitOffsetPageBodyResponse(response: Client.APIResponse) throws -> Operations.PaginationLimitOffsetPageBodyResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationLimitOffsetPageBodyRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationLimitOffsetPageParamsResponse(response: Client.APIResponse) throws -> Operations.PaginationLimitOffsetPageParamsResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationLimitOffsetPageParamsRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationURLParamsResponse(response: Client.APIResponse) throws -> Operations.PaginationURLParamsResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationURLParamsRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationWithRetriesResponse(response: Client.APIResponse) throws -> Operations.PaginationWithRetriesResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationWithRetriesRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

private func handlePaginationWrappedOptionalBodyResponse(response: Client.APIResponse) throws -> Operations.PaginationWrappedOptionalBodyResponse {
    let httpResponse = response.httpResponse
    
    if httpResponse.statusCode == 200 { 
        if httpResponse.contentType.matchContentType(pattern: "application/json"), let data = response.data {
            do {
                return .res(try JSONDecoder().decode(Operations.PaginationWrappedOptionalBodyRes.self, from: data))
            } catch {
                throw ResponseHandlerError.failedToDecodeJSON(error)
            }
        }
    }

    return .empty
}

