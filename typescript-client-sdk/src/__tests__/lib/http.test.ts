/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { expect, test, vi } from "vitest";

import { Fetcher, HTTPClient, matchResponse } from "../../lib/http.js";

test("makes requests", async () => {
  const fetcher: Fetcher = vi.fn(async (req) => {
    return new Response(JSON.stringify({ success: true, url: req }), {
      headers: { "content-type": "application/json" },
    });
  });

  const client = new HTTPClient({ fetcher });
  const res = await client.request(new Request("https://example.com/foo"));
  expect(res.ok).toBe(true);

  const body = await res.json();
  expect(body.success).toBe(true);
});

test("applies hooks to request lifecycle", async () => {
  const fetcher: Fetcher = vi.fn(async () => new Response("ok"));

  const client = new HTTPClient({ fetcher });

  const onRequest = vi.fn();
  const onError = vi.fn();
  const onResponse = vi.fn();
  const asyncOnRequest = vi.fn();
  const asyncOnError = vi.fn();
  const asyncOnResponse = vi.fn();

  client
    .addHook("beforeRequest", onRequest)
    .addHook("requestError", onError)
    .addHook("response", onResponse);

  client
    .addHook("beforeRequest", async (req) => {
      asyncOnRequest(req);
    })
    .addHook("requestError", async (err, req) => {
      asyncOnError(err, req);
    })
    .addHook("response", async (res) => {
      asyncOnResponse(res, req);
    });

  const req = new Request("https://example.com/foo");
  const res = await client.request(req);
  expect(res.ok).toBe(true);

  expect(onRequest).toHaveBeenCalledWith(req);
  expect(asyncOnRequest).toHaveBeenCalledWith(req);

  expect(onError).not.toHaveBeenCalledWith(req);
  expect(asyncOnError).not.toHaveBeenCalledWith(req);

  expect(onResponse).toHaveBeenCalledWith(res, req);
  expect(asyncOnResponse).toHaveBeenCalledWith(res, req);
});

test("allows request hooks to mutate requests", async () => {
  const fetcher: Fetcher = vi.fn(async (req) => {
    if (!(req instanceof Request)) {
      throw new Error("expected a Request object");
    }

    return new Response(req.headers.get("test-header"));
  });

  const client = new HTTPClient({ fetcher });
  // mutate request
  client.addHook("beforeRequest", (req) => {
    req.headers.append("test-header", "a");
  });
  // return new request
  client.addHook("beforeRequest", async (req) => {
    const next = new Request(req);
    next.headers.append("test-header", "b");
    return next;
  });

  const res = await client.request(new Request("https://example.com/foo"));
  expect(res.ok).toBe(true);

  const body = await res.text();
  expect(body).toEqual("a, b");
});

test("applies error hooks", async () => {
  const err = new Error("simulated error");
  const fetcher: Fetcher = vi.fn(async () => {
    throw err;
  });

  const client = new HTTPClient({ fetcher });

  const hook = vi.fn();
  const asyncHook = vi.fn();

  client.addHook("requestError", hook);
  client.addHook("requestError", asyncHook);

  const req = new Request("https://example.com/foo");
  await expect(client.request(req)).rejects.toEqual(err);

  expect(hook).toHaveBeenCalledWith(err, req);
  expect(asyncHook).toHaveBeenCalledWith(err, req);
});

test("applies multiple hooks", async () => {
  const fetcher: Fetcher = vi.fn(async () => new Response("ok"));

  const client = new HTTPClient({ fetcher });

  const hookA = vi.fn();
  const hookB = vi.fn();

  client.addHook("response", hookA).addHook("response", hookB);

  const req = new Request("https://example.com/foo");
  const res = await client.request(req);
  expect(res.ok).toBe(true);

  expect(hookA).toHaveBeenCalledWith(res, req);
  expect(hookB).toHaveBeenCalledWith(res, req);
});

test("removes hooks", async () => {
  const fetcher: Fetcher = vi.fn(async () => new Response("ok"));

  const client = new HTTPClient({ fetcher });

  const hookA = vi.fn();
  const hookB = vi.fn();
  const hookC = vi.fn();
  const hookD = vi.fn();
  const asyncHookD = async () => {
    hookD();
  };

  client.addHook("response", hookA);
  client.addHook("response", hookB);
  client.addHook("response", hookC);
  client.addHook("response", asyncHookD);

  client.removeHook("response", hookB);
  client.removeHook("response", asyncHookD);

  const req = new Request("https://example.com/foo");
  const res = await client.request(req);
  expect(res.ok).toBe(true);

  expect(hookA).toHaveBeenCalledWith(res, req);
  expect(hookB).not.toHaveBeenCalled();
  expect(hookC).toHaveBeenCalledWith(res, req);
  expect(hookD).not.toHaveBeenCalled();
});

test("clones into new client with no shared state", async () => {
  const fetcher: Fetcher = vi.fn(async () => new Response("ok"));

  const onResponseParent = vi.fn();
  const onResponseChild = vi.fn();

  const parent = new HTTPClient({ fetcher });
  parent.addHook("response", onResponseParent);

  const child = parent.clone();
  child.addHook("response", onResponseChild);

  // Check that child hooks aren't inadvertently added to parent internal hook
  // arrays.
  let req = new Request("https://example.com/foo");
  let res = await parent.request(req);
  expect(res.ok).toBe(true);

  expect(onResponseParent).toHaveBeenCalledWith(res, req);
  expect(onResponseChild).not.toHaveBeenCalled();

  onResponseParent.mockClear();

  // Check that child does take on the hooks registered on the parent.
  req = new Request("https://example.com/foo");
  res = await child.request(req);

  expect(onResponseParent).toHaveBeenCalledWith(res, req);
  expect(onResponseChild).toHaveBeenCalledWith(res, req);
});

test("matches content types to expected content types", async () => {
  type TestCase = {
    title: string;
    input: string;
    pattern: string;
  };

  const match: TestCase[] = [
    { title: "simple match", input: "text/plain", pattern: "text/plain" },
    { title: "wildcard", input: "text/plain", pattern: "*" },
    {
      title: "wildcard and input params",
      input: "text/plain;v=1",
      pattern: "*",
    },
    { title: "wildcard slash", input: "text/plain", pattern: "*/*" },
    {
      title: "wildcard slash and input params",
      input: "text/plain;v=1",
      pattern: "*/*;v=1",
    },
    { title: "partial wildcard", input: "text/plain", pattern: "text/*" },
    { title: "exact", input: "text/plain", pattern: "text/plain" },
    {
      title: "one param",
      input: "text/plain;charset=utf-8",
      pattern: "text/plain;charset=utf-8",
    },
    {
      title: "many params",
      input: "text/plain;charset=utf-8;q=3;v=1",
      pattern: "text/plain;v=1;charset=utf-8;q=3",
    },
    {
      title: "excess params",
      input: "text/plain;charset=utf-8;v=2",
      pattern: "text/plain;charset=utf-8",
    },
    {
      title: "case-insensitive",
      input: "text/plain;charset=UTF-8",
      pattern: "Text/Plain; charset=utf-8",
    },
    {
      title: "space-insensitive",
      input: "text/plain ;  charset=utf-8",
      pattern: "text/plain; charset=utf-8",
    },
    {
      title: "leading and trailing spaces",
      input: "    text/plain;charset=utf-8",
      pattern: "text/plain; charset=utf-8    ",
    },
  ];

  match.forEach(({ title, input, pattern }) => {
    const res = new Response("", {
      headers: { "content-type": input },
      status: 200,
    });

    expect(
      matchResponse(res, 200, pattern),
      `expected ${title} test to succeed`,
    ).toBe(true);
  });

  const mismatch: TestCase[] = [
    {
      title: "different content types",
      input: "text/plain",
      pattern: "application/json",
    },
    {
      title: "different types",
      input: "text/json",
      pattern: "application/json",
    },
    {
      title: "different subtypes",
      input: "application/json",
      pattern: "application/xml",
    },
    {
      title: "wildcard slash and different params",
      input: "text/plain;v=2",
      pattern: "*/*;v=1",
    },
    {
      title: "different wildcard type",
      input: "application/json",
      pattern: "*/xml",
    },
    {
      title: "different wildcard subtype",
      input: "text/json",
      pattern: "application/*",
    },
    {
      title: "no params",
      input: "text/plain",
      pattern: "text/plain;charset=utf-8;v=2",
    },
    {
      title: "missing params",
      input: "text/plain;v=2",
      pattern: "text/plain;charset=utf-8;v=2",
    },
    {
      title: "different params",
      input: "text/plain;charset=utf-8;v=2",
      pattern: "text/plain;charset=latin-1;v=2",
    },
    { title: "malformed pattern", input: "text/plain", pattern: "text" },
    { title: "malformed input type", input: "text/", pattern: "text/plain" },
    { title: "missing input type", input: ";v=1", pattern: "text/plain" },
    { title: "missing pattern type", input: "text/plain", pattern: ";v=1" },
    { title: "empty", input: "", pattern: "" },
    { title: "only spaces", input: "  ", pattern: "" },
  ];

  mismatch.forEach(({ title, input, pattern }) => {
    const res = new Response("", {
      headers: { "content-type": input },
      status: 200,
    });

    expect(
      matchResponse(res, 200, pattern),
      `expected ${title} test to fail`,
    ).toBe(false);
  });
});
