/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { test, expect, vi } from "vitest";

import { retry } from "../../lib/retries.js";

test("passes through successful response", async () => {
  const fn = vi.fn(async () => {
    return new Response("test response", {
      status: 201,
    });
  });

  const res = await retry(fn, {
    config: {
      strategy: "backoff",
      backoff: {
        initialInterval: 10,
        maxInterval: 20,
        exponent: 1.5,
        maxElapsedTime: 100,
      },
    },
    statusCodes: ["4xx", "5xx"],
  });

  expect(fn).toHaveBeenCalledTimes(1);
  expect(await res.status).toEqual(201);
  expect(await res.text()).toEqual("test response");
});

test("does not retry with 'none' strategy ", async () => {
  const fn = vi.fn(async () => {
    return new Response("server error", {
      status: 503,
    });
  });

  const res = await retry(fn, {
    config: { strategy: "none" },
    statusCodes: ["5xx"],
  });

  expect(fn).toHaveBeenCalledTimes(1);
  expect(await res.status).toEqual(503);
  expect(await res.text()).toEqual("server error");
});

test("retries specified status codes", async () => {
  let attempts = 0;
  const fn = vi.fn(async () => {
    attempts += 1;
    return new Response("test response", {
      status: attempts > 2 ? 201 : 503,
    });
  });

  const res = await retry(fn, {
    config: {
      strategy: "backoff",
      backoff: {
        initialInterval: 10,
        maxInterval: 20,
        exponent: 1.5,
        maxElapsedTime: 1000,
      },
    },
    statusCodes: ["503"],
  });

  expect(fn).toHaveBeenCalledTimes(3);
  expect(await res.status).toEqual(201);
  expect(await res.text()).toEqual("test response");
});

test("retries specified status code ranges", async () => {
  let attempts = 0;
  const fn = vi.fn(async () => {
    attempts += 1;
    return new Response("test response", {
      status: attempts > 2 ? 201 : 401,
    });
  });

  const res = await retry(fn, {
    config: {
      strategy: "backoff",
      backoff: {
        initialInterval: 10,
        maxInterval: 20,
        exponent: 1.5,
        maxElapsedTime: 1000,
      },
    },
    statusCodes: ["4xx"],
  });

  expect(fn).toHaveBeenCalledTimes(3);
  expect(await res.status).toEqual(201);
  expect(await res.text()).toEqual("test response");
});

test("returns response after retries are exhausted", async () => {
  const fn = vi.fn(async () => {
    return new Response("server error", {
      status: 500,
    });
  });

  const res = await retry(fn, {
    config: {
      strategy: "backoff",
      backoff: {
        initialInterval: 10,
        maxInterval: 50,
        exponent: 2,
        maxElapsedTime: 100,
      },
    },
    statusCodes: ["5xx"],
  });

  expect(fn.mock.calls.length).toBeGreaterThanOrEqual(3);
  expect(await res.status).toEqual(500);
  expect(await res.text()).toEqual("server error");
});

test("does not retry connection errors by default", async () => {
  const fn = vi.fn(async () => {
    throw new Error("fetch failed");
  });

  expect(
    retry(fn, {
      config: {
        strategy: "backoff",
        backoff: {
          initialInterval: 10,
          maxInterval: 50,
          exponent: 2,
          maxElapsedTime: 100,
        },
      },
      statusCodes: ["5xx"],
    }),
  ).rejects.toThrow("fetch failed");

  expect(fn).toHaveBeenCalledTimes(1);
});

test("does not retry timeout errors by default", async () => {
  const signal = AbortSignal.timeout(10);
  const fn = vi.fn(async () => {
    await new Promise((res) => setTimeout(res, 50));
    signal.throwIfAborted();
    throw new Error("unreachable code");
  });

  try {
    await retry(fn, {
      config: {
        strategy: "backoff",
        backoff: {
          initialInterval: 10,
          maxInterval: 50,
          exponent: 2,
          maxElapsedTime: 100,
        },
      },
      statusCodes: ["5xx"],
    });
    expect.unreachable("operation should have thrown an error");
  } catch (err) {
    expect(err).toHaveProperty("name", "TimeoutError");
  }

  expect(fn).toHaveBeenCalledTimes(1);
});

test("retries connection errors", async () => {
  let attempts = 0;
  const fn = vi.fn(async () => {
    attempts += 1;
    if (attempts < 3) {
      throw new TypeError("Fetch failed: simulated error");
    }

    return new Response("test response", { status: 200 });
  });

  const res = await retry(fn, {
    config: {
      strategy: "backoff",
      backoff: {
        initialInterval: 10,
        maxInterval: 20,
        exponent: 1.5,
        maxElapsedTime: 1000,
      },
      retryConnectionErrors: true,
    },
    statusCodes: ["503"],
  });

  expect(fn.mock.calls.length).toBeGreaterThanOrEqual(3);
  expect(await res.status).toEqual(200);
  expect(await res.text()).toEqual("test response");
});

test("retries timeout errors", async () => {
  const signal = AbortSignal.timeout(10);
  await new Promise((res) => setTimeout(res, 20));

  let attempts = 0;
  const fn = vi.fn(async () => {
    attempts += 1;
    if (attempts < 3) {
      signal.throwIfAborted();
      expect.unreachable("signal should have been aborted with timeout");
    }

    return new Response("test response", { status: 200 });
  });

  const res = await retry(fn, {
    config: {
      strategy: "backoff",
      backoff: {
        initialInterval: 10,
        maxInterval: 20,
        exponent: 1.5,
        maxElapsedTime: 1000,
      },
      retryConnectionErrors: true,
    },
    statusCodes: ["503"],
  });

  expect(fn.mock.calls.length).toBeGreaterThanOrEqual(3);
  expect(await res.status).toEqual(200);
  expect(await res.text()).toEqual("test response");
});
