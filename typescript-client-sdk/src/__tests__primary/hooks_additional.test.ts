/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { expect, test, vi } from "vitest";

import { SDK } from "../index.js";
import { TestHooksRes } from "../sdk/models/operations/testhooks.js";

import { recordTest } from "./common_helpers.js";
import { UnexpectedClientError } from "../sdk/models/errors/httpclienterrors.js";
import { HTTPClient } from "../lib/http.js";

test("Test hooks", async () => {
  recordTest("test-hooks");

  const s = new SDK({
    security: {
      apiKeyAuth: "Token YOUR_API_KEY",
    },
  });

  const response = await s.hooks.testHooks("someInitialValue");
  expect(response).toBeDefined();
  expect(response.httpMeta.response.status).toBe(200);
  expect(response.res).toEqual({
    args: {
      someParam: "overriddenParam",
    },
    headers: {
      clientLevelHeader: "added by client",
      idempotencyKey: "some-key",
    },
    url: "http://localhost:35123/anything/hooks?someParam=overriddenParam",
  } as TestHooksRes);
});

test("Test hooks before create request", async () => {
  recordTest("test-hooks-before-create-request");

  const s = new SDK({
    security: {
      apiKeyAuth: "Token YOUR_API_KEY",
    },
  });

  const response = await s.hooks.testHooksBeforeCreateRequestPaths("foo/bar");
  expect(response).toBeDefined();
  expect(response.httpMeta.response.status).toBe(200);
  expect(response.res).toEqual({
    url: "http://localhost:35123/anything/hooks/beforeCreateRequestPaths/foo/bar",
    headers: {
      oldPathname: "/anything/hooks/beforeCreateRequestPaths/foo%2Fbar",
    },
  });
});

test("Test hooks after response", async () => {
  recordTest("test-hooks-after-response");

  const s = new SDK({
    security: {
      apiKeyAuth: "Token YOUR_API_KEY",
    },
  });

  try {
    await s.hooks.testHooksAfterResponse();
    expect.unreachable("sdk call is expected to fail");
  } catch (err: unknown) {
    expect(err).toBeInstanceOf(UnexpectedClientError);
    expect(err).toHaveProperty(["cause", "message"], "validation failed");
  }
});

test("Test hooks error", async () => {
  recordTest("test-hooks-error");

  const s = new SDK({
    security: {
      apiKeyAuth: "Token YOUR_API_KEY",
    },
  });

  try {
    await s.hooks.testHooksError();
    expect.unreachable("sdk call is expected to fail");
  } catch (err: unknown) {
    expect(err).toBeInstanceOf(UnexpectedClientError);
    expect(err).toHaveProperty(["cause", "message"], "special test error case");
  }
});

test("Test hooks authorization header modification", async () => {
  recordTest("hooks-authorization-header-modification");

  const s = new SDK({
    security: {
      apiKeyAuth: "Bearer testToken",
    },
  });

  const res = await s.hooks.authorizationHeaderModification();
  expect(res).toBeDefined();
  expect(res.httpMeta.response.status).toBe(200);
  expect(res.token?.authenticated).toBe(true);
  expect(res.token?.token).toBe("testToken modified");
});

test("Hooks can trigger retries", async () => {
  recordTest("hooks-trigger-retries");

  const spy = vi.fn();
  const httpClient = new HTTPClient().addHook("beforeRequest", spy);

  const s = new SDK({
    httpClient,
  });

  const retries = {
    strategy: "backoff",
    backoff: {
      exponent: 1.5,
      initialInterval: 50,
      maxInterval: 100,
      maxElapsedTime: 1000,
    },
  } as const;

  let res = await s.requestBodies.nullableObjectPost(null, { retries });

  expect(res).toBeDefined();
  expect(res.httpMeta.response.status).toBe(200);
  expect(spy).toHaveBeenCalledTimes(1);

  spy.mockReset();
  expect(spy).toHaveBeenCalledTimes(0);

  res = await s.requestBodies.nullableObjectPost(null, {
    retries,
    fetchOptions: { headers: { "x-force-retry-hook": "force-retry" } },
  });

  expect(res).toBeDefined();
  expect(res.httpMeta.response.status).toBe(200);
  expect(spy).toHaveBeenCalledTimes(2);
});

test("Hooks can access retry config for a method call", async () => {
  recordTest("hooks-access-retry-config");

  const spy = vi.fn();
  const httpClient = new HTTPClient().addHook("beforeRequest", spy);

  const s = new SDK({
    httpClient,
  });

  const retries = { strategy: "none" } as const;

  const res = await s.requestBodies.nullableObjectPost(null, {
    retries,
    fetchOptions: { headers: { "x-force-retry-hook": "force-retry" } },
  });

  expect(res).toBeDefined();
  expect(res.httpMeta.response.status).toBe(200);
  expect(spy).toHaveBeenCalledTimes(1);
});

test("Hooks can terminate retry loop", async () => {
  recordTest("hooks-terminate-retry-loop");

  let once = true;
  const spy = vi.fn();
  const httpClient = new HTTPClient()
    .addHook("beforeRequest", spy)
    .addHook("beforeRequest", (req) => {
      if (once) {
        once = false;
        req.headers.set("x-teapot", "json");
      }
    });

  const sdk = new SDK({
    httpClient,
  });

  const retries = {
    strategy: "backoff",
    backoff: {
      exponent: 1.5,
      initialInterval: 50,
      maxInterval: 100,
      maxElapsedTime: 1000,
    },
  } as const;

  const res1 = await sdk.methods.methodGet({
    serverURL: "http://localhost:35456",
    retries,
    retryCodes: ["418"],
  });

  expect(res1).toBeDefined();
  expect(res1.httpMeta.response.status).toBe(200);
  expect(spy).toHaveBeenCalledTimes(2);

  spy.mockReset();
  expect(spy).toHaveBeenCalledTimes(0);

  // At this point, we've confirmed that retry behavior works as expected.
  // Below we will test to see if the hook can force a permanent error and abort
  // the retry loop.

  once = true;
  await expect(
    sdk.methods.methodGet({
      serverURL: "http://localhost:35456",
      retries,
      retryCodes: ["418"],
      fetchOptions: {
        headers: {
          "x-force-retry-hook": "skip-retry",
        },
      },
    }),
  ).rejects.toThrow("Permanent error encountered");
});
