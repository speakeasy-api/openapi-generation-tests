/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { expect, test } from "vitest";

import {
  RetriesGetResponse,
  RetriesAfterResponse,
} from "../sdk/models/operations";
import { SDK } from "..";
import { SDKError } from "../sdk/models/errors";
import { recordTest } from "./common_helpers";

test("Test Retries Succeeds", async () => {
  recordTest("retries-succeeds");

  const sdk = new SDK({});

  const res: RetriesGetResponse = await sdk.retries.retriesGet(pseudoUUID());

  expect(res.statusCode).toBeDefined();
  expect(res.statusCode).toBe(200);
  expect(res.retries?.retries).toBe(3);
});

test("Test Retries Timeout", async () => {
  recordTest("retries-timeout");

  const sdk = new SDK({});

  try {
    await sdk.retries.retriesGet(pseudoUUID(), 1000000000, {
      retries: {
        strategy: "backoff",
        backoff: {
          initialInterval: 1,
          maxInterval: 50,
          exponent: 1.1,
          maxElapsedTime: 100,
        },
        retryConnectionErrors: false,
      },
    });

    expect.unreachable("SDK call should not have succeeded");
  } catch (e) {
    expect(e).toBeInstanceOf(SDKError);

    const sdkErr = e as SDKError;
    expect(sdkErr.statusCode).toBe(503);
  }
});

test("Test Respect Retry After", async () => {
  recordTest("retries-header");

  const sdk = new SDK({});

  const res: RetriesAfterResponse = await sdk.retries.retriesAfter(
    pseudoUUID(),
    3,
    1,
    {
      retries: {
        strategy: "backoff",
        backoff: {
          initialInterval: 5000,
          maxInterval: 10000,
          exponent: 1.1,
          maxElapsedTime: 10000,
        },
        retryConnectionErrors: false,
      },
    },
  );

  expect(res.statusCode).toBeDefined();
  expect(res.statusCode).toBe(200);
  expect(res.retries?.retries).toBe(3);
});

test("TestGlobalRetryConfigDisable", async () => {
  recordTest("retries-global-config-disable");

  const sdk = new SDK({
    retryConfig: { strategy: "none" },
  });

  try {
    await sdk.retries.retriesGet(pseudoUUID(), 2);

    expect.unreachable("SDK call should not have succeeded");
  } catch (e) {
    expect(e).toBeInstanceOf(SDKError);

    const sdkErr = e as SDKError;
    expect(sdkErr.statusCode).toBe(503);
  }
});

test("TestGlobalRetryConfigSuccess", async () => {
  recordTest("retries-global-config-success");
  const sdk = new SDK({
    retryConfig: {
      strategy: "backoff",
      backoff: {
        initialInterval: 1,
        maxInterval: 50,
        exponent: 1.1,
        maxElapsedTime: 200,
      },
      retryConnectionErrors: false,
    },
  });

  const res: RetriesGetResponse = await sdk.retries.retriesGet(pseudoUUID(), 2);

  expect(res.statusCode).toBeDefined();
  expect(res.statusCode).toBe(200);
  expect(res.retries?.retries).toBe(2);
});

test("TestGlobalRetryConfigTimeout", async () => {
  recordTest("retries-global-config-timeout");
  const sdk = new SDK({
    retryConfig: {
      strategy: "backoff",
      backoff: {
        initialInterval: 1,
        maxInterval: 50,
        exponent: 1.1,
        maxElapsedTime: 100,
      },
      retryConnectionErrors: false,
    },
  });

  try {
    await sdk.retries.retriesGet(pseudoUUID(), 30);

    expect.unreachable("SDK call should not have succeeded");
  } catch (e) {
    expect(e).toBeInstanceOf(SDKError);

    const sdkErr = e as SDKError;
    expect(sdkErr.statusCode).toBe(503);
  }
});

function pseudoUUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
    const r = (Math.random() * 16) | 0,
      v = c == "x" ? r : (r & 0x3) | 0x8;
    return v.toString(16);
  });
}
