/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeSimple as encodeSimple$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { SecurityInput } from "../lib/security.js";
import * as operations from "./models/operations/index.js";
import * as shared from "./models/shared/index.js";
import { Decimal as Decimal$ } from "./types/decimal.js";
import { RFCDate } from "./types/rfcdate.js";

export class Generation extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    async anchorTypesGet(options?: RequestOptions): Promise<operations.AnchorTypesGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/anchorTypes")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "anchorTypesGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.AnchorTypesGetResponse>()
            .json(200, operations.AnchorTypesGetResponse$, { key: "TypeFromAnchor" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async arrayCircularReferenceGet(
        options?: RequestOptions
    ): Promise<operations.ArrayCircularReferenceGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/arrayCircularReference")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "arrayCircularReferenceGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.ArrayCircularReferenceGetResponse>()
            .json(200, operations.ArrayCircularReferenceGetResponse$, {
                key: "arrayCircularReferenceObject",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async circularReferenceGet(
        options?: RequestOptions
    ): Promise<operations.CircularReferenceGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/circularReference")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "circularReferenceGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.CircularReferenceGetResponse>()
            .json(200, operations.CircularReferenceGetResponse$, {
                key: "validCircularReferenceObject",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async dateParamWithDefault(
        dateInput: RFCDate | undefined,
        options?: RequestOptions
    ): Promise<operations.DateParamWithDefaultResponse> {
        const input$: operations.DateParamWithDefaultRequest = {
            dateInput: dateInput,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DateParamWithDefaultRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/dateParamWithDefault")();

        const query$ = encodeFormQuery$({
            dateInput: payload$.dateInput,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "dateParamWithDefault",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.DateParamWithDefaultResponse>()
            .void(204, operations.DateParamWithDefaultResponse$)
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async dateTimeParamWithDefault(
        dateTimeInput: Date | undefined,
        options?: RequestOptions
    ): Promise<operations.DateTimeParamWithDefaultResponse> {
        const input$: operations.DateTimeParamWithDefaultRequest = {
            dateTimeInput: dateTimeInput,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DateTimeParamWithDefaultRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/dateTimeParamWithDefault")();

        const query$ = encodeFormQuery$({
            dateTimeInput: payload$.dateTimeInput,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "dateTimeParamWithDefault",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.DateTimeParamWithDefaultResponse>()
            .void(204, operations.DateTimeParamWithDefaultResponse$)
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async decimalParamWithDefault(
        decimalInput: Decimal$ | number | undefined,
        options?: RequestOptions
    ): Promise<operations.DecimalParamWithDefaultResponse> {
        const input$: operations.DecimalParamWithDefaultRequest = {
            decimalInput: decimalInput,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DecimalParamWithDefaultRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/decimalParamWithDefault")();

        const query$ = encodeFormQuery$({
            decimalInput: payload$.decimalInput,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "decimalParamWithDefault",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.DecimalParamWithDefaultResponse>()
            .void(204, operations.DecimalParamWithDefaultResponse$)
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async deprecatedFieldInSchemaPost(
        request: shared.DeprecatedFieldInObject,
        options?: RequestOptions
    ): Promise<operations.DeprecatedFieldInSchemaPostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DeprecatedFieldInObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/deprecatedFieldInSchema")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "deprecatedFieldInSchemaPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.DeprecatedFieldInSchemaPostResponse>()
            .void(200, operations.DeprecatedFieldInSchemaPostResponse$)
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async deprecatedObjectInSchemaGet(
        options?: RequestOptions
    ): Promise<operations.DeprecatedObjectInSchemaGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/deprecatedObjectInSchema")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "deprecatedObjectInSchemaGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.DeprecatedObjectInSchemaGetResponse>()
            .json(200, operations.DeprecatedObjectInSchemaGetResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async deprecatedOperationNoCommentsGet(
        deprecatedParameter?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.DeprecatedOperationNoCommentsGetResponse> {
        const input$: operations.DeprecatedOperationNoCommentsGetRequest = {
            deprecatedParameter: deprecatedParameter,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeprecatedOperationNoCommentsGetRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/deprecatedOperationNoComments")();

        const query$ = encodeFormQuery$({
            deprecatedParameter: payload$.deprecatedParameter,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "deprecatedOperationNoCommentsGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.DeprecatedOperationNoCommentsGetResponse>()
            .void(200, operations.DeprecatedOperationNoCommentsGetResponse$)
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * This is an endpoint setup to test deprecation with comments
     *
     * @deprecated method: This operation is deprecated. Use simplePathParameterObjects instead.
     */
    async deprecatedOperationWithCommentsGet(
        deprecatedParameter?: string | undefined,
        newParameter?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.DeprecatedOperationWithCommentsGetResponse> {
        const input$: operations.DeprecatedOperationWithCommentsGetRequest = {
            deprecatedParameter: deprecatedParameter,
            newParameter: newParameter,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeprecatedOperationWithCommentsGetRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/deprecatedOperationWithComments")();

        const query$ = encodeFormQuery$({
            deprecatedParameter: payload$.deprecatedParameter,
            newParameter: payload$.newParameter,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "deprecatedOperationWithCommentsGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.DeprecatedOperationWithCommentsGetResponse>()
                .void(200, operations.DeprecatedOperationWithCommentsGetResponse$)
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async emptyObjectGet(
        emptyObject: shared.EmptyObjectParam,
        options?: RequestOptions
    ): Promise<operations.EmptyObjectGetResponse> {
        const input$: operations.EmptyObjectGetRequest = {
            emptyObject: emptyObject,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.EmptyObjectGetRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            emptyObject: encodeSimple$("emptyObject", payload$.emptyObject, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/anything/{emptyObject}")(pathParams$);

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "emptyObjectGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.EmptyObjectGetResponse>()
            .void(200, operations.EmptyObjectGetResponse$)
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async emptyResponseObjectWithCommentGet(
        options?: RequestOptions
    ): Promise<operations.EmptyResponseObjectWithCommentGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/octet-stream");

        const path$ = this.templateURLComponent("/anything/emptyResponseObjectWithComment")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "emptyResponseObjectWithCommentGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.EmptyResponseObjectWithCommentGetResponse>()
            .bytes(200, operations.EmptyResponseObjectWithCommentGetResponse$, { key: "Body" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async globalNameOverridden(
        request?: shared.SimpleObject | undefined,
        options?: RequestOptions
    ): Promise<operations.GetGlobalNameOverrideResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$.outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/globalNameOverride")();

        const query$ = "";

        headers$.set(
            "any",
            encodeSimple$("any", payload$?.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            encodeSimple$("bigint", payload$?.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            encodeSimple$("bigintStr", payload$?.bigintStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "bool",
            encodeSimple$("bool", payload$?.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            encodeSimple$("boolOpt", payload$?.boolOpt, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "date",
            encodeSimple$("date", payload$?.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            encodeSimple$("dateTime", payload$?.dateTime, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimal",
            encodeSimple$("decimal", payload$?.decimal, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimalStr",
            encodeSimple$("decimalStr", payload$?.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            encodeSimple$("enum", payload$?.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            encodeSimple$("float32", payload$?.float32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float64Str",
            encodeSimple$("float64Str", payload$?.float64Str, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "int",
            encodeSimple$("int", payload$?.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            encodeSimple$("int32", payload$?.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            encodeSimple$("int32Enum", payload$?.int32Enum, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "int64Str",
            encodeSimple$("int64Str", payload$?.int64Str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intEnum",
            encodeSimple$("intEnum", payload$?.intEnum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intOptNull",
            encodeSimple$("intOptNull", payload$?.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            encodeSimple$("num", payload$?.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            encodeSimple$("numOptNull", payload$?.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            encodeSimple$("str", payload$?.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            encodeSimple$("strOpt", payload$?.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "getGlobalNameOverride",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.GetGlobalNameOverrideResponse>()
            .json(200, operations.GetGlobalNameOverrideResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async ignoredGenerationGet(
        options?: RequestOptions
    ): Promise<operations.IgnoredGenerationGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/ignoredGeneration")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "ignoredGenerationGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.IgnoredGenerationGetResponse>()
            .json(200, operations.IgnoredGenerationGetResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async ignoresPost(
        requestBody: operations.IgnoresPostRequestBody,
        testParam?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.IgnoresPostResponse> {
        const input$: operations.IgnoresPostRequest = {
            requestBody: requestBody,
            testParam: testParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.IgnoresPostRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const path$ = this.templateURLComponent("/anything/ignores")();

        const query$ = encodeFormQuery$({
            testParam: payload$.testParam,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "ignoresPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.IgnoresPostResponse>()
            .json(200, operations.IgnoresPostResponse$, { key: "httpBinSimpleJsonObject" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async nameOverride(
        testEnumQueryParam: operations.EnumNameOverride,
        testQueryParam: string,
        options?: RequestOptions
    ): Promise<operations.NameOverrideGetResponse> {
        const input$: operations.NameOverrideGetRequest = {
            testEnumQueryParam: testEnumQueryParam,
            testQueryParam: testQueryParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.NameOverrideGetRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/nameOverride")();

        const query$ = encodeFormQuery$({
            enumNameOverride: payload$.testEnumQueryParam,
            nameOverride: payload$.testQueryParam,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nameOverrideGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.NameOverrideGetResponse>()
            .json(200, operations.NameOverrideGetResponse$, { key: "overriddenResponse" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async objectCircularReferenceGet(
        options?: RequestOptions
    ): Promise<operations.ObjectCircularReferenceGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/objectCircularReference")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "objectCircularReferenceGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.ObjectCircularReferenceGetResponse>()
            .json(200, operations.ObjectCircularReferenceGetResponse$, {
                key: "objectCircularReferenceObject",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async oneOfCircularReferenceGet(
        options?: RequestOptions
    ): Promise<operations.OneOfCircularReferenceGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/oneOfCircularReference")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "oneOfCircularReferenceGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.OneOfCircularReferenceGetResponse>()
            .json(200, operations.OneOfCircularReferenceGetResponse$, {
                key: "oneOfCircularReferenceObject",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async typedParameterGenerationGet(
        bigint?: bigint | undefined,
        date?: RFCDate | undefined,
        decimal?: Decimal$ | number | undefined,
        obj?: operations.Obj | undefined,
        options?: RequestOptions
    ): Promise<operations.TypedParameterGenerationGetResponse> {
        const input$: operations.TypedParameterGenerationGetRequest = {
            bigint: bigint,
            date: date,
            decimal: decimal,
            obj: obj,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.TypedParameterGenerationGetRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/typedParameterGeneration")();

        const query$ = encodeFormQuery$({
            bigint: payload$.bigint,
            date: payload$.date,
            decimal: payload$.decimal,
            obj: payload$.obj,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "typedParameterGenerationGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.TypedParameterGenerationGetResponse>()
            .void(200, operations.TypedParameterGenerationGetResponse$)
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * An operation used for testing usage examples
     *
     * @remarks
     * An operation used for testing usage examples that includes a large array of parameters and input types to ensure that all are handled correctly
     *
     * @see {@link https://docs.example.com} - Usage example docs
     */
    async usageExamplePost(
        request: operations.UsageExamplePostRequest,
        security: operations.UsageExamplePostSecurity,
        options?: RequestOptions
    ): Promise<operations.UsageExamplePostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.UsageExamplePostRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const path$ = this.templateURLComponent("/anything/usageExample")();

        const query$ = encodeFormQuery$({
            bigintParameter: payload$.bigintParameter,
            bigintParameterOptional: payload$.bigintParameterOptional,
            bigintStrParameter: payload$.bigintStrParameter,
            bigintStrParameterOptional: payload$.bigintStrParameterOptional,
            boolParameter: payload$.boolParameter,
            dateParameter: payload$.dateParameter,
            dateTimeDefaultParameter: payload$.dateTimeDefaultParameter,
            dateTimeParameter: payload$.dateTimeParameter,
            decimalParameter: payload$.decimalParameter,
            decimalParameterOptional: payload$.decimalParameterOptional,
            decimalStrParameter: payload$.decimalStrParameter,
            decimalStrParameterOptional: payload$.decimalStrParameterOptional,
            doubleParameter: payload$.doubleParameter,
            enumParameter: payload$.enumParameter,
            falseyNumberParameter: payload$.falseyNumberParameter,
            float32Parameter: payload$.float32Parameter,
            float64StringParameter: payload$.float64StringParameter,
            floatParameter: payload$.floatParameter,
            int64Parameter: payload$.int64Parameter,
            int64StringParameter: payload$.int64StringParameter,
            intParameter: payload$.intParameter,
            optEnumParameter: payload$.optEnumParameter,
            strParameter: payload$.strParameter,
        });

        const security$: SecurityInput[][] = [
            [
                {
                    type: "http:basic",
                    value: { username: security?.username, password: security?.password },
                },
            ],
        ];
        const securitySettings$ = this.resolveSecurity(...security$);
        const context = {
            operationID: "usageExamplePost",
            oAuth2Scopes: [],
            securitySource: security$,
        };

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.UsageExamplePostResponse>()
            .json(200, operations.UsageExamplePostResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }
}
