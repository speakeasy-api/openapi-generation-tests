/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import * as b64$ from "../lib/base64.js";
import { SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeSimple as encodeSimple$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { extractSecurity, SecurityInput } from "../lib/security.js";
import * as operations from "./models/operations/index.js";
import * as shared from "./models/shared/index.js";
import { Decimal as Decimal$ } from "./types/decimal.js";
import { RFCDate } from "./types/rfcdate.js";
import * as z from "zod";

export class Generation extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    async anchorTypesGet(
        options?: RequestOptions
    ): Promise<operations.AnchorTypesGetTypeFromAnchor> {
        const path$ = this.templateURLComponent("/anything/anchorTypes")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "anchorTypesGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.AnchorTypesGetTypeFromAnchor>()
            .json(200, operations.AnchorTypesGetTypeFromAnchor$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async arrayCircularReferenceGet(
        options?: RequestOptions
    ): Promise<Array<shared.ArrayCircularReferenceObject>> {
        const path$ = this.templateURLComponent("/anything/arrayCircularReference")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "arrayCircularReferenceGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Array<shared.ArrayCircularReferenceObject>>()
            .json(200, z.array(shared.ArrayCircularReferenceObject$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async circularReferenceGet(
        options?: RequestOptions
    ): Promise<shared.ValidCircularReferenceObject> {
        const path$ = this.templateURLComponent("/anything/circularReference")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "circularReferenceGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<shared.ValidCircularReferenceObject>()
            .json(200, shared.ValidCircularReferenceObject$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async dateParamWithDefault(
        dateInput: RFCDate | undefined,
        options?: RequestOptions
    ): Promise<void> {
        const input$: operations.DateParamWithDefaultRequest = {
            dateInput: dateInput,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DateParamWithDefaultRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/dateParamWithDefault")();

        const query$ = encodeFormQuery$({
            dateInput: payload$.dateInput,
        });

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "dateParamWithDefault",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<void>()
            .void(204, z.void())
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async dateTimeParamWithDefault(
        dateTimeInput: Date | undefined,
        options?: RequestOptions
    ): Promise<void> {
        const input$: operations.DateTimeParamWithDefaultRequest = {
            dateTimeInput: dateTimeInput,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DateTimeParamWithDefaultRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/dateTimeParamWithDefault")();

        const query$ = encodeFormQuery$({
            dateTimeInput: payload$.dateTimeInput,
        });

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "dateTimeParamWithDefault",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<void>()
            .void(204, z.void())
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async decimalParamWithDefault(
        decimalInput: Decimal$ | number | undefined,
        options?: RequestOptions
    ): Promise<void> {
        const input$: operations.DecimalParamWithDefaultRequest = {
            decimalInput: decimalInput,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DecimalParamWithDefaultRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/decimalParamWithDefault")();

        const query$ = encodeFormQuery$({
            decimalInput: payload$.decimalInput,
        });

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "decimalParamWithDefault",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<void>()
            .void(204, z.void())
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async deprecatedFieldInSchemaPost(
        request: shared.DeprecatedFieldInObject,
        options?: RequestOptions
    ): Promise<void> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DeprecatedFieldInObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/deprecatedFieldInSchema")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "*/*",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "deprecatedFieldInSchemaPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<void>()
            .void(200, z.void())
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async deprecatedObjectInSchemaGet(
        options?: RequestOptions
    ): Promise<operations.DeprecatedObjectInSchemaGetResponseBody> {
        const path$ = this.templateURLComponent("/anything/deprecatedObjectInSchema")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "deprecatedObjectInSchemaGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.DeprecatedObjectInSchemaGetResponseBody>()
            .json(200, operations.DeprecatedObjectInSchemaGetResponseBody$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async deprecatedOperationNoCommentsGet(
        deprecatedParameter?: string | undefined,
        options?: RequestOptions
    ): Promise<void> {
        const input$: operations.DeprecatedOperationNoCommentsGetRequest = {
            deprecatedParameter: deprecatedParameter,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeprecatedOperationNoCommentsGetRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/deprecatedOperationNoComments")();

        const query$ = encodeFormQuery$({
            deprecatedParameter: payload$.deprecatedParameter,
        });

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "deprecatedOperationNoCommentsGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<void>()
            .void(200, z.void())
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * This is an endpoint setup to test deprecation with comments
     *
     * @deprecated method: This operation is deprecated. Use simplePathParameterObjects instead.
     */
    async deprecatedOperationWithCommentsGet(
        deprecatedParameter?: string | undefined,
        newParameter?: string | undefined,
        options?: RequestOptions
    ): Promise<void> {
        const input$: operations.DeprecatedOperationWithCommentsGetRequest = {
            deprecatedParameter: deprecatedParameter,
            newParameter: newParameter,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.DeprecatedOperationWithCommentsGetRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/deprecatedOperationWithComments")();

        const query$ = encodeFormQuery$({
            deprecatedParameter: payload$.deprecatedParameter,
            newParameter: payload$.newParameter,
        });

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "deprecatedOperationWithCommentsGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<void>()
            .void(200, z.void())
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async emptyObjectGet(
        emptyObject: shared.EmptyObjectParam,
        options?: RequestOptions
    ): Promise<void> {
        const input$: operations.EmptyObjectGetRequest = {
            emptyObject: emptyObject,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.EmptyObjectGetRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            emptyObject: encodeSimple$("emptyObject", payload$.emptyObject, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/anything/{emptyObject}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "emptyObjectGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<void>()
            .void(200, z.void())
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async emptyResponseObjectWithCommentGet(options?: RequestOptions): Promise<Uint8Array> {
        const path$ = this.templateURLComponent("/anything/emptyResponseObjectWithComment")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/octet-stream",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "emptyResponseObjectWithCommentGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Uint8Array>()
            .bytes(200, b64$.zodInbound)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async globalNameOverridden(
        request?: shared.SimpleObject | undefined,
        options?: RequestOptions
    ): Promise<operations.GetGlobalNameOverrideResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$outboundSchema.optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/globalNameOverride")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            any: encodeSimple$("any", payload$?.any, { explode: false, charEncoding: "none" }),
            bigint: encodeSimple$("bigint", payload$?.bigint, {
                explode: false,
                charEncoding: "none",
            }),
            bigintStr: encodeSimple$("bigintStr", payload$?.bigintStr, {
                explode: false,
                charEncoding: "none",
            }),
            bool: encodeSimple$("bool", payload$?.bool, { explode: false, charEncoding: "none" }),
            boolOpt: encodeSimple$("boolOpt", payload$?.boolOpt, {
                explode: false,
                charEncoding: "none",
            }),
            date: encodeSimple$("date", payload$?.date, { explode: false, charEncoding: "none" }),
            dateTime: encodeSimple$("dateTime", payload$?.dateTime, {
                explode: false,
                charEncoding: "none",
            }),
            decimal: encodeSimple$("decimal", payload$?.decimal, {
                explode: false,
                charEncoding: "none",
            }),
            decimalStr: encodeSimple$("decimalStr", payload$?.decimalStr, {
                explode: false,
                charEncoding: "none",
            }),
            enum: encodeSimple$("enum", payload$?.enum, { explode: false, charEncoding: "none" }),
            float32: encodeSimple$("float32", payload$?.float32, {
                explode: false,
                charEncoding: "none",
            }),
            float64Str: encodeSimple$("float64Str", payload$?.float64Str, {
                explode: false,
                charEncoding: "none",
            }),
            int: encodeSimple$("int", payload$?.int, { explode: false, charEncoding: "none" }),
            int32: encodeSimple$("int32", payload$?.int32, {
                explode: false,
                charEncoding: "none",
            }),
            int32Enum: encodeSimple$("int32Enum", payload$?.int32Enum, {
                explode: false,
                charEncoding: "none",
            }),
            int64Str: encodeSimple$("int64Str", payload$?.int64Str, {
                explode: false,
                charEncoding: "none",
            }),
            intEnum: encodeSimple$("intEnum", payload$?.intEnum, {
                explode: false,
                charEncoding: "none",
            }),
            intOptNull: encodeSimple$("intOptNull", payload$?.intOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            num: encodeSimple$("num", payload$?.num, { explode: false, charEncoding: "none" }),
            numOptNull: encodeSimple$("numOptNull", payload$?.numOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            str: encodeSimple$("str", payload$?.str, { explode: false, charEncoding: "none" }),
            strOpt: encodeSimple$("strOpt", payload$?.strOpt, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "getGlobalNameOverride",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.GetGlobalNameOverrideResponseBody>()
            .json(200, operations.GetGlobalNameOverrideResponseBody$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async ignoredGenerationGet(
        options?: RequestOptions
    ): Promise<operations.IgnoredGenerationGetResponseBody> {
        const path$ = this.templateURLComponent("/anything/ignoredGeneration")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ignoredGenerationGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.IgnoredGenerationGetResponseBody>()
            .json(200, operations.IgnoredGenerationGetResponseBody$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async ignoresPost(
        requestBody: operations.IgnoresPostRequestBody,
        testParam?: string | undefined,
        options?: RequestOptions
    ): Promise<shared.HttpBinSimpleJsonObject> {
        const input$: operations.IgnoresPostRequest = {
            requestBody: requestBody,
            testParam: testParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.IgnoresPostRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const path$ = this.templateURLComponent("/anything/ignores")();

        const query$ = encodeFormQuery$({
            testParam: payload$.testParam,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "ignoresPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<shared.HttpBinSimpleJsonObject>()
            .json(200, shared.HttpBinSimpleJsonObject$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async nameOverride(
        testEnumQueryParam: operations.EnumNameOverride,
        testQueryParam: string,
        options?: RequestOptions
    ): Promise<operations.NameOverrideGetOverriddenResponse> {
        const input$: operations.NameOverrideGetRequest = {
            testEnumQueryParam: testEnumQueryParam,
            testQueryParam: testQueryParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.NameOverrideGetRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/nameOverride")();

        const query$ = encodeFormQuery$({
            enumNameOverride: payload$.testEnumQueryParam,
            nameOverride: payload$.testQueryParam,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "nameOverrideGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.NameOverrideGetOverriddenResponse>()
            .json(200, operations.NameOverrideGetOverriddenResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async objectCircularReferenceGet(
        options?: RequestOptions
    ): Promise<shared.ObjectCircularReferenceObject> {
        const path$ = this.templateURLComponent("/anything/objectCircularReference")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "objectCircularReferenceGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<shared.ObjectCircularReferenceObject>()
            .json(200, shared.ObjectCircularReferenceObject$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async oneOfCircularReferenceGet(
        options?: RequestOptions
    ): Promise<shared.OneOfCircularReferenceObject> {
        const path$ = this.templateURLComponent("/anything/oneOfCircularReference")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "oneOfCircularReferenceGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<shared.OneOfCircularReferenceObject>()
            .json(200, shared.OneOfCircularReferenceObject$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async typedParameterGenerationGet(
        bigint?: bigint | undefined,
        date?: RFCDate | undefined,
        decimal?: Decimal$ | number | undefined,
        obj?: operations.Obj | undefined,
        options?: RequestOptions
    ): Promise<void> {
        const input$: operations.TypedParameterGenerationGetRequest = {
            bigint: bigint,
            date: date,
            decimal: decimal,
            obj: obj,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.TypedParameterGenerationGetRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/typedParameterGeneration")();

        const query$ = encodeFormQuery$({
            bigint: payload$.bigint,
            date: payload$.date,
            decimal: payload$.decimal,
            obj: payload$.obj,
        });

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "typedParameterGenerationGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<void>()
            .void(200, z.void())
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    /**
     * An operation used for testing usage examples
     *
     * @remarks
     * An operation used for testing usage examples that includes a large array of parameters and input types to ensure that all are handled correctly
     *
     * @see {@link https://docs.example.com} - Usage example docs
     */
    async usageExamplePost(
        request: operations.UsageExamplePostRequest,
        security: operations.UsageExamplePostSecurity,
        options?: RequestOptions
    ): Promise<operations.UsageExamplePostResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.UsageExamplePostRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const path$ = this.templateURLComponent("/anything/usageExample")();

        const query$ = encodeFormQuery$({
            bigintParameter: payload$.bigintParameter,
            bigintParameterOptional: payload$.bigintParameterOptional,
            bigintStrParameter: payload$.bigintStrParameter,
            bigintStrParameterOptional: payload$.bigintStrParameterOptional,
            boolParameter: payload$.boolParameter,
            dateParameter: payload$.dateParameter,
            dateTimeDefaultParameter: payload$.dateTimeDefaultParameter,
            dateTimeParameter: payload$.dateTimeParameter,
            decimalParameter: payload$.decimalParameter,
            decimalParameterOptional: payload$.decimalParameterOptional,
            decimalStrParameter: payload$.decimalStrParameter,
            decimalStrParameterOptional: payload$.decimalStrParameterOptional,
            doubleParameter: payload$.doubleParameter,
            enumParameter: payload$.enumParameter,
            falseyNumberParameter: payload$.falseyNumberParameter,
            float32Parameter: payload$.float32Parameter,
            float64StringParameter: payload$.float64StringParameter,
            floatParameter: payload$.floatParameter,
            int64Parameter: payload$.int64Parameter,
            int64StringParameter: payload$.int64StringParameter,
            intParameter: payload$.intParameter,
            optEnumParameter: payload$.optEnumParameter,
            strParameter: payload$.strParameter,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$: SecurityInput[][] = [
            [
                {
                    type: "http:basic",
                    value: { password: security?.password, username: security?.username },
                },
            ],
        ];
        const securitySettings$ = this.resolveSecurity(...security$);
        const context = {
            operationID: "usageExamplePost",
            oAuth2Scopes: [],
            securitySource: security$,
        };

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.UsageExamplePostResponseBody>()
            .json(200, operations.UsageExamplePostResponseBody$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }
}
