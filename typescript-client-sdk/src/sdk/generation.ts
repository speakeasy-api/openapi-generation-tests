/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as errors from "../sdk/models/errors";
import * as operations from "../sdk/models/operations";
import * as shared from "../sdk/models/shared";
import { Decimal as Decimal$, RFCDate } from "../sdk/types";

export class Generation extends ClientSDK {
    private readonly options$: SDKOptions;

    constructor(options: SDKOptions = {}) {
        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
        });

        this.options$ = options;
        void this.options$;
    }

    async anchorTypesGet(options?: RequestOptions): Promise<operations.AnchorTypesGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/anchorTypes")();

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.AnchorTypesGetResponse$.inboundSchema.parse({
                ...responseFields$,
                TypeFromAnchor: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async arrayCircularReferenceGet(
        options?: RequestOptions
    ): Promise<operations.ArrayCircularReferenceGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/arrayCircularReference")();

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.ArrayCircularReferenceGetResponse$.inboundSchema.parse({
                ...responseFields$,
                arrayCircularReferenceObject: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async circularReferenceGet(
        options?: RequestOptions
    ): Promise<operations.CircularReferenceGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/circularReference")();

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.CircularReferenceGetResponse$.inboundSchema.parse({
                ...responseFields$,
                validCircularReferenceObject: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async dateParamWithDefault(
        dateInput: RFCDate | undefined,
        options?: RequestOptions
    ): Promise<operations.DateParamWithDefaultResponse> {
        const input$: operations.DateParamWithDefaultRequest = {
            dateInput: dateInput,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.DateParamWithDefaultRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/dateParamWithDefault")();

        const query$ = [
            enc$.encodeForm("dateInput", payload$.dateInput, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DateParamWithDefaultResponse$.inboundSchema.parse(responseFields$);
    }

    async dateTimeParamWithDefault(
        dateTimeInput: Date | undefined,
        options?: RequestOptions
    ): Promise<operations.DateTimeParamWithDefaultResponse> {
        const input$: operations.DateTimeParamWithDefaultRequest = {
            dateTimeInput: dateTimeInput,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.DateTimeParamWithDefaultRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/dateTimeParamWithDefault")();

        const query$ = [
            enc$.encodeForm("dateTimeInput", payload$.dateTimeInput, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DateTimeParamWithDefaultResponse$.inboundSchema.parse(responseFields$);
    }

    async decimalParamWithDefault(
        decimalInput: Decimal$ | number | undefined,
        options?: RequestOptions
    ): Promise<operations.DecimalParamWithDefaultResponse> {
        const input$: operations.DecimalParamWithDefaultRequest = {
            decimalInput: decimalInput,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.DecimalParamWithDefaultRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/decimalParamWithDefault")();

        const query$ = [
            enc$.encodeForm("decimalInput", payload$.decimalInput, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 204)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DecimalParamWithDefaultResponse$.inboundSchema.parse(responseFields$);
    }

    async deprecatedFieldInSchemaPost(
        input: shared.DeprecatedFieldInObject,
        options?: RequestOptions
    ): Promise<operations.DeprecatedFieldInSchemaPostResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "*/*");

        const payload$ = shared.DeprecatedFieldInObject$.outboundSchema.parse(input);
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/deprecatedFieldInSchema")();

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DeprecatedFieldInSchemaPostResponse$.inboundSchema.parse(responseFields$);
    }

    async deprecatedObjectInSchemaGet(
        options?: RequestOptions
    ): Promise<operations.DeprecatedObjectInSchemaGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/deprecatedObjectInSchema")();

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.DeprecatedObjectInSchemaGetResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    /**
     * @deprecated method: This will be removed in a future release, please migrate away from it as soon as possible.
     */
    async deprecatedOperationNoCommentsGet(
        deprecatedParameter?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.DeprecatedOperationNoCommentsGetResponse> {
        const input$: operations.DeprecatedOperationNoCommentsGetRequest = {
            deprecatedParameter: deprecatedParameter,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ =
            operations.DeprecatedOperationNoCommentsGetRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/deprecatedOperationNoComments")();

        const query$ = [
            enc$.encodeForm("deprecatedParameter", payload$.deprecatedParameter, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DeprecatedOperationNoCommentsGetResponse$.inboundSchema.parse(
            responseFields$
        );
    }

    /**
     * This is an endpoint setup to test deprecation with comments
     *
     * @deprecated method: This operation is deprecated. Use simplePathParameterObjects instead.
     */
    async deprecatedOperationWithCommentsGet(
        deprecatedParameter?: string | undefined,
        newParameter?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.DeprecatedOperationWithCommentsGetResponse> {
        const input$: operations.DeprecatedOperationWithCommentsGetRequest = {
            deprecatedParameter: deprecatedParameter,
            newParameter: newParameter,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ =
            operations.DeprecatedOperationWithCommentsGetRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/deprecatedOperationWithComments")();

        const query$ = [
            enc$.encodeForm("deprecatedParameter", payload$.deprecatedParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("newParameter", payload$.newParameter, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.DeprecatedOperationWithCommentsGetResponse$.inboundSchema.parse(
            responseFields$
        );
    }

    async emptyObjectGet(
        emptyObject: shared.EmptyObjectParam,
        options?: RequestOptions
    ): Promise<operations.EmptyObjectGetResponse> {
        const input$: operations.EmptyObjectGetRequest = {
            emptyObject: emptyObject,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = operations.EmptyObjectGetRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const pathParams$ = {
            emptyObject: enc$.encodeSimple("emptyObject", payload$.emptyObject, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = this.templateURLComponent("/anything/{emptyObject}")(pathParams$);

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.EmptyObjectGetResponse$.inboundSchema.parse(responseFields$);
    }

    async emptyResponseObjectWithCommentGet(
        options?: RequestOptions
    ): Promise<operations.EmptyResponseObjectWithCommentGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/octet-stream");

        const path$ = this.templateURLComponent("/anything/emptyResponseObjectWithComment")();

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/octet-stream")) {
            const responseBody = await response.arrayBuffer();
            const result =
                operations.EmptyResponseObjectWithCommentGetResponse$.inboundSchema.parse({
                    ...responseFields$,
                    Body: new Uint8Array(responseBody),
                });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async globalNameOverridden(
        input: shared.SimpleObject | undefined,
        options?: RequestOptions
    ): Promise<operations.GetGlobalNameOverrideResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = shared.SimpleObject$.outboundSchema.optional().parse(input);
        const body$ =
            payload$ === undefined ? null : enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/globalNameOverride")();

        headers$.set(
            "any",
            enc$.encodeSimple("any", payload$?.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            enc$.encodeSimple("bigint", payload$?.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            enc$.encodeSimple("bigintStr", payload$?.bigintStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "bool",
            enc$.encodeSimple("bool", payload$?.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            enc$.encodeSimple("boolOpt", payload$?.boolOpt, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "date",
            enc$.encodeSimple("date", payload$?.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            enc$.encodeSimple("dateTime", payload$?.dateTime, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "decimal",
            enc$.encodeSimple("decimal", payload$?.decimal, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "decimalStr",
            enc$.encodeSimple("decimalStr", payload$?.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            enc$.encodeSimple("enum", payload$?.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            enc$.encodeSimple("float32", payload$?.float32, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "int",
            enc$.encodeSimple("int", payload$?.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            enc$.encodeSimple("int32", payload$?.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            enc$.encodeSimple("int32Enum", payload$?.int32Enum, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "intEnum",
            enc$.encodeSimple("intEnum", payload$?.intEnum, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "intOptNull",
            enc$.encodeSimple("intOptNull", payload$?.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            enc$.encodeSimple("num", payload$?.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            enc$.encodeSimple("numOptNull", payload$?.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            enc$.encodeSimple("str", payload$?.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            enc$.encodeSimple("strOpt", payload$?.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.GetGlobalNameOverrideResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async ignoredGenerationGet(
        options?: RequestOptions
    ): Promise<operations.IgnoredGenerationGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/ignoredGeneration")();

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.IgnoredGenerationGetResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async ignoresPost(
        requestBody: operations.IgnoresPostRequestBody,
        testParam?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.IgnoresPostResponse> {
        const input$: operations.IgnoresPostRequest = {
            requestBody: requestBody,
            testParam: testParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.IgnoresPostRequest$.outboundSchema.parse(input$);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const path$ = this.templateURLComponent("/anything/ignores")();

        const query$ = [
            enc$.encodeForm("testParam", payload$.testParam, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.IgnoresPostResponse$.inboundSchema.parse({
                ...responseFields$,
                httpBinSimpleJsonObject: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async nameOverride(
        testEnumQueryParam: operations.EnumNameOverride,
        testQueryParam: string,
        options?: RequestOptions
    ): Promise<operations.NameOverrideGetResponse> {
        const input$: operations.NameOverrideGetRequest = {
            testEnumQueryParam: testEnumQueryParam,
            testQueryParam: testQueryParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = operations.NameOverrideGetRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/nameOverride")();

        const query$ = [
            enc$.encodeForm("enumNameOverride", payload$.testEnumQueryParam, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("nameOverride", payload$.testQueryParam, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.NameOverrideGetResponse$.inboundSchema.parse({
                ...responseFields$,
                overriddenResponse: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async objectCircularReferenceGet(
        options?: RequestOptions
    ): Promise<operations.ObjectCircularReferenceGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/objectCircularReference")();

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.ObjectCircularReferenceGetResponse$.inboundSchema.parse({
                ...responseFields$,
                objectCircularReferenceObject: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async oneOfCircularReferenceGet(
        options?: RequestOptions
    ): Promise<operations.OneOfCircularReferenceGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/oneOfCircularReference")();

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            { security: securitySettings$, method: "GET", path: path$, headers: headers$ },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.OneOfCircularReferenceGetResponse$.inboundSchema.parse({
                ...responseFields$,
                oneOfCircularReferenceObject: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async typedParameterGenerationGet(
        bigint?: bigint | undefined,
        date?: RFCDate | undefined,
        decimal?: Decimal$ | number | undefined,
        obj?: operations.Obj | undefined,
        options?: RequestOptions
    ): Promise<operations.TypedParameterGenerationGetResponse> {
        const input$: operations.TypedParameterGenerationGetRequest = {
            bigint: bigint,
            date: date,
            decimal: decimal,
            obj: obj,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ =
            operations.TypedParameterGenerationGetRequest$.outboundSchema.parse(input$);
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/typedParameterGeneration")();

        const query$ = [
            enc$.encodeForm("bigint", payload$.bigint, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("date", payload$.date, { explode: true, charEncoding: "percent" }),
            enc$.encodeForm("decimal", payload$.decimal, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("obj", payload$.obj, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchStatusCode(response, 200)) {
            // fallthrough
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }

        return operations.TypedParameterGenerationGetResponse$.inboundSchema.parse(responseFields$);
    }

    /**
     * An operation used for testing usage examples
     *
     * @remarks
     * An operation used for testing usage examples that includes a large array of parameters and input types to ensure that all are handled correctly
     *
     * @see {@link https://docs.example.com} - Usage example docs
     */
    async usageExamplePost(
        input: operations.UsageExamplePostRequest,
        security: operations.UsageExamplePostSecurity,
        options?: RequestOptions
    ): Promise<operations.UsageExamplePostResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = operations.UsageExamplePostRequest$.outboundSchema.parse(input);

        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const path$ = this.templateURLComponent("/anything/usageExample")();

        const query$ = [
            enc$.encodeForm("bigintParameter", payload$.bigintParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("bigintParameterOptional", payload$.bigintParameterOptional, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("bigintStrParameter", payload$.bigintStrParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("bigintStrParameterOptional", payload$.bigintStrParameterOptional, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("boolParameter", payload$.boolParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("dateParameter", payload$.dateParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("dateTimeDefaultParameter", payload$.dateTimeDefaultParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("dateTimeParameter", payload$.dateTimeParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("decimalParameter", payload$.decimalParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("decimalParameterOptional", payload$.decimalParameterOptional, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("decimalStrParameter", payload$.decimalStrParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("decimalStrParameterOptional", payload$.decimalStrParameterOptional, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("doubleParameter", payload$.doubleParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("enumParameter", payload$.enumParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("falseyNumberParameter", payload$.falseyNumberParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("float32Parameter", payload$.float32Parameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("floatParameter", payload$.floatParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("int64Parameter", payload$.int64Parameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("intParameter", payload$.intParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("optEnumParameter", payload$.optEnumParameter, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("strParameter", payload$.strParameter, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const securitySettings$ = this.resolveSecurity([
            { value: security?.password, fieldName: "password", type: "http:basic" },
            { value: security?.username, fieldName: "username", type: "http:basic" },
        ]);

        const response = await this.fetch$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = operations.UsageExamplePostResponse$.inboundSchema.parse({
                ...responseFields$,
                object: responseBody,
            });
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }
}
