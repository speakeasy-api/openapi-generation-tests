/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { paginationPaginationAmbiguousInput } from "../funcs/paginationPaginationAmbiguousInput.js";
import { paginationPaginationBodyFlattenedOptionalSecurity } from "../funcs/paginationPaginationBodyFlattenedOptionalSecurity.js";
import { paginationPaginationBodyFlattenedWithSecurity } from "../funcs/paginationPaginationBodyFlattenedWithSecurity.js";
import { paginationPaginationBodyWrappedRequest } from "../funcs/paginationPaginationBodyWrappedRequest.js";
import { paginationPaginationCursorBody } from "../funcs/paginationPaginationCursorBody.js";
import { paginationPaginationCursorNonNumeric } from "../funcs/paginationPaginationCursorNonNumeric.js";
import { paginationPaginationCursorParams } from "../funcs/paginationPaginationCursorParams.js";
import { paginationPaginationLimitOffsetDeepOutputsPageBody } from "../funcs/paginationPaginationLimitOffsetDeepOutputsPageBody.js";
import { paginationPaginationLimitOffsetOffsetBody } from "../funcs/paginationPaginationLimitOffsetOffsetBody.js";
import { paginationPaginationLimitOffsetOffsetParams } from "../funcs/paginationPaginationLimitOffsetOffsetParams.js";
import { paginationPaginationLimitOffsetPageBody } from "../funcs/paginationPaginationLimitOffsetPageBody.js";
import { paginationPaginationLimitOffsetPageParams } from "../funcs/paginationPaginationLimitOffsetPageParams.js";
import { paginationPaginationURLParams } from "../funcs/paginationPaginationURLParams.js";
import { paginationPaginationWithRetries } from "../funcs/paginationPaginationWithRetries.js";
import { paginationPaginationWrappedOptionalBody } from "../funcs/paginationPaginationWrappedOptionalBody.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { PageIterator, unwrapResultIterator } from "../sdk/types/operations.js";
import * as operations from "./models/operations/index.js";
import * as shared from "./models/shared/index.js";

export class Pagination extends ClientSDK {
  /**
   * This is a paginated operation where there is both a query parameter and
   * request body field called "cursor". This ambiguity is used to test that
   * the generator only updates the appropriate field in the pagination code
   * "next()" function.
   */
  async paginationAmbiguousInput(
    requestBody: operations.PaginationAmbiguousInputRequestBody,
    cursor?: number | undefined,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<
      operations.PaginationAmbiguousInputResponse,
      { cursor: number }
    >
  > {
    return unwrapResultIterator(paginationPaginationAmbiguousInput(
      this,
      requestBody,
      cursor,
      options,
    ));
  }

  async paginationBodyFlattenedOptionalSecurity(
    limit: number,
    offset: number,
    security?:
      | operations.PaginationBodyFlattenedOptionalSecuritySecurity
      | undefined,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<
      operations.PaginationBodyFlattenedOptionalSecurityResponse,
      { offset: number }
    >
  > {
    return unwrapResultIterator(
      paginationPaginationBodyFlattenedOptionalSecurity(
        this,
        limit,
        offset,
        security,
        options,
      ),
    );
  }

  async paginationBodyFlattenedWithSecurity(
    security: operations.PaginationBodyFlattenedWithSecuritySecurity,
    limit: number,
    offset: number,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<
      operations.PaginationBodyFlattenedWithSecurityResponse,
      { offset: number }
    >
  > {
    return unwrapResultIterator(paginationPaginationBodyFlattenedWithSecurity(
      this,
      security,
      limit,
      offset,
      options,
    ));
  }

  /**
   * This operation has a request wrapper type that encapsulates the
   * parameters and request body. The pagination inputs are meant to go in
   * the request body and we want to test that the generator correctly
   * generates the next() function call preserving everything from the
   * original request and interpolating the next pagination inputs.
   */
  async paginationBodyWrappedRequest(
    request: operations.PaginationBodyWrappedRequestRequest,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<
      operations.PaginationBodyWrappedRequestResponse,
      { page: number }
    >
  > {
    return unwrapResultIterator(paginationPaginationBodyWrappedRequest(
      this,
      request,
      options,
    ));
  }

  async paginationCursorBody(
    request: operations.PaginationCursorBodyRequestBody,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<operations.PaginationCursorBodyResponse, { cursor: number }>
  > {
    return unwrapResultIterator(paginationPaginationCursorBody(
      this,
      request,
      options,
    ));
  }

  async paginationCursorNonNumeric(
    cursor?: string | undefined,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<
      operations.PaginationCursorNonNumericResponse,
      { cursor: string }
    >
  > {
    return unwrapResultIterator(paginationPaginationCursorNonNumeric(
      this,
      cursor,
      options,
    ));
  }

  async paginationCursorParams(
    cursor: number,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<operations.PaginationCursorParamsResponse, { cursor: number }>
  > {
    return unwrapResultIterator(paginationPaginationCursorParams(
      this,
      cursor,
      options,
    ));
  }

  async paginationLimitOffsetDeepOutputsPageBody(
    request: shared.LimitOffsetConfig,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<
      operations.PaginationLimitOffsetDeepOutputsPageBodyResponse,
      { page: number }
    >
  > {
    return unwrapResultIterator(
      paginationPaginationLimitOffsetDeepOutputsPageBody(
        this,
        request,
        options,
      ),
    );
  }

  async paginationLimitOffsetOffsetBody(
    request: shared.LimitOffsetConfig,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<
      operations.PaginationLimitOffsetOffsetBodyResponse,
      { offset: number }
    >
  > {
    return unwrapResultIterator(paginationPaginationLimitOffsetOffsetBody(
      this,
      request,
      options,
    ));
  }

  async paginationLimitOffsetOffsetParams(
    limit?: number | undefined,
    offset?: number | undefined,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<
      operations.PaginationLimitOffsetOffsetParamsResponse,
      { offset: number }
    >
  > {
    return unwrapResultIterator(paginationPaginationLimitOffsetOffsetParams(
      this,
      limit,
      offset,
      options,
    ));
  }

  async paginationLimitOffsetPageBody(
    request: shared.LimitOffsetConfig,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<
      operations.PaginationLimitOffsetPageBodyResponse,
      { page: number }
    >
  > {
    return unwrapResultIterator(paginationPaginationLimitOffsetPageBody(
      this,
      request,
      options,
    ));
  }

  async paginationLimitOffsetPageParams(
    page: number,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<
      operations.PaginationLimitOffsetPageParamsResponse,
      { page: number }
    >
  > {
    return unwrapResultIterator(paginationPaginationLimitOffsetPageParams(
      this,
      page,
      options,
    ));
  }

  async paginationURLParams(
    attempts: number,
    isReferencePath?: string | undefined,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<operations.PaginationURLParamsResponse, { url: string }>
  > {
    return unwrapResultIterator(paginationPaginationURLParams(
      this,
      attempts,
      isReferencePath,
      options,
    ));
  }

  async paginationWithRetries(
    cursor?: string | undefined,
    faultSettings?: string | undefined,
    requestId?: string | undefined,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<operations.PaginationWithRetriesResponse, { cursor: string }>
  > {
    return unwrapResultIterator(paginationPaginationWithRetries(
      this,
      cursor,
      faultSettings,
      requestId,
      options,
    ));
  }

  async paginationWrappedOptionalBody(
    request: operations.PaginationWrappedOptionalBodyRequest,
    security?: operations.PaginationWrappedOptionalBodySecurity | undefined,
    options?: RequestOptions & { serverURL?: string },
  ): Promise<
    PageIterator<
      operations.PaginationWrappedOptionalBodyResponse,
      { offset: number }
    >
  > {
    return unwrapResultIterator(paginationPaginationWrappedOptionalBody(
      this,
      request,
      security,
      options,
    ));
  }
}
