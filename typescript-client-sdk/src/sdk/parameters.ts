/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeDeepObjectQuery as encodeDeepObjectQuery$,
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeJSONQuery as encodeJSONQuery$,
    encodePipeDelimitedQuery as encodePipeDelimitedQuery$,
    encodeSimple as encodeSimple$,
    queryJoin as queryJoin$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "./models/operations/index.js";
import * as shared from "./models/shared/index.js";

export class ParametersT extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    async deepObjectQueryParamsMap(
        mapParam: { [k: string]: string },
        mapArrParam?: { [k: string]: Array<string> } | undefined,
        options?: RequestOptions
    ): Promise<operations.DeepObjectQueryParamsMapRes> {
        const input$: operations.DeepObjectQueryParamsMapRequest = {
            mapArrParam: mapArrParam,
            mapParam: mapParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DeepObjectQueryParamsMapRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/deepObject/map")();

        const query$ = encodeDeepObjectQuery$({
            mapArrParam: payload$.mapArrParam,
            mapParam: payload$.mapParam,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "deepObjectQueryParamsMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.DeepObjectQueryParamsMapRes>()
            .json(200, operations.DeepObjectQueryParamsMapRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async deepObjectQueryParamsObject(
        objParam: shared.SimpleObject,
        objArrParam?: operations.ObjArrParam | undefined,
        options?: RequestOptions
    ): Promise<operations.DeepObjectQueryParamsObjectRes> {
        const input$: operations.DeepObjectQueryParamsObjectRequest = {
            objArrParam: objArrParam,
            objParam: objParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DeepObjectQueryParamsObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/deepObject/obj")();

        const query$ = encodeDeepObjectQuery$({
            objArrParam: payload$.objArrParam,
            objParam: payload$.objParam,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "deepObjectQueryParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.DeepObjectQueryParamsObjectRes>()
            .json(200, operations.DeepObjectQueryParamsObjectRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async duplicateParam(
        duplicateParamRequest: string,
        options?: RequestOptions
    ): Promise<operations.DuplicateParamDuplicateParamResponse> {
        const input$: operations.DuplicateParamRequest = {
            duplicateParamRequest: duplicateParamRequest,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DuplicateParamRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            duplicateParamRequest: encodeSimple$(
                "duplicateParamRequest",
                payload$.duplicateParamRequest,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent("/anything/params/{duplicateParamRequest}")(
            pathParams$
        );

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "duplicateParam",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.DuplicateParamDuplicateParamResponse>()
            .json(200, operations.DuplicateParamDuplicateParamResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async formQueryParamsArray(
        arrParam?: Array<string> | undefined,
        arrParamExploded?: Array<number> | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsArrayRes> {
        const input$: operations.FormQueryParamsArrayRequest = {
            arrParam: arrParam,
            arrParamExploded: arrParamExploded,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.FormQueryParamsArrayRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/array")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    arrParam: payload$.arrParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                arrParamExploded: payload$.arrParamExploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.FormQueryParamsArrayRes>()
            .json(200, operations.FormQueryParamsArrayRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async formQueryParamsCamelObject(
        objParamExploded: operations.ObjParamExploded,
        objParam?: operations.ObjParam | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsCamelObjectRes> {
        const input$: operations.FormQueryParamsCamelObjectRequest = {
            objParam: objParam,
            objParamExploded: objParamExploded,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.FormQueryParamsCamelObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/camelObj")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    obj_param: payload$.obj_param,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                obj_param_exploded: payload$.obj_param_exploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsCamelObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.FormQueryParamsCamelObjectRes>()
            .json(200, operations.FormQueryParamsCamelObjectRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async formQueryParamsMap(
        mapParam?: { [k: string]: string } | undefined,
        mapParamExploded?: { [k: string]: number } | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsMapRes> {
        const input$: operations.FormQueryParamsMapRequest = {
            mapParam: mapParam,
            mapParamExploded: mapParamExploded,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.FormQueryParamsMapRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/map")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    mapParam: payload$.mapParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                mapParamExploded: payload$.mapParamExploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.FormQueryParamsMapRes>()
            .json(200, operations.FormQueryParamsMapRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async formQueryParamsObject(
        objParamExploded: shared.SimpleObject,
        objParam?: shared.SimpleObject | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsObjectRes> {
        const input$: operations.FormQueryParamsObjectRequest = {
            objParam: objParam,
            objParamExploded: objParamExploded,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.FormQueryParamsObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/obj")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    objParam: payload$.objParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                objParamExploded: payload$.objParamExploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.FormQueryParamsObjectRes>()
            .json(200, operations.FormQueryParamsObjectRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async formQueryParamsPrimitive(
        boolParam: boolean,
        intParam: number,
        numParam: number,
        strParam: string,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsPrimitiveRes> {
        const input$: operations.FormQueryParamsPrimitiveRequest = {
            boolParam: boolParam,
            intParam: intParam,
            numParam: numParam,
            strParam: strParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.FormQueryParamsPrimitiveRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/primitive")();

        const query$ = encodeFormQuery$({
            boolParam: payload$.boolParam,
            intParam: payload$.intParam,
            numParam: payload$.numParam,
            strParam: payload$.strParam,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.FormQueryParamsPrimitiveRes>()
            .json(200, operations.FormQueryParamsPrimitiveRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async formQueryParamsRefParamObject(
        refObjParam?: shared.RefQueryParamObj | undefined,
        refObjParamExploded?: shared.RefQueryParamObjExploded | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsRefParamObjectRes> {
        const input$: operations.FormQueryParamsRefParamObjectRequest = {
            refObjParam: refObjParam,
            refObjParamExploded: refObjParamExploded,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.FormQueryParamsRefParamObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/refParamObject")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    refObjParam: payload$.refObjParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                refObjParamExploded: payload$.refObjParamExploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsRefParamObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.FormQueryParamsRefParamObjectRes>()
            .json(200, operations.FormQueryParamsRefParamObjectRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async headerParamsArray(
        xHeaderArray: Array<string>,
        options?: RequestOptions
    ): Promise<operations.HeaderParamsArrayRes> {
        const input$: operations.HeaderParamsArrayRequest = {
            xHeaderArray: xHeaderArray,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.HeaderParamsArrayRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/headers/array")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
            "X-Header-Array": encodeSimple$("X-Header-Array", payload$["X-Header-Array"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "headerParamsArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.HeaderParamsArrayRes>()
            .json(200, operations.HeaderParamsArrayRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async headerParamsMap(
        xHeaderMap: { [k: string]: string },
        xHeaderMapExplode: { [k: string]: string },
        options?: RequestOptions
    ): Promise<operations.HeaderParamsMapRes> {
        const input$: operations.HeaderParamsMapRequest = {
            xHeaderMap: xHeaderMap,
            xHeaderMapExplode: xHeaderMapExplode,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.HeaderParamsMapRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/headers/map")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
            "X-Header-Map": encodeSimple$("X-Header-Map", payload$["X-Header-Map"], {
                explode: false,
                charEncoding: "none",
            }),
            "X-Header-Map-Explode": encodeSimple$(
                "X-Header-Map-Explode",
                payload$["X-Header-Map-Explode"],
                { explode: true, charEncoding: "none" }
            ),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "headerParamsMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.HeaderParamsMapRes>()
            .json(200, operations.HeaderParamsMapRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async headerParamsObject(
        xHeaderObj: shared.SimpleObject,
        xHeaderObjExplode: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.HeaderParamsObjectRes> {
        const input$: operations.HeaderParamsObjectRequest = {
            xHeaderObj: xHeaderObj,
            xHeaderObjExplode: xHeaderObjExplode,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.HeaderParamsObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/headers/obj")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
            "X-Header-Obj": encodeSimple$("X-Header-Obj", payload$["X-Header-Obj"], {
                explode: false,
                charEncoding: "none",
            }),
            "X-Header-Obj-Explode": encodeSimple$(
                "X-Header-Obj-Explode",
                payload$["X-Header-Obj-Explode"],
                { explode: true, charEncoding: "none" }
            ),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "headerParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.HeaderParamsObjectRes>()
            .json(200, operations.HeaderParamsObjectRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async headerParamsPrimitive(
        xHeaderBoolean: boolean,
        xHeaderInteger: number,
        xHeaderNumber: number,
        xHeaderString: string,
        options?: RequestOptions
    ): Promise<operations.HeaderParamsPrimitiveRes> {
        const input$: operations.HeaderParamsPrimitiveRequest = {
            xHeaderBoolean: xHeaderBoolean,
            xHeaderInteger: xHeaderInteger,
            xHeaderNumber: xHeaderNumber,
            xHeaderString: xHeaderString,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.HeaderParamsPrimitiveRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/headers/primitive")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
            "X-Header-Boolean": encodeSimple$("X-Header-Boolean", payload$["X-Header-Boolean"], {
                explode: false,
                charEncoding: "none",
            }),
            "X-Header-Integer": encodeSimple$("X-Header-Integer", payload$["X-Header-Integer"], {
                explode: false,
                charEncoding: "none",
            }),
            "X-Header-Number": encodeSimple$("X-Header-Number", payload$["X-Header-Number"], {
                explode: false,
                charEncoding: "none",
            }),
            "X-Header-String": encodeSimple$("X-Header-String", payload$["X-Header-String"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "headerParamsPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.HeaderParamsPrimitiveRes>()
            .json(200, operations.HeaderParamsPrimitiveRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async jsonQueryParamsObject(
        deepObjParam: shared.DeepObject,
        simpleObjParam: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.JsonQueryParamsObjectRes> {
        const input$: operations.JsonQueryParamsObjectRequest = {
            deepObjParam: deepObjParam,
            simpleObjParam: simpleObjParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.JsonQueryParamsObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/json/obj")();

        const query$ = encodeJSONQuery$(
            {
                deepObjParam: payload$.deepObjParam,
                simpleObjParam: payload$.simpleObjParam,
            },
            { explode: false }
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "jsonQueryParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.JsonQueryParamsObjectRes>()
            .json(200, operations.JsonQueryParamsObjectRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async jsonQueryParamsObjectSmaller(
        deepObjParam: shared.DeepObjectSmaller,
        simpleObjParam: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.JsonQueryParamsObjectSmallerRes> {
        const input$: operations.JsonQueryParamsObjectSmallerRequest = {
            deepObjParam: deepObjParam,
            simpleObjParam: simpleObjParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.JsonQueryParamsObjectSmallerRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/json/objsmaller")();

        const query$ = encodeJSONQuery$(
            {
                deepObjParam: payload$.deepObjParam,
                simpleObjParam: payload$.simpleObjParam,
            },
            { explode: false }
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "jsonQueryParamsObjectSmaller",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.JsonQueryParamsObjectSmallerRes>()
            .json(200, operations.JsonQueryParamsObjectSmallerRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async mixedParametersCamelCase(
        headerParam: string,
        pathParam: string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.MixedParametersCamelCaseRes> {
        const input$: operations.MixedParametersCamelCaseRequest = {
            headerParam: headerParam,
            pathParam: pathParam,
            queryStringParam: queryStringParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.MixedParametersCamelCaseRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            path_param: encodeSimple$("path_param", payload$.path_param, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/anything/mixedParams/path/{path_param}/camelcase"
        )(pathParams$);

        const query$ = encodeFormQuery$({
            query_string_param: payload$.query_string_param,
        });

        const headers$ = new Headers({
            Accept: "application/json",
            header_param: encodeSimple$("header_param", payload$.header_param, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "mixedParametersCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.MixedParametersCamelCaseRes>()
            .json(200, operations.MixedParametersCamelCaseRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async mixedParametersPrimitives(
        headerParam: string,
        pathParam: string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.MixedParametersPrimitivesRes> {
        const input$: operations.MixedParametersPrimitivesRequest = {
            headerParam: headerParam,
            pathParam: pathParam,
            queryStringParam: queryStringParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.MixedParametersPrimitivesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            pathParam: encodeSimple$("pathParam", payload$.pathParam, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/anything/mixedParams/path/{pathParam}")(
            pathParams$
        );

        const query$ = encodeFormQuery$({
            queryStringParam: payload$.queryStringParam,
        });

        const headers$ = new Headers({
            Accept: "application/json",
            headerParam: encodeSimple$("headerParam", payload$.headerParam, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "mixedParametersPrimitives",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.MixedParametersPrimitivesRes>()
            .json(200, operations.MixedParametersPrimitivesRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async mixedQueryParams(
        deepObjectParam: shared.SimpleObject,
        formParam: shared.SimpleObject,
        jsonParam: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.MixedQueryParamsRes> {
        const input$: operations.MixedQueryParamsRequest = {
            deepObjectParam: deepObjectParam,
            formParam: formParam,
            jsonParam: jsonParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.MixedQueryParamsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/mixed")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                deepObjectParam: payload$.deepObjectParam,
            }),
            encodeFormQuery$({
                formParam: payload$.formParam,
            }),
            encodeJSONQuery$(
                {
                    jsonParam: payload$.jsonParam,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "mixedQueryParams",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.MixedQueryParamsRes>()
            .json(200, operations.MixedQueryParamsRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async pathParameterJson(
        jsonObj: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.PathParameterJsonRes> {
        const input$: operations.PathParameterJsonRequest = {
            jsonObj: jsonObj,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.PathParameterJsonRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            jsonObj: encodeJSON$("jsonObj", payload$.jsonObj, {
                explode: true,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/anything/pathParams/json/{jsonObj}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "pathParameterJson",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.PathParameterJsonRes>()
            .json(200, operations.PathParameterJsonRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async pipeDelimitedQueryParamsArray(
        arrParam?: Array<string> | undefined,
        arrParamExploded?: Array<number> | undefined,
        mapParam?: { [k: string]: string } | undefined,
        objParam?: shared.SimpleObject | undefined,
        options?: RequestOptions
    ): Promise<operations.PipeDelimitedQueryParamsArrayRes> {
        const input$: operations.PipeDelimitedQueryParamsArrayRequest = {
            arrParam: arrParam,
            arrParamExploded: arrParamExploded,
            mapParam: mapParam,
            objParam: objParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.PipeDelimitedQueryParamsArrayRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/pipe/array")();

        const query$ = queryJoin$(
            encodePipeDelimitedQuery$(
                {
                    arrParam: payload$.arrParam,
                    mapParam: payload$.mapParam,
                    objParam: payload$.objParam,
                },
                { explode: false }
            ),
            encodePipeDelimitedQuery$({
                arrParamExploded: payload$.arrParamExploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "pipeDelimitedQueryParamsArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.PipeDelimitedQueryParamsArrayRes>()
            .json(200, operations.PipeDelimitedQueryParamsArrayRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async simplePathParameterArrays(
        arrParam: Array<string>,
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterArraysRes> {
        const input$: operations.SimplePathParameterArraysRequest = {
            arrParam: arrParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.SimplePathParameterArraysRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            arrParam: encodeSimple$("arrParam", payload$.arrParam, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/anything/pathParams/arr/{arrParam}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "simplePathParameterArrays",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.SimplePathParameterArraysRes>()
            .json(200, operations.SimplePathParameterArraysRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async simplePathParameterMaps(
        mapParam: { [k: string]: string },
        mapParamExploded: { [k: string]: number },
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterMapsRes> {
        const input$: operations.SimplePathParameterMapsRequest = {
            mapParam: mapParam,
            mapParamExploded: mapParamExploded,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.SimplePathParameterMapsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            mapParam: encodeSimple$("mapParam", payload$.mapParam, {
                explode: false,
                charEncoding: "percent",
            }),
            mapParamExploded: encodeSimple$("mapParamExploded", payload$.mapParamExploded, {
                explode: true,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/anything/pathParams/map/{mapParam}/mapExploded/{mapParamExploded}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "simplePathParameterMaps",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.SimplePathParameterMapsRes>()
            .json(200, operations.SimplePathParameterMapsRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async simplePathParameterObjects(
        objParam: shared.SimpleObject,
        objParamExploded: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterObjectsRes> {
        const input$: operations.SimplePathParameterObjectsRequest = {
            objParam: objParam,
            objParamExploded: objParamExploded,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.SimplePathParameterObjectsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            objParam: encodeSimple$("objParam", payload$.objParam, {
                explode: false,
                charEncoding: "percent",
            }),
            objParamExploded: encodeSimple$("objParamExploded", payload$.objParamExploded, {
                explode: true,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/anything/pathParams/obj/{objParam}/objExploded/{objParamExploded}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "simplePathParameterObjects",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.SimplePathParameterObjectsRes>()
            .json(200, operations.SimplePathParameterObjectsRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async simplePathParameterPrimitives(
        boolParam: boolean,
        intParam: number,
        numParam: number,
        strParam: string,
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterPrimitivesRes> {
        const input$: operations.SimplePathParameterPrimitivesRequest = {
            boolParam: boolParam,
            intParam: intParam,
            numParam: numParam,
            strParam: strParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.SimplePathParameterPrimitivesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            boolParam: encodeSimple$("boolParam", payload$.boolParam, {
                explode: false,
                charEncoding: "percent",
            }),
            intParam: encodeSimple$("intParam", payload$.intParam, {
                explode: false,
                charEncoding: "percent",
            }),
            numParam: encodeSimple$("numParam", payload$.numParam, {
                explode: false,
                charEncoding: "percent",
            }),
            strParam: encodeSimple$("strParam", payload$.strParam, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/anything/pathParams/str/{strParam}/bool/{boolParam}/int/{intParam}/num/{numParam}"
        )(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "simplePathParameterPrimitives",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.SimplePathParameterPrimitivesRes>()
            .json(200, operations.SimplePathParameterPrimitivesRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }
}
