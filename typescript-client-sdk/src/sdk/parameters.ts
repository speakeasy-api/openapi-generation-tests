/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeDeepObjectQuery as encodeDeepObjectQuery$,
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeJSONQuery as encodeJSONQuery$,
    encodePipeDelimitedQuery as encodePipeDelimitedQuery$,
    encodeSimple as encodeSimple$,
    queryJoin as queryJoin$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "./models/operations/index.js";
import * as shared from "./models/shared/index.js";

export class ParametersT extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    async deepObjectQueryParamsMap(
        mapParam: { [k: string]: string },
        mapArrParam?: { [k: string]: Array<string> } | undefined,
        options?: RequestOptions
    ): Promise<operations.DeepObjectQueryParamsMapResponse> {
        const input$: operations.DeepObjectQueryParamsMapRequest = {
            mapArrParam: mapArrParam,
            mapParam: mapParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DeepObjectQueryParamsMapRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/deepObject/map")();

        const query$ = encodeDeepObjectQuery$({
            mapArrParam: payload$.mapArrParam,
            mapParam: payload$.mapParam,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "deepObjectQueryParamsMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.DeepObjectQueryParamsMapResponse>()
            .json(200, operations.DeepObjectQueryParamsMapResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async deepObjectQueryParamsObject(
        objParam: shared.SimpleObject,
        objArrParam?: operations.ObjArrParam | undefined,
        options?: RequestOptions
    ): Promise<operations.DeepObjectQueryParamsObjectResponse> {
        const input$: operations.DeepObjectQueryParamsObjectRequest = {
            objArrParam: objArrParam,
            objParam: objParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DeepObjectQueryParamsObjectRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/deepObject/obj")();

        const query$ = encodeDeepObjectQuery$({
            objArrParam: payload$.objArrParam,
            objParam: payload$.objParam,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "deepObjectQueryParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.DeepObjectQueryParamsObjectResponse>()
            .json(200, operations.DeepObjectQueryParamsObjectResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async duplicateParam(
        duplicateParamRequest: string,
        options?: RequestOptions
    ): Promise<operations.DuplicateParamResponse> {
        const input$: operations.DuplicateParamRequest = {
            duplicateParamRequest: duplicateParamRequest,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.DuplicateParamRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            duplicateParamRequest: encodeSimple$(
                "duplicateParamRequest",
                payload$.duplicateParamRequest,
                { explode: false, charEncoding: "percent" }
            ),
        };
        const path$ = this.templateURLComponent("/anything/params/{duplicateParamRequest}")(
            pathParams$
        );

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "duplicateParam",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.DuplicateParamResponse>()
            .json(200, operations.DuplicateParamResponse$, { key: "duplicateParamResponse" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async formQueryParamsArray(
        arrParam?: Array<string> | undefined,
        arrParamExploded?: Array<number> | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsArrayResponse> {
        const input$: operations.FormQueryParamsArrayRequest = {
            arrParam: arrParam,
            arrParamExploded: arrParamExploded,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.FormQueryParamsArrayRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/array")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    arrParam: payload$.arrParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                arrParamExploded: payload$.arrParamExploded,
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.FormQueryParamsArrayResponse>()
            .json(200, operations.FormQueryParamsArrayResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async formQueryParamsCamelObject(
        objParamExploded: operations.ObjParamExploded,
        objParam?: operations.ObjParam | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsCamelObjectResponse> {
        const input$: operations.FormQueryParamsCamelObjectRequest = {
            objParam: objParam,
            objParamExploded: objParamExploded,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.FormQueryParamsCamelObjectRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/camelObj")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    obj_param: payload$.obj_param,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                obj_param_exploded: payload$.obj_param_exploded,
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsCamelObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.FormQueryParamsCamelObjectResponse>()
            .json(200, operations.FormQueryParamsCamelObjectResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async formQueryParamsMap(
        mapParam?: { [k: string]: string } | undefined,
        mapParamExploded?: { [k: string]: number } | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsMapResponse> {
        const input$: operations.FormQueryParamsMapRequest = {
            mapParam: mapParam,
            mapParamExploded: mapParamExploded,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.FormQueryParamsMapRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/map")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    mapParam: payload$.mapParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                mapParamExploded: payload$.mapParamExploded,
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.FormQueryParamsMapResponse>()
            .json(200, operations.FormQueryParamsMapResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async formQueryParamsObject(
        objParamExploded: shared.SimpleObject,
        objParam?: shared.SimpleObject | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsObjectResponse> {
        const input$: operations.FormQueryParamsObjectRequest = {
            objParam: objParam,
            objParamExploded: objParamExploded,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.FormQueryParamsObjectRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/obj")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    objParam: payload$.objParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                objParamExploded: payload$.objParamExploded,
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.FormQueryParamsObjectResponse>()
            .json(200, operations.FormQueryParamsObjectResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async formQueryParamsPrimitive(
        boolParam: boolean,
        intParam: number,
        numParam: number,
        strParam: string,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsPrimitiveResponse> {
        const input$: operations.FormQueryParamsPrimitiveRequest = {
            boolParam: boolParam,
            intParam: intParam,
            numParam: numParam,
            strParam: strParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.FormQueryParamsPrimitiveRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/primitive")();

        const query$ = encodeFormQuery$({
            boolParam: payload$.boolParam,
            intParam: payload$.intParam,
            numParam: payload$.numParam,
            strParam: payload$.strParam,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.FormQueryParamsPrimitiveResponse>()
            .json(200, operations.FormQueryParamsPrimitiveResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async formQueryParamsRefParamObject(
        refObjParam?: shared.RefQueryParamObj | undefined,
        refObjParamExploded?: shared.RefQueryParamObjExploded | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsRefParamObjectResponse> {
        const input$: operations.FormQueryParamsRefParamObjectRequest = {
            refObjParam: refObjParam,
            refObjParamExploded: refObjParamExploded,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.FormQueryParamsRefParamObjectRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/form/refParamObject")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    refObjParam: payload$.refObjParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                refObjParamExploded: payload$.refObjParamExploded,
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "formQueryParamsRefParamObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.FormQueryParamsRefParamObjectResponse>()
            .json(200, operations.FormQueryParamsRefParamObjectResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async headerParamsArray(
        xHeaderArray: Array<string>,
        options?: RequestOptions
    ): Promise<operations.HeaderParamsArrayResponse> {
        const input$: operations.HeaderParamsArrayRequest = {
            xHeaderArray: xHeaderArray,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.HeaderParamsArrayRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/headers/array")();

        const query$ = "";

        headers$.set(
            "X-Header-Array",
            encodeSimple$("X-Header-Array", payload$["X-Header-Array"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "headerParamsArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.HeaderParamsArrayResponse>()
            .json(200, operations.HeaderParamsArrayResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async headerParamsMap(
        xHeaderMap: { [k: string]: string },
        xHeaderMapExplode: { [k: string]: string },
        options?: RequestOptions
    ): Promise<operations.HeaderParamsMapResponse> {
        const input$: operations.HeaderParamsMapRequest = {
            xHeaderMap: xHeaderMap,
            xHeaderMapExplode: xHeaderMapExplode,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.HeaderParamsMapRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/headers/map")();

        const query$ = "";

        headers$.set(
            "X-Header-Map",
            encodeSimple$("X-Header-Map", payload$["X-Header-Map"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "X-Header-Map-Explode",
            encodeSimple$("X-Header-Map-Explode", payload$["X-Header-Map-Explode"], {
                explode: true,
                charEncoding: "none",
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "headerParamsMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.HeaderParamsMapResponse>()
            .json(200, operations.HeaderParamsMapResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async headerParamsObject(
        xHeaderObj: shared.SimpleObject,
        xHeaderObjExplode: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.HeaderParamsObjectResponse> {
        const input$: operations.HeaderParamsObjectRequest = {
            xHeaderObj: xHeaderObj,
            xHeaderObjExplode: xHeaderObjExplode,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.HeaderParamsObjectRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/headers/obj")();

        const query$ = "";

        headers$.set(
            "X-Header-Obj",
            encodeSimple$("X-Header-Obj", payload$["X-Header-Obj"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "X-Header-Obj-Explode",
            encodeSimple$("X-Header-Obj-Explode", payload$["X-Header-Obj-Explode"], {
                explode: true,
                charEncoding: "none",
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "headerParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.HeaderParamsObjectResponse>()
            .json(200, operations.HeaderParamsObjectResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async headerParamsPrimitive(
        xHeaderBoolean: boolean,
        xHeaderInteger: number,
        xHeaderNumber: number,
        xHeaderString: string,
        options?: RequestOptions
    ): Promise<operations.HeaderParamsPrimitiveResponse> {
        const input$: operations.HeaderParamsPrimitiveRequest = {
            xHeaderBoolean: xHeaderBoolean,
            xHeaderInteger: xHeaderInteger,
            xHeaderNumber: xHeaderNumber,
            xHeaderString: xHeaderString,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.HeaderParamsPrimitiveRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/headers/primitive")();

        const query$ = "";

        headers$.set(
            "X-Header-Boolean",
            encodeSimple$("X-Header-Boolean", payload$["X-Header-Boolean"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "X-Header-Integer",
            encodeSimple$("X-Header-Integer", payload$["X-Header-Integer"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "X-Header-Number",
            encodeSimple$("X-Header-Number", payload$["X-Header-Number"], {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "X-Header-String",
            encodeSimple$("X-Header-String", payload$["X-Header-String"], {
                explode: false,
                charEncoding: "none",
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "headerParamsPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.HeaderParamsPrimitiveResponse>()
            .json(200, operations.HeaderParamsPrimitiveResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async jsonQueryParamsObject(
        deepObjParam: shared.DeepObject,
        simpleObjParam: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.JsonQueryParamsObjectResponse> {
        const input$: operations.JsonQueryParamsObjectRequest = {
            deepObjParam: deepObjParam,
            simpleObjParam: simpleObjParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.JsonQueryParamsObjectRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/json/obj")();

        const query$ = encodeJSONQuery$(
            {
                deepObjParam: payload$.deepObjParam,
                simpleObjParam: payload$.simpleObjParam,
            },
            { explode: false }
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "jsonQueryParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.JsonQueryParamsObjectResponse>()
            .json(200, operations.JsonQueryParamsObjectResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async jsonQueryParamsObjectSmaller(
        deepObjParam: shared.DeepObjectSmaller,
        simpleObjParam: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.JsonQueryParamsObjectSmallerResponse> {
        const input$: operations.JsonQueryParamsObjectSmallerRequest = {
            deepObjParam: deepObjParam,
            simpleObjParam: simpleObjParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.JsonQueryParamsObjectSmallerRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/json/objsmaller")();

        const query$ = encodeJSONQuery$(
            {
                deepObjParam: payload$.deepObjParam,
                simpleObjParam: payload$.simpleObjParam,
            },
            { explode: false }
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "jsonQueryParamsObjectSmaller",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.JsonQueryParamsObjectSmallerResponse>()
            .json(200, operations.JsonQueryParamsObjectSmallerResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async mixedParametersCamelCase(
        headerParam: string,
        pathParam: string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.MixedParametersCamelCaseResponse> {
        const input$: operations.MixedParametersCamelCaseRequest = {
            headerParam: headerParam,
            pathParam: pathParam,
            queryStringParam: queryStringParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.MixedParametersCamelCaseRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            path_param: encodeSimple$("path_param", payload$.path_param, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/anything/mixedParams/path/{path_param}/camelcase"
        )(pathParams$);

        const query$ = encodeFormQuery$({
            query_string_param: payload$.query_string_param,
        });

        headers$.set(
            "header_param",
            encodeSimple$("header_param", payload$.header_param, {
                explode: false,
                charEncoding: "none",
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "mixedParametersCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.MixedParametersCamelCaseResponse>()
            .json(200, operations.MixedParametersCamelCaseResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async mixedParametersPrimitives(
        headerParam: string,
        pathParam: string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.MixedParametersPrimitivesResponse> {
        const input$: operations.MixedParametersPrimitivesRequest = {
            headerParam: headerParam,
            pathParam: pathParam,
            queryStringParam: queryStringParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.MixedParametersPrimitivesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            pathParam: encodeSimple$("pathParam", payload$.pathParam, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/anything/mixedParams/path/{pathParam}")(
            pathParams$
        );

        const query$ = encodeFormQuery$({
            queryStringParam: payload$.queryStringParam,
        });

        headers$.set(
            "headerParam",
            encodeSimple$("headerParam", payload$.headerParam, {
                explode: false,
                charEncoding: "none",
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "mixedParametersPrimitives",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.MixedParametersPrimitivesResponse>()
            .json(200, operations.MixedParametersPrimitivesResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async mixedQueryParams(
        deepObjectParam: shared.SimpleObject,
        formParam: shared.SimpleObject,
        jsonParam: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.MixedQueryParamsResponse> {
        const input$: operations.MixedQueryParamsRequest = {
            deepObjectParam: deepObjectParam,
            formParam: formParam,
            jsonParam: jsonParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.MixedQueryParamsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/mixed")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                deepObjectParam: payload$.deepObjectParam,
            }),
            encodeFormQuery$({
                formParam: payload$.formParam,
            }),
            encodeJSONQuery$(
                {
                    jsonParam: payload$.jsonParam,
                },
                { explode: false }
            )
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "mixedQueryParams",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.MixedQueryParamsResponse>()
            .json(200, operations.MixedQueryParamsResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async pathParameterJson(
        jsonObj: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.PathParameterJsonResponse> {
        const input$: operations.PathParameterJsonRequest = {
            jsonObj: jsonObj,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.PathParameterJsonRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            jsonObj: encodeJSON$("jsonObj", payload$.jsonObj, {
                explode: true,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/anything/pathParams/json/{jsonObj}")(pathParams$);

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "pathParameterJson",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.PathParameterJsonResponse>()
            .json(200, operations.PathParameterJsonResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async pipeDelimitedQueryParamsArray(
        arrParam?: Array<string> | undefined,
        arrParamExploded?: Array<number> | undefined,
        mapParam?: { [k: string]: string } | undefined,
        objParam?: shared.SimpleObject | undefined,
        options?: RequestOptions
    ): Promise<operations.PipeDelimitedQueryParamsArrayResponse> {
        const input$: operations.PipeDelimitedQueryParamsArrayRequest = {
            arrParam: arrParam,
            arrParamExploded: arrParamExploded,
            mapParam: mapParam,
            objParam: objParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.PipeDelimitedQueryParamsArrayRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/queryParams/pipe/array")();

        const query$ = queryJoin$(
            encodePipeDelimitedQuery$(
                {
                    arrParam: payload$.arrParam,
                    mapParam: payload$.mapParam,
                    objParam: payload$.objParam,
                },
                { explode: false }
            ),
            encodePipeDelimitedQuery$({
                arrParamExploded: payload$.arrParamExploded,
            })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "pipeDelimitedQueryParamsArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.PipeDelimitedQueryParamsArrayResponse>()
            .json(200, operations.PipeDelimitedQueryParamsArrayResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async simplePathParameterArrays(
        arrParam: Array<string>,
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterArraysResponse> {
        const input$: operations.SimplePathParameterArraysRequest = {
            arrParam: arrParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.SimplePathParameterArraysRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            arrParam: encodeSimple$("arrParam", payload$.arrParam, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent("/anything/pathParams/arr/{arrParam}")(pathParams$);

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "simplePathParameterArrays",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.SimplePathParameterArraysResponse>()
            .json(200, operations.SimplePathParameterArraysResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async simplePathParameterMaps(
        mapParam: { [k: string]: string },
        mapParamExploded: { [k: string]: number },
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterMapsResponse> {
        const input$: operations.SimplePathParameterMapsRequest = {
            mapParam: mapParam,
            mapParamExploded: mapParamExploded,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.SimplePathParameterMapsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            mapParam: encodeSimple$("mapParam", payload$.mapParam, {
                explode: false,
                charEncoding: "percent",
            }),
            mapParamExploded: encodeSimple$("mapParamExploded", payload$.mapParamExploded, {
                explode: true,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/anything/pathParams/map/{mapParam}/mapExploded/{mapParamExploded}"
        )(pathParams$);

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "simplePathParameterMaps",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.SimplePathParameterMapsResponse>()
            .json(200, operations.SimplePathParameterMapsResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async simplePathParameterObjects(
        objParam: shared.SimpleObject,
        objParamExploded: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterObjectsResponse> {
        const input$: operations.SimplePathParameterObjectsRequest = {
            objParam: objParam,
            objParamExploded: objParamExploded,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.SimplePathParameterObjectsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            objParam: encodeSimple$("objParam", payload$.objParam, {
                explode: false,
                charEncoding: "percent",
            }),
            objParamExploded: encodeSimple$("objParamExploded", payload$.objParamExploded, {
                explode: true,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/anything/pathParams/obj/{objParam}/objExploded/{objParamExploded}"
        )(pathParams$);

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "simplePathParameterObjects",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.SimplePathParameterObjectsResponse>()
            .json(200, operations.SimplePathParameterObjectsResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async simplePathParameterPrimitives(
        boolParam: boolean,
        intParam: number,
        numParam: number,
        strParam: string,
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterPrimitivesResponse> {
        const input$: operations.SimplePathParameterPrimitivesRequest = {
            boolParam: boolParam,
            intParam: intParam,
            numParam: numParam,
            strParam: strParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.SimplePathParameterPrimitivesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const pathParams$ = {
            boolParam: encodeSimple$("boolParam", payload$.boolParam, {
                explode: false,
                charEncoding: "percent",
            }),
            intParam: encodeSimple$("intParam", payload$.intParam, {
                explode: false,
                charEncoding: "percent",
            }),
            numParam: encodeSimple$("numParam", payload$.numParam, {
                explode: false,
                charEncoding: "percent",
            }),
            strParam: encodeSimple$("strParam", payload$.strParam, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/anything/pathParams/str/{strParam}/bool/{boolParam}/int/{intParam}/num/{numParam}"
        )(pathParams$);

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "simplePathParameterPrimitives",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.SimplePathParameterPrimitivesResponse>()
            .json(200, operations.SimplePathParameterPrimitivesResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }
}
