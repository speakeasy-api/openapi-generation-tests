/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
    encodeDeepObjectQuery as encodeDeepObjectQuery$,
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeJSONQuery as encodeJSONQuery$,
    encodePipeDelimitedQuery as encodePipeDelimitedQuery$,
    encodeSimple as encodeSimple$,
    queryJoin as queryJoin$,
} from "../lib/encodings.js";
import * as m$ from "../lib/matchers.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { SDKError } from "./models/errors/sdkerror.js";
import { SDKValidationError } from "./models/errors/sdkvalidationerror.js";
import * as operations from "./models/operations/index.js";
import * as shared from "./models/shared/index.js";
import { unwrap as unwrap$ } from "./types/fp.js";

export class ParametersT extends ClientSDK {
    async deepObjectQueryParamsDeepObject(
        deepObj: shared.DeepObjectQueryParams,
        options?: RequestOptions
    ): Promise<operations.DeepObjectQueryParamsDeepObjectRes> {
        const input$: operations.DeepObjectQueryParamsDeepObjectRequest = {
            deepObj: deepObj,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.DeepObjectQueryParamsDeepObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/deepObject/deepObj")();

        const query$ = encodeDeepObjectQuery$({
            deepObj: payload$.deepObj,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "deepObjectQueryParamsDeepObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.DeepObjectQueryParamsDeepObjectRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.DeepObjectQueryParamsDeepObjectRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async deepObjectQueryParamsMap(
        mapParam: { [k: string]: string },
        mapArrParam?: { [k: string]: Array<string> } | undefined,
        options?: RequestOptions
    ): Promise<operations.DeepObjectQueryParamsMapRes> {
        const input$: operations.DeepObjectQueryParamsMapRequest = {
            mapArrParam: mapArrParam,
            mapParam: mapParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.DeepObjectQueryParamsMapRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/deepObject/map")();

        const query$ = encodeDeepObjectQuery$({
            mapArrParam: payload$.mapArrParam,
            mapParam: payload$.mapParam,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "deepObjectQueryParamsMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.DeepObjectQueryParamsMapRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.DeepObjectQueryParamsMapRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async deepObjectQueryParamsObject(
        objParam: shared.SimpleObject,
        objArrParam?: operations.ObjArrParam | undefined,
        options?: RequestOptions
    ): Promise<operations.DeepObjectQueryParamsObjectRes> {
        const input$: operations.DeepObjectQueryParamsObjectRequest = {
            objArrParam: objArrParam,
            objParam: objParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.DeepObjectQueryParamsObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/deepObject/obj")();

        const query$ = encodeDeepObjectQuery$({
            objArrParam: payload$.objArrParam,
            objParam: payload$.objParam,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "deepObjectQueryParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.DeepObjectQueryParamsObjectRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.DeepObjectQueryParamsObjectRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async duplicateParam(
        duplicateParamRequest: string,
        options?: RequestOptions
    ): Promise<operations.DuplicateParamDuplicateParamResponse> {
        const input$: operations.DuplicateParamRequest = {
            duplicateParamRequest: duplicateParamRequest,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.DuplicateParamRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            duplicateParamRequest: encodeSimple$(
                "duplicateParamRequest",
                payload$.duplicateParamRequest,
                { explode: false, charEncoding: "percent" }
            ),
        };

        const path$ = pathToFunc("/anything/params/{duplicateParamRequest}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "duplicateParam",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.DuplicateParamDuplicateParamResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.DuplicateParamDuplicateParamResponse$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async formQueryParamsArray(
        arrParam?: Array<string> | undefined,
        arrParamExploded?: Array<number> | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsArrayRes> {
        const input$: operations.FormQueryParamsArrayRequest = {
            arrParam: arrParam,
            arrParamExploded: arrParamExploded,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.FormQueryParamsArrayRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/form/array")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    arrParam: payload$.arrParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                arrParamExploded: payload$.arrParamExploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "formQueryParamsArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.FormQueryParamsArrayRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.FormQueryParamsArrayRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async formQueryParamsCamelObject(
        objParamExploded: operations.ObjParamExploded,
        objParam?: operations.ObjParam | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsCamelObjectRes> {
        const input$: operations.FormQueryParamsCamelObjectRequest = {
            objParam: objParam,
            objParamExploded: objParamExploded,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.FormQueryParamsCamelObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/form/camelObj")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    obj_param: payload$.obj_param,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                obj_param_exploded: payload$.obj_param_exploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "formQueryParamsCamelObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.FormQueryParamsCamelObjectRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.FormQueryParamsCamelObjectRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async formQueryParamsMap(
        mapParam?: { [k: string]: string } | undefined,
        mapParamExploded?: { [k: string]: number } | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsMapRes> {
        const input$: operations.FormQueryParamsMapRequest = {
            mapParam: mapParam,
            mapParamExploded: mapParamExploded,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.FormQueryParamsMapRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/form/map")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    mapParam: payload$.mapParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                mapParamExploded: payload$.mapParamExploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "formQueryParamsMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.FormQueryParamsMapRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.FormQueryParamsMapRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async formQueryParamsObject(
        objParamExploded: shared.SimpleObject,
        objParam?: shared.SimpleObject | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsObjectRes> {
        const input$: operations.FormQueryParamsObjectRequest = {
            objParam: objParam,
            objParamExploded: objParamExploded,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.FormQueryParamsObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/form/obj")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    objParam: payload$.objParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                objParamExploded: payload$.objParamExploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "formQueryParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.FormQueryParamsObjectRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.FormQueryParamsObjectRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async formQueryParamsPrimitive(
        boolParam: boolean,
        intParam: number,
        numParam: number,
        strParam: string,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsPrimitiveRes> {
        const input$: operations.FormQueryParamsPrimitiveRequest = {
            boolParam: boolParam,
            intParam: intParam,
            numParam: numParam,
            strParam: strParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.FormQueryParamsPrimitiveRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/form/primitive")();

        const query$ = encodeFormQuery$({
            boolParam: payload$.boolParam,
            intParam: payload$.intParam,
            numParam: payload$.numParam,
            strParam: payload$.strParam,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "formQueryParamsPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.FormQueryParamsPrimitiveRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.FormQueryParamsPrimitiveRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async formQueryParamsRefParamObject(
        refObjParam?: shared.RefQueryParamObj | undefined,
        refObjParamExploded?: shared.RefQueryParamObjExploded | undefined,
        options?: RequestOptions
    ): Promise<operations.FormQueryParamsRefParamObjectRes> {
        const input$: operations.FormQueryParamsRefParamObjectRequest = {
            refObjParam: refObjParam,
            refObjParamExploded: refObjParamExploded,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.FormQueryParamsRefParamObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/form/refParamObject")();

        const query$ = queryJoin$(
            encodeFormQuery$(
                {
                    refObjParam: payload$.refObjParam,
                },
                { explode: false }
            ),
            encodeFormQuery$({
                refObjParamExploded: payload$.refObjParamExploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "formQueryParamsRefParamObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.FormQueryParamsRefParamObjectRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.FormQueryParamsRefParamObjectRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async headerParamsArray(
        xHeaderArray: Array<string>,
        options?: RequestOptions
    ): Promise<operations.HeaderParamsArrayRes> {
        const input$: operations.HeaderParamsArrayRequest = {
            xHeaderArray: xHeaderArray,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.HeaderParamsArrayRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/headers/array")();

        const headers$ = new Headers({
            Accept: "application/json",
            "X-Header-Array": encodeSimple$("X-Header-Array", payload$["X-Header-Array"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "headerParamsArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.HeaderParamsArrayRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.HeaderParamsArrayRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async headerParamsMap(
        xHeaderMap: { [k: string]: string },
        xHeaderMapExplode: { [k: string]: string },
        options?: RequestOptions
    ): Promise<operations.HeaderParamsMapRes> {
        const input$: operations.HeaderParamsMapRequest = {
            xHeaderMap: xHeaderMap,
            xHeaderMapExplode: xHeaderMapExplode,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.HeaderParamsMapRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/headers/map")();

        const headers$ = new Headers({
            Accept: "application/json",
            "X-Header-Map": encodeSimple$("X-Header-Map", payload$["X-Header-Map"], {
                explode: false,
                charEncoding: "none",
            }),
            "X-Header-Map-Explode": encodeSimple$(
                "X-Header-Map-Explode",
                payload$["X-Header-Map-Explode"],
                { explode: true, charEncoding: "none" }
            ),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "headerParamsMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.HeaderParamsMapRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.HeaderParamsMapRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async headerParamsObject(
        xHeaderObj: shared.SimpleObject,
        xHeaderObjExplode: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.HeaderParamsObjectRes> {
        const input$: operations.HeaderParamsObjectRequest = {
            xHeaderObj: xHeaderObj,
            xHeaderObjExplode: xHeaderObjExplode,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.HeaderParamsObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/headers/obj")();

        const headers$ = new Headers({
            Accept: "application/json",
            "X-Header-Obj": encodeSimple$("X-Header-Obj", payload$["X-Header-Obj"], {
                explode: false,
                charEncoding: "none",
            }),
            "X-Header-Obj-Explode": encodeSimple$(
                "X-Header-Obj-Explode",
                payload$["X-Header-Obj-Explode"],
                { explode: true, charEncoding: "none" }
            ),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "headerParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.HeaderParamsObjectRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.HeaderParamsObjectRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async headerParamsPrimitive(
        xHeaderBoolean: boolean,
        xHeaderInteger: number,
        xHeaderNumber: number,
        xHeaderString: string,
        options?: RequestOptions
    ): Promise<operations.HeaderParamsPrimitiveRes> {
        const input$: operations.HeaderParamsPrimitiveRequest = {
            xHeaderBoolean: xHeaderBoolean,
            xHeaderInteger: xHeaderInteger,
            xHeaderNumber: xHeaderNumber,
            xHeaderString: xHeaderString,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.HeaderParamsPrimitiveRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/headers/primitive")();

        const headers$ = new Headers({
            Accept: "application/json",
            "X-Header-Boolean": encodeSimple$("X-Header-Boolean", payload$["X-Header-Boolean"], {
                explode: false,
                charEncoding: "none",
            }),
            "X-Header-Integer": encodeSimple$("X-Header-Integer", payload$["X-Header-Integer"], {
                explode: false,
                charEncoding: "none",
            }),
            "X-Header-Number": encodeSimple$("X-Header-Number", payload$["X-Header-Number"], {
                explode: false,
                charEncoding: "none",
            }),
            "X-Header-String": encodeSimple$("X-Header-String", payload$["X-Header-String"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "headerParamsPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.HeaderParamsPrimitiveRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.HeaderParamsPrimitiveRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async jsonQueryParamsObject(
        deepObjParam: shared.DeepObject,
        simpleObjParam: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.JsonQueryParamsObjectRes> {
        const input$: operations.JsonQueryParamsObjectRequest = {
            deepObjParam: deepObjParam,
            simpleObjParam: simpleObjParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.JsonQueryParamsObjectRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/json/obj")();

        const query$ = encodeJSONQuery$(
            {
                deepObjParam: payload$.deepObjParam,
                simpleObjParam: payload$.simpleObjParam,
            },
            { explode: false }
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "jsonQueryParamsObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.JsonQueryParamsObjectRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.JsonQueryParamsObjectRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async jsonQueryParamsObjectSmaller(
        deepObjParam: shared.DeepObjectSmaller,
        simpleObjParam: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.JsonQueryParamsObjectSmallerRes> {
        const input$: operations.JsonQueryParamsObjectSmallerRequest = {
            deepObjParam: deepObjParam,
            simpleObjParam: simpleObjParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.JsonQueryParamsObjectSmallerRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/json/objsmaller")();

        const query$ = encodeJSONQuery$(
            {
                deepObjParam: payload$.deepObjParam,
                simpleObjParam: payload$.simpleObjParam,
            },
            { explode: false }
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "jsonQueryParamsObjectSmaller",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.JsonQueryParamsObjectSmallerRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.JsonQueryParamsObjectSmallerRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async mixedParametersCamelCase(
        headerParam: string,
        pathParam: string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.MixedParametersCamelCaseRes> {
        const input$: operations.MixedParametersCamelCaseRequest = {
            headerParam: headerParam,
            pathParam: pathParam,
            queryStringParam: queryStringParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.MixedParametersCamelCaseRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            path_param: encodeSimple$("path_param", payload$.path_param, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/anything/mixedParams/path/{path_param}/camelcase")(pathParams$);

        const query$ = encodeFormQuery$({
            query_string_param: payload$.query_string_param,
        });

        const headers$ = new Headers({
            Accept: "application/json",
            header_param: encodeSimple$("header_param", payload$.header_param, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "mixedParametersCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.MixedParametersCamelCaseRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.MixedParametersCamelCaseRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async mixedParametersPrimitives(
        headerParam: string,
        pathParam: string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.MixedParametersPrimitivesRes> {
        const input$: operations.MixedParametersPrimitivesRequest = {
            headerParam: headerParam,
            pathParam: pathParam,
            queryStringParam: queryStringParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.MixedParametersPrimitivesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            pathParam: encodeSimple$("pathParam", payload$.pathParam, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/anything/mixedParams/path/{pathParam}")(pathParams$);

        const query$ = encodeFormQuery$({
            queryStringParam: payload$.queryStringParam,
        });

        const headers$ = new Headers({
            Accept: "application/json",
            headerParam: encodeSimple$("headerParam", payload$.headerParam, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "mixedParametersPrimitives",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.MixedParametersPrimitivesRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.MixedParametersPrimitivesRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async mixedQueryParams(
        deepObjectParam: shared.SimpleObject,
        formParam: shared.SimpleObject,
        jsonParam: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.MixedQueryParamsRes> {
        const input$: operations.MixedQueryParamsRequest = {
            deepObjectParam: deepObjectParam,
            formParam: formParam,
            jsonParam: jsonParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.MixedQueryParamsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/mixed")();

        const query$ = queryJoin$(
            encodeDeepObjectQuery$({
                deepObjectParam: payload$.deepObjectParam,
            }),
            encodeFormQuery$({
                formParam: payload$.formParam,
            }),
            encodeJSONQuery$(
                {
                    jsonParam: payload$.jsonParam,
                },
                { explode: false }
            )
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "mixedQueryParams",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.MixedQueryParamsRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.MixedQueryParamsRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async pathParameterJson(
        jsonObj: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.PathParameterJsonRes> {
        const input$: operations.PathParameterJsonRequest = {
            jsonObj: jsonObj,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.PathParameterJsonRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            jsonObj: encodeJSON$("jsonObj", payload$.jsonObj, {
                explode: true,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/anything/pathParams/json/{jsonObj}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "pathParameterJson",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.PathParameterJsonRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.PathParameterJsonRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async pipeDelimitedQueryParamsArray(
        arrParam?: Array<string> | undefined,
        arrParamExploded?: Array<number> | undefined,
        mapParam?: { [k: string]: string } | undefined,
        objParam?: shared.SimpleObject | undefined,
        options?: RequestOptions
    ): Promise<operations.PipeDelimitedQueryParamsArrayRes> {
        const input$: operations.PipeDelimitedQueryParamsArrayRequest = {
            arrParam: arrParam,
            arrParamExploded: arrParamExploded,
            mapParam: mapParam,
            objParam: objParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.PipeDelimitedQueryParamsArrayRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/queryParams/pipe/array")();

        const query$ = queryJoin$(
            encodePipeDelimitedQuery$(
                {
                    arrParam: payload$.arrParam,
                    mapParam: payload$.mapParam,
                    objParam: payload$.objParam,
                },
                { explode: false }
            ),
            encodePipeDelimitedQuery$({
                arrParamExploded: payload$.arrParamExploded,
            })
        );

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "pipeDelimitedQueryParamsArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.PipeDelimitedQueryParamsArrayRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.PipeDelimitedQueryParamsArrayRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async simplePathParameterArrays(
        arrParam: Array<string>,
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterArraysRes> {
        const input$: operations.SimplePathParameterArraysRequest = {
            arrParam: arrParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.SimplePathParameterArraysRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            arrParam: encodeSimple$("arrParam", payload$.arrParam, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc("/anything/pathParams/arr/{arrParam}")(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "simplePathParameterArrays",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.SimplePathParameterArraysRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.SimplePathParameterArraysRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async simplePathParameterMaps(
        mapParam: { [k: string]: string },
        mapParamExploded: { [k: string]: number },
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterMapsRes> {
        const input$: operations.SimplePathParameterMapsRequest = {
            mapParam: mapParam,
            mapParamExploded: mapParamExploded,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.SimplePathParameterMapsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            mapParam: encodeSimple$("mapParam", payload$.mapParam, {
                explode: false,
                charEncoding: "percent",
            }),
            mapParamExploded: encodeSimple$("mapParamExploded", payload$.mapParamExploded, {
                explode: true,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc(
            "/anything/pathParams/map/{mapParam}/mapExploded/{mapParamExploded}"
        )(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "simplePathParameterMaps",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.SimplePathParameterMapsRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.SimplePathParameterMapsRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async simplePathParameterObjects(
        objParam: shared.SimpleObject,
        objParamExploded: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterObjectsRes> {
        const input$: operations.SimplePathParameterObjectsRequest = {
            objParam: objParam,
            objParamExploded: objParamExploded,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.SimplePathParameterObjectsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            objParam: encodeSimple$("objParam", payload$.objParam, {
                explode: false,
                charEncoding: "percent",
            }),
            objParamExploded: encodeSimple$("objParamExploded", payload$.objParamExploded, {
                explode: true,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc(
            "/anything/pathParams/obj/{objParam}/objExploded/{objParamExploded}"
        )(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "simplePathParameterObjects",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.SimplePathParameterObjectsRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.SimplePathParameterObjectsRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async simplePathParameterPrimitives(
        boolParam: boolean,
        intParam: number,
        numParam: number,
        strParam: string,
        options?: RequestOptions
    ): Promise<operations.SimplePathParameterPrimitivesRes> {
        const input$: operations.SimplePathParameterPrimitivesRequest = {
            boolParam: boolParam,
            intParam: intParam,
            numParam: numParam,
            strParam: strParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.SimplePathParameterPrimitivesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const pathParams$ = {
            boolParam: encodeSimple$("boolParam", payload$.boolParam, {
                explode: false,
                charEncoding: "percent",
            }),
            intParam: encodeSimple$("intParam", payload$.intParam, {
                explode: false,
                charEncoding: "percent",
            }),
            numParam: encodeSimple$("numParam", payload$.numParam, {
                explode: false,
                charEncoding: "percent",
            }),
            strParam: encodeSimple$("strParam", payload$.strParam, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc(
            "/anything/pathParams/str/{strParam}/bool/{boolParam}/int/{intParam}/num/{numParam}"
        )(pathParams$);

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "simplePathParameterPrimitives",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.SimplePathParameterPrimitivesRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.SimplePathParameterPrimitivesRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }
}
