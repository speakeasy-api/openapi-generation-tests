/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as b64$ from "../lib/base64.js";
import {
    encodeBodyForm as encodeBodyForm$,
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeSimple as encodeSimple$,
} from "../lib/encodings.js";
import * as m$ from "../lib/matchers.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { SDKError } from "./models/errors/sdkerror.js";
import { SDKValidationError } from "./models/errors/sdkvalidationerror.js";
import * as operations from "./models/operations/index.js";
import { RequestBodyPostApplicationJsonArrayServerList } from "./models/operations/requestbodypostapplicationjsonarray.js";
import { RequestBodyPostApplicationJsonArrayCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonarraycamelcase.js";
import { RequestBodyPostApplicationJsonArrayOfArrayServerList } from "./models/operations/requestbodypostapplicationjsonarrayofarray.js";
import { RequestBodyPostApplicationJsonArrayOfArrayCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonarrayofarraycamelcase.js";
import { RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonarrayofarrayofprimitive.js";
import { RequestBodyPostApplicationJsonArrayOfMapServerList } from "./models/operations/requestbodypostapplicationjsonarrayofmap.js";
import { RequestBodyPostApplicationJsonArrayOfMapCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonarrayofmapcamelcase.js";
import { RequestBodyPostApplicationJsonArrayOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonarrayofprimitive.js";
import { RequestBodyPostApplicationJsonMapServerList } from "./models/operations/requestbodypostapplicationjsonmap.js";
import { RequestBodyPostApplicationJsonMapCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonmapcamelcase.js";
import { RequestBodyPostApplicationJsonMapOfArrayServerList } from "./models/operations/requestbodypostapplicationjsonmapofarray.js";
import { RequestBodyPostApplicationJsonMapOfArrayCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonmapofarraycamelcase.js";
import { RequestBodyPostApplicationJsonMapOfMapServerList } from "./models/operations/requestbodypostapplicationjsonmapofmap.js";
import { RequestBodyPostApplicationJsonMapOfMapCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonmapofmapcamelcase.js";
import { RequestBodyPostApplicationJsonMapOfMapOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonmapofmapofprimitive.js";
import { RequestBodyPostApplicationJsonMapOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonmapofprimitive.js";
import { RequestBodyReadAndWriteServerList } from "./models/operations/requestbodyreadandwrite.js";
import { RequestBodyReadOnlyInputServerList } from "./models/operations/requestbodyreadonlyinput.js";
import { RequestBodyReadOnlyUnionServerList } from "./models/operations/requestbodyreadonlyunion.js";
import { RequestBodyReadWriteOnlyUnionServerList } from "./models/operations/requestbodyreadwriteonlyunion.js";
import { RequestBodyWriteOnlyServerList } from "./models/operations/requestbodywriteonly.js";
import { RequestBodyWriteOnlyOutputServerList } from "./models/operations/requestbodywriteonlyoutput.js";
import { RequestBodyWriteOnlyUnionServerList } from "./models/operations/requestbodywriteonlyunion.js";
import * as shared from "./models/shared/index.js";
import { isBlobLike } from "./types/blobs.js";
import { Decimal as Decimal$ } from "./types/decimal.js";
import { unwrap as unwrap$ } from "./types/fp.js";
import { RFCDate } from "./types/rfcdate.js";
import * as z from "zod";

export class RequestBodies extends ClientSDK {
    async nullEnumPost(
        request: shared.ObjectWithNullEnums,
        options?: RequestOptions
    ): Promise<operations.NullEnumPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.ObjectWithNullEnums$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/nullEnum")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "nullEnumPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<operations.NullEnumPostRes, SDKError | SDKValidationError>(
            m$.json(200, operations.NullEnumPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async nullableObjectPost(
        request: shared.NullableObject | null,
        options?: RequestOptions
    ): Promise<operations.NullableObjectPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.nullable(shared.NullableObject$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/nullableRequiredObject")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "nullableObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.NullableObjectPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.NullableObjectPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async nullableOptionalFieldsPost(
        request: operations.NullableOptionalFieldsPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableOptionalFieldsPostResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.NullableOptionalFieldsPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/nullableOptionalFields")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "nullableOptionalFieldsPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.NullableOptionalFieldsPostResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.NullableOptionalFieldsPostResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async nullableRequiredEmptyObjectPost(
        request: operations.NullableRequiredEmptyObjectPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredEmptyObjectPostResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.NullableRequiredEmptyObjectPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/nullableRequiredEmptyObject")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "nullableRequiredEmptyObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.NullableRequiredEmptyObjectPostResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.NullableRequiredEmptyObjectPostResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async nullableRequiredPropertyPost(
        request: operations.NullableRequiredPropertyPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredPropertyPostResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.NullableRequiredPropertyPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/nullableRequiredProperty")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "nullableRequiredPropertyPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.NullableRequiredPropertyPostResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.NullableRequiredPropertyPostResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async nullableRequiredSharedObjectPost(
        request: operations.NullableRequiredSharedObjectPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredSharedObjectPostResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.NullableRequiredSharedObjectPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/nullableRequiredSharedObject")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "nullableRequiredSharedObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.NullableRequiredSharedObjectPostResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.NullableRequiredSharedObjectPostResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonArray(
        request: Array<shared.SimpleObject>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<shared.SimpleObject>> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(shared.SimpleObject$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonArrayServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#array")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<Array<shared.SimpleObject>, SDKError | SDKValidationError>(
            m$.json(200, z.array(shared.SimpleObject$inboundSchema)),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonArrayCamelCase(
        request: Array<shared.SimpleObjectCamelCase>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<shared.SimpleObjectCamelCase>> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(shared.SimpleObjectCamelCase$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonArrayCamelCaseServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#arrayCamelCase")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            Array<shared.SimpleObjectCamelCase>,
            SDKError | SDKValidationError
        >(
            m$.json(200, z.array(shared.SimpleObjectCamelCase$inboundSchema)),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonArrayObj(
        request: Array<shared.SimpleObject>,
        options?: RequestOptions
    ): Promise<shared.ArrObjValue> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(shared.SimpleObject$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc(
            "/anything/requestBodies/post/application/json/array/objResponse"
        )();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonArrayObj",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<shared.ArrObjValue, SDKError | SDKValidationError>(
            m$.json(200, shared.ArrObjValue$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonArrayObjCamelCase(
        request: Array<shared.SimpleObjectCamelCase>,
        options?: RequestOptions
    ): Promise<shared.ArrObjValueCamelCase> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(shared.SimpleObjectCamelCase$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc(
            "/anything/requestBodies/post/application/json/array/objResponseCamelCase"
        )();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonArrayObjCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            shared.ArrObjValueCamelCase,
            SDKError | SDKValidationError
        >(
            m$.json(200, shared.ArrObjValueCamelCase$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonArrayOfArray(
        request: Array<Array<shared.SimpleObject>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<Array<shared.SimpleObject>>> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(z.array(shared.SimpleObject$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonArrayOfArrayServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#arrayOfArrays")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            Array<Array<shared.SimpleObject>>,
            SDKError | SDKValidationError
        >(
            m$.json(200, z.array(z.array(shared.SimpleObject$inboundSchema))),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonArrayOfArrayCamelCase(
        request: Array<Array<shared.SimpleObjectCamelCase>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<Array<shared.SimpleObjectCamelCase>>> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(z.array(shared.SimpleObjectCamelCase$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonArrayOfArrayCamelCaseServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#arrayOfArraysCamelCase")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            Array<Array<shared.SimpleObjectCamelCase>>,
            SDKError | SDKValidationError
        >(
            m$.json(200, z.array(z.array(shared.SimpleObjectCamelCase$inboundSchema))),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonArrayOfArrayOfPrimitive(
        request: Array<Array<string>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<Array<string>>> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(z.array(z.string())).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#arrayOfArraysOfPrimitives")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArrayOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<Array<Array<string>>, SDKError | SDKValidationError>(
            m$.json(200, z.array(z.array(z.string()))),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonArrayOfMap(
        request: Array<{ [k: string]: shared.SimpleObject }>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<{ [k: string]: shared.SimpleObject }>> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(z.record(shared.SimpleObject$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonArrayOfMapServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#arrayOfMaps")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            Array<{ [k: string]: shared.SimpleObject }>,
            SDKError | SDKValidationError
        >(
            m$.json(200, z.array(z.record(shared.SimpleObject$inboundSchema))),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonArrayOfMapCamelCase(
        request: Array<{ [k: string]: shared.SimpleObjectCamelCase }>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<{ [k: string]: shared.SimpleObjectCamelCase }>> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z.array(z.record(shared.SimpleObjectCamelCase$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonArrayOfMapCamelCaseServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#arrayOfMapsCamelCase")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            Array<{ [k: string]: shared.SimpleObjectCamelCase }>,
            SDKError | SDKValidationError
        >(
            m$.json(200, z.array(z.record(shared.SimpleObjectCamelCase$inboundSchema))),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonArrayOfPrimitive(
        request: Array<string>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<string>> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(z.string()).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonArrayOfPrimitiveServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#arrayOfPrimitives")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<Array<string>, SDKError | SDKValidationError>(
            m$.json(200, z.array(z.string())),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonDeep(
        request: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonDeepRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.DeepObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/application/json/deep")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostApplicationJsonDeepRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostApplicationJsonDeepRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonDeepCamelCase(
        request: shared.DeepObjectCamelCase,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonDeepCamelCaseRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.DeepObjectCamelCase$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/application/json/deep/camelcase")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonDeepCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostApplicationJsonDeepCamelCaseRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostApplicationJsonDeepCamelCaseRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonMap(
        request: { [k: string]: shared.SimpleObject },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: shared.SimpleObject }> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(shared.SimpleObject$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonMapServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#map")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            { [k: string]: shared.SimpleObject },
            SDKError | SDKValidationError
        >(
            m$.json(200, z.record(shared.SimpleObject$inboundSchema)),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonMapCamelCase(
        request: { [k: string]: shared.SimpleObjectCamelCase },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: shared.SimpleObjectCamelCase }> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(shared.SimpleObjectCamelCase$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonMapCamelCaseServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#mapCamelCase")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            { [k: string]: shared.SimpleObjectCamelCase },
            SDKError | SDKValidationError
        >(
            m$.json(200, z.record(shared.SimpleObjectCamelCase$inboundSchema)),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonMapObj(
        request: { [k: string]: shared.SimpleObject },
        options?: RequestOptions
    ): Promise<shared.MapObjValue> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(shared.SimpleObject$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/application/json/map/objResponse")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonMapObj",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<shared.MapObjValue, SDKError | SDKValidationError>(
            m$.json(200, shared.MapObjValue$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonMapObjCamelCase(
        request: { [k: string]: shared.SimpleObjectCamelCase },
        options?: RequestOptions
    ): Promise<shared.MapObjValueCamelCase> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(shared.SimpleObjectCamelCase$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc(
            "/anything/requestBodies/post/application/json/map/objResponseCamelCase"
        )();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonMapObjCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            shared.MapObjValueCamelCase,
            SDKError | SDKValidationError
        >(
            m$.json(200, shared.MapObjValueCamelCase$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonMapOfArray(
        request: { [k: string]: Array<shared.SimpleObject> },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: Array<shared.SimpleObject> }> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(z.array(shared.SimpleObject$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonMapOfArrayServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#mapOfArrays")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            { [k: string]: Array<shared.SimpleObject> },
            SDKError | SDKValidationError
        >(
            m$.json(200, z.record(z.array(shared.SimpleObject$inboundSchema))),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonMapOfArrayCamelCase(
        request: { [k: string]: Array<shared.SimpleObjectCamelCase> },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: Array<shared.SimpleObjectCamelCase> }> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z.record(z.array(shared.SimpleObjectCamelCase$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonMapOfArrayCamelCaseServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#mapOfArraysCamelCase")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            { [k: string]: Array<shared.SimpleObjectCamelCase> },
            SDKError | SDKValidationError
        >(
            m$.json(200, z.record(z.array(shared.SimpleObjectCamelCase$inboundSchema))),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonMapOfMap(
        request: { [k: string]: { [k: string]: shared.SimpleObject } },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: { [k: string]: shared.SimpleObject } }> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(z.record(shared.SimpleObject$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonMapOfMapServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#mapOfMaps")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            { [k: string]: { [k: string]: shared.SimpleObject } },
            SDKError | SDKValidationError
        >(
            m$.json(200, z.record(z.record(shared.SimpleObject$inboundSchema))),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonMapOfMapCamelCase(
        request: { [k: string]: { [k: string]: shared.SimpleObjectCamelCase } },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: { [k: string]: shared.SimpleObjectCamelCase } }> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z.record(z.record(shared.SimpleObjectCamelCase$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonMapOfMapCamelCaseServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#mapOfMapsCamelCase")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            { [k: string]: { [k: string]: shared.SimpleObjectCamelCase } },
            SDKError | SDKValidationError
        >(
            m$.json(200, z.record(z.record(shared.SimpleObjectCamelCase$inboundSchema))),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonMapOfMapOfPrimitive(
        request: { [k: string]: { [k: string]: string } },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: { [k: string]: string } }> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(z.record(z.string())).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonMapOfMapOfPrimitiveServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#mapOfMapsOfPrimitives")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMapOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            { [k: string]: { [k: string]: string } },
            SDKError | SDKValidationError
        >(
            m$.json(200, z.record(z.record(z.string()))),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonMapOfPrimitive(
        request: { [k: string]: string },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: string }> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyPostApplicationJsonMapOfPrimitiveServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = pathToFunc("/requestbody#mapOfPrimitives")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<{ [k: string]: string }, SDKError | SDKValidationError>(
            m$.json(200, z.record(z.string())),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonMultipleJsonFiltered(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonMultipleJsonFilteredRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.SimpleObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc(
            "/anything/requestBodies/post/application/json/multiple/json/filtered"
        )();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            any: encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" }),
            bigint: encodeSimple$("bigint", payload$.bigint, {
                explode: false,
                charEncoding: "none",
            }),
            bigintStr: encodeSimple$("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            }),
            bool: encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" }),
            boolOpt: encodeSimple$("boolOpt", payload$.boolOpt, {
                explode: false,
                charEncoding: "none",
            }),
            date: encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" }),
            dateTime: encodeSimple$("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            }),
            decimal: encodeSimple$("decimal", payload$.decimal, {
                explode: false,
                charEncoding: "none",
            }),
            decimalStr: encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            }),
            enum: encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" }),
            float32: encodeSimple$("float32", payload$.float32, {
                explode: false,
                charEncoding: "none",
            }),
            float64Str: encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            }),
            int: encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" }),
            int32: encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" }),
            int32Enum: encodeSimple$("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            }),
            int64Str: encodeSimple$("int64Str", payload$.int64Str, {
                explode: false,
                charEncoding: "none",
            }),
            intEnum: encodeSimple$("intEnum", payload$.intEnum, {
                explode: false,
                charEncoding: "none",
            }),
            intOptNull: encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            num: encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" }),
            numOptNull: encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            str: encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" }),
            strOpt: encodeSimple$("strOpt", payload$.strOpt, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonMultipleJsonFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostApplicationJsonMultipleJsonFilteredRes,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostApplicationJsonMultipleJsonFilteredRes$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonSimple(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonSimpleRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.SimpleObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/application/json/simple")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            any: encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" }),
            bigint: encodeSimple$("bigint", payload$.bigint, {
                explode: false,
                charEncoding: "none",
            }),
            bigintStr: encodeSimple$("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            }),
            bool: encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" }),
            boolOpt: encodeSimple$("boolOpt", payload$.boolOpt, {
                explode: false,
                charEncoding: "none",
            }),
            date: encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" }),
            dateTime: encodeSimple$("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            }),
            decimal: encodeSimple$("decimal", payload$.decimal, {
                explode: false,
                charEncoding: "none",
            }),
            decimalStr: encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            }),
            enum: encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" }),
            float32: encodeSimple$("float32", payload$.float32, {
                explode: false,
                charEncoding: "none",
            }),
            float64Str: encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            }),
            int: encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" }),
            int32: encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" }),
            int32Enum: encodeSimple$("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            }),
            int64Str: encodeSimple$("int64Str", payload$.int64Str, {
                explode: false,
                charEncoding: "none",
            }),
            intEnum: encodeSimple$("intEnum", payload$.intEnum, {
                explode: false,
                charEncoding: "none",
            }),
            intOptNull: encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            num: encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" }),
            numOptNull: encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            str: encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" }),
            strOpt: encodeSimple$("strOpt", payload$.strOpt, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostApplicationJsonSimpleRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostApplicationJsonSimpleRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostApplicationJsonSimpleCamelCase(
        request: shared.SimpleObjectCamelCase,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonSimpleCamelCaseRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.SimpleObjectCamelCase$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/application/json/camelcase")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostApplicationJsonSimpleCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostApplicationJsonSimpleCamelCaseRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostApplicationJsonSimpleCamelCaseRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostComplexNumberTypes(
        request: operations.RequestBodyPostComplexNumberTypesRequest,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostComplexNumberTypesResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPostComplexNumberTypesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.complexNumberTypes, { explode: true });

        const pathParams$ = {
            pathBigInt: encodeSimple$("pathBigInt", payload$.pathBigInt, {
                explode: false,
                charEncoding: "percent",
            }),
            pathBigIntStr: encodeSimple$("pathBigIntStr", payload$.pathBigIntStr, {
                explode: false,
                charEncoding: "percent",
            }),
            pathDecimal: encodeSimple$("pathDecimal", payload$.pathDecimal, {
                explode: false,
                charEncoding: "percent",
            }),
            pathDecimalStr: encodeSimple$("pathDecimalStr", payload$.pathDecimalStr, {
                explode: false,
                charEncoding: "percent",
            }),
        };

        const path$ = pathToFunc(
            "/anything/requestBodies/post/{pathBigInt}/{pathBigIntStr}/{pathDecimal}/{pathDecimalStr}/complex-number-types"
        )(pathParams$);

        const query$ = encodeFormQuery$({
            queryBigInt: payload$.queryBigInt,
            queryBigIntStr: payload$.queryBigIntStr,
            queryDecimal: payload$.queryDecimal,
            queryDecimalStr: payload$.queryDecimalStr,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostComplexNumberTypes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostComplexNumberTypesResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostComplexNumberTypesResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostDefaultsAndConsts(
        request: shared.DefaultsAndConsts,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostDefaultsAndConstsResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.DefaultsAndConsts$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/defaultsAndConsts")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostDefaultsAndConsts",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostDefaultsAndConstsResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostDefaultsAndConstsResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostEmptyObject(
        request: operations.RequestBodyPostEmptyObjectRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostEmptyObjectResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPostEmptyObjectRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/empty-object")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostEmptyObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostEmptyObjectResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostEmptyObjectResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostFormDeep(
        request: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormDeepRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.DeepObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = pathToFunc("/anything/requestBodies/post/form/deep")();

        const headers$ = new Headers({
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostFormDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostFormDeepRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostFormDeepRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostFormMapPrimitive(
        request: { [k: string]: string },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormMapPrimitiveRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = pathToFunc("/anything/requestBodies/post/form/map/primitive")();

        const headers$ = new Headers({
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostFormMapPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostFormMapPrimitiveRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostFormMapPrimitiveRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostFormSimple(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormSimpleRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.SimpleObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = pathToFunc("/anything/requestBodies/post/form/simple")();

        const headers$ = new Headers({
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
            any: encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" }),
            bigint: encodeSimple$("bigint", payload$.bigint, {
                explode: false,
                charEncoding: "none",
            }),
            bigintStr: encodeSimple$("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            }),
            bool: encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" }),
            boolOpt: encodeSimple$("boolOpt", payload$.boolOpt, {
                explode: false,
                charEncoding: "none",
            }),
            date: encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" }),
            dateTime: encodeSimple$("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            }),
            decimal: encodeSimple$("decimal", payload$.decimal, {
                explode: false,
                charEncoding: "none",
            }),
            decimalStr: encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            }),
            enum: encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" }),
            float32: encodeSimple$("float32", payload$.float32, {
                explode: false,
                charEncoding: "none",
            }),
            float64Str: encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            }),
            int: encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" }),
            int32: encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" }),
            int32Enum: encodeSimple$("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            }),
            int64Str: encodeSimple$("int64Str", payload$.int64Str, {
                explode: false,
                charEncoding: "none",
            }),
            intEnum: encodeSimple$("intEnum", payload$.intEnum, {
                explode: false,
                charEncoding: "none",
            }),
            intOptNull: encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            num: encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" }),
            numOptNull: encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            str: encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" }),
            strOpt: encodeSimple$("strOpt", payload$.strOpt, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostFormSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostFormSimpleRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostFormSimpleRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesArrayBigInt(
        request: Array<bigint>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayBigIntResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(z.bigint().transform((v) => Number(v))).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/array/bigInt")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayBigInt",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesArrayBigIntResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostJsonDataTypesArrayBigIntResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesArrayDate(
        request: Array<RFCDate>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayDateResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(z.instanceof(RFCDate).transform((v) => v.toString())).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/array/date")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayDate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesArrayDateResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostJsonDataTypesArrayDateResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesArrayDecimalStr(
        request: Array<Decimal$ | number>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayDecimalStrResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z
                    .array(z.union([z.instanceof(Decimal$), z.number()]).transform((v) => `${v}`))
                    .parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/array/decimalStr")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayDecimalStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesArrayDecimalStrResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostJsonDataTypesArrayDecimalStrResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesBigInt(
        request: bigint,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBigIntResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z
                    .bigint()
                    .transform((v) => Number(v))
                    .parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/bigint")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesBigInt",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesBigIntResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostJsonDataTypesBigIntResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesBigIntStr(
        request: bigint,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBigIntStrResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z
                    .bigint()
                    .transform((v) => `${v}`)
                    .parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/bigintStr")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesBigIntStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesBigIntStrResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostJsonDataTypesBigIntStrResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesBoolean(
        request: boolean,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBooleanResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.boolean().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/boolean")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesBoolean",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesBooleanResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostJsonDataTypesBooleanResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesComplexNumberArrays(
        request: shared.ComplexNumberArrays,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesComplexNumberArraysRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.ComplexNumberArrays$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc(
            "/anything/requestBodies/post/jsonDataTypes/complexNumberArrays"
        )();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesComplexNumberArrays",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesComplexNumberArraysRes,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostJsonDataTypesComplexNumberArraysRes$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesComplexNumberMaps(
        request: shared.ComplexNumberMaps,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesComplexNumberMapsRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.ComplexNumberMaps$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/complexNumberMaps")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesComplexNumberMaps",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesComplexNumberMapsRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostJsonDataTypesComplexNumberMapsRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesDate(
        request: RFCDate,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDateResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z
                    .instanceof(RFCDate)
                    .transform((v) => v.toString())
                    .parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/date")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesDate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesDateResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostJsonDataTypesDateResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesDateTime(
        request: Date,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDateTimeResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z
                    .date()
                    .transform((v) => v.toISOString())
                    .parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/dateTime")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesDateTime",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesDateTimeResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostJsonDataTypesDateTimeResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesDecimal(
        request: Decimal$ | number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDecimalResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z
                    .union([z.instanceof(Decimal$), z.number()])
                    .transform((v) => (typeof v === "number" ? v : v.toNumber()))
                    .parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/decimal")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesDecimal",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesDecimalResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostJsonDataTypesDecimalResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesDecimalStr(
        request: Decimal$ | number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDecimalStrResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z
                    .union([z.instanceof(Decimal$), z.number()])
                    .transform((v) => `${v}`)
                    .parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/decimalStr")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesDecimalStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesDecimalStrResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostJsonDataTypesDecimalStrResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesFloat32(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesFloat32ResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.number().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/float32")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesFloat32",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesFloat32ResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostJsonDataTypesFloat32ResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesInt32(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesInt32ResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.number().int().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/int32")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesInt32",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesInt32ResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostJsonDataTypesInt32ResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesInteger(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesIntegerResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.number().int().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/integer")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesInteger",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesIntegerResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostJsonDataTypesIntegerResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesMapBigIntStr(
        request: { [k: string]: bigint },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapBigIntStrResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(z.bigint().transform((v) => `${v}`)).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/map/bigIntStr")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesMapBigIntStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesMapBigIntStrResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostJsonDataTypesMapBigIntStrResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesMapDateTime(
        request: { [k: string]: Date },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapDateTimeResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(z.date().transform((v) => v.toISOString())).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/map/dateTime")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesMapDateTime",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesMapDateTimeResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostJsonDataTypesMapDateTimeResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesMapDecimal(
        request: { [k: string]: Decimal$ | number },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapDecimalResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z
                    .record(
                        z
                            .union([z.instanceof(Decimal$), z.number()])
                            .transform((v) => (typeof v === "number" ? v : v.toNumber()))
                    )
                    .parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/map/decimal")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesMapDecimal",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesMapDecimalResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostJsonDataTypesMapDecimalResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesNumber(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesNumberResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.number().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/number")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesNumber",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesNumberResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostJsonDataTypesNumberResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostJsonDataTypesString(
        request: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesStringResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.string().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/jsonDataTypes/string")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostJsonDataTypesString",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostJsonDataTypesStringResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostJsonDataTypesStringResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostMultipleContentTypesComponentFiltered(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesComponentFilteredRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.SimpleObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc(
            "/anything/requestBodies/post/multiple/contentTypes/component/filtered"
        )();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            any: encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" }),
            bigint: encodeSimple$("bigint", payload$.bigint, {
                explode: false,
                charEncoding: "none",
            }),
            bigintStr: encodeSimple$("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            }),
            bool: encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" }),
            boolOpt: encodeSimple$("boolOpt", payload$.boolOpt, {
                explode: false,
                charEncoding: "none",
            }),
            date: encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" }),
            dateTime: encodeSimple$("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            }),
            decimal: encodeSimple$("decimal", payload$.decimal, {
                explode: false,
                charEncoding: "none",
            }),
            decimalStr: encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            }),
            enum: encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" }),
            float32: encodeSimple$("float32", payload$.float32, {
                explode: false,
                charEncoding: "none",
            }),
            float64Str: encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            }),
            int: encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" }),
            int32: encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" }),
            int32Enum: encodeSimple$("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            }),
            int64Str: encodeSimple$("int64Str", payload$.int64Str, {
                explode: false,
                charEncoding: "none",
            }),
            intEnum: encodeSimple$("intEnum", payload$.intEnum, {
                explode: false,
                charEncoding: "none",
            }),
            intOptNull: encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            num: encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" }),
            numOptNull: encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            str: encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" }),
            strOpt: encodeSimple$("strOpt", payload$.strOpt, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostMultipleContentTypesComponentFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostMultipleContentTypesComponentFilteredRes,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostMultipleContentTypesComponentFilteredRes$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostMultipleContentTypesInlineFiltered(
        request: operations.RequestBodyPostMultipleContentTypesInlineFilteredRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesInlineFilteredRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesInlineFilteredRequestBody$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc(
            "/anything/requestBodies/post/multiple/contentTypes/inline/filtered"
        )();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostMultipleContentTypesInlineFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostMultipleContentTypesInlineFilteredRes,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostMultipleContentTypesInlineFilteredRes$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostMultipleContentTypesSplitParamForm(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamFormRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamFormRes> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamFormRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamFormRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = Object.entries(payload$.RequestBody || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = pathToFunc(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = encodeFormQuery$({
            paramStr: payload$.paramStr,
        });

        const headers$ = new Headers({
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_form",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostMultipleContentTypesSplitParamFormRes,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostMultipleContentTypesSplitParamFormRes$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostMultipleContentTypesSplitParamJson(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamJsonRes> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const path$ = pathToFunc(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = encodeFormQuery$({
            paramStr: payload$.paramStr,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_json",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostMultipleContentTypesSplitParamJsonRes,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostMultipleContentTypesSplitParamJsonRes$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostMultipleContentTypesSplitParamMultipart(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRes> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = new FormData();

        body$.append("bool2", String(payload$.RequestBody.bool2));
        body$.append("num2", String(payload$.RequestBody.num2));
        body$.append("str2", payload$.RequestBody.str2);

        const path$ = pathToFunc(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = encodeFormQuery$({
            paramStr: payload$.paramStr,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_multipart",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRes,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRes$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostMultipleContentTypesSplitForm(
        request: operations.RequestBodyPostMultipleContentTypesSplitFormRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitFormRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitFormRequestBody$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = pathToFunc("/anything/requestBodies/post/multiple/contentTypes/split")();

        const headers$ = new Headers({
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_form",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostMultipleContentTypesSplitFormRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostMultipleContentTypesSplitFormRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostMultipleContentTypesSplitJson(
        request: operations.RequestBodyPostMultipleContentTypesSplitJsonRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitJsonRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitJsonRequestBody$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/multiple/contentTypes/split")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_json",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostMultipleContentTypesSplitJsonRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostMultipleContentTypesSplitJsonRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostMultipleContentTypesSplitMultipart(
        request: operations.RequestBodyPostMultipleContentTypesSplitMultipartRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitMultipartRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitMultipartRequestBody$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = new FormData();

        body$.append("bool2", String(payload$.bool2));
        body$.append("num2", String(payload$.num2));
        body$.append("str2", payload$.str2);

        const path$ = pathToFunc("/anything/requestBodies/post/multiple/contentTypes/split")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_multipart",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostMultipleContentTypesSplitMultipartRes,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostMultipleContentTypesSplitMultipartRes$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostNotNullableNotRequiredStringBody(
        request?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNotNullableNotRequiredStringBodyResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.string().optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/notnullable/notrequired/string")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostNotNullableNotRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostNotNullableNotRequiredStringBodyResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostNotNullableNotRequiredStringBodyResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostNullArray(
        request: Array<string>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullArrayResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.array(z.string()).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/null-array")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostNullArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostNullArrayResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostNullArrayResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostNullDictionary(
        request: { [k: string]: string },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullDictionaryResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/null-dictionary")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostNullDictionary",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostNullDictionaryResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPostNullDictionaryResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostNullableNotRequiredStringBody(
        request?: string | null | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullableNotRequiredStringBodyResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.nullable(z.string()).optional().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/nullable/notrequired/string")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostNullableNotRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostNullableNotRequiredStringBodyResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostNullableNotRequiredStringBodyResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPostNullableRequiredStringBody(
        request: string | null,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullableRequiredStringBodyResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.nullable(z.string()).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/requestBodies/post/nullable/required/string")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPostNullableRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPostNullableRequiredStringBodyResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.RequestBodyPostNullableRequiredStringBodyResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPutBytes(
        request: Uint8Array | string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutBytesRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => b64$.zodOutbound.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = payload$;

        const path$ = pathToFunc("/anything/requestBodies/put/bytes")();

        const headers$ = new Headers({
            "Content-Type": "application/octet-stream",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPutBytes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPutBytesRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPutBytesRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPutBytesWithParams(
        requestBody: Uint8Array | string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutBytesWithParamsRes> {
        const input$: operations.RequestBodyPutBytesWithParamsRequest = {
            requestBody: requestBody,
            queryStringParam: queryStringParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPutBytesWithParamsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = payload$.RequestBody;

        const path$ = pathToFunc("/anything/requestBodies/put/bytesWithParams")();

        const query$ = encodeFormQuery$({
            queryStringParam: payload$.queryStringParam,
        });

        const headers$ = new Headers({
            "Content-Type": "application/octet-stream",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPutBytesWithParams",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPutBytesWithParamsRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPutBytesWithParamsRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPutMultipartDeep(
        request: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartDeepRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.DeepObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = new FormData();

        body$.append("any", encodeJSON$("any", payload$.any, { explode: true }));
        body$.append("arr", encodeJSON$("arr", payload$.arr, { explode: true }));
        body$.append("bool", String(payload$.bool));
        body$.append("int", String(payload$.int));
        body$.append("map", encodeJSON$("map", payload$.map, { explode: true }));
        body$.append("num", String(payload$.num));
        body$.append("obj", encodeJSON$("obj", payload$.obj, { explode: true }));
        body$.append("str", payload$.str);
        if (payload$.type !== undefined) {
            body$.append("type", payload$.type);
        }

        const path$ = pathToFunc("/anything/requestBodies/put/multipart/deep")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPutMultipartDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPutMultipartDeepRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPutMultipartDeepRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPutMultipartDifferentFileName(
        request: operations.RequestBodyPutMultipartDifferentFileNameRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartDifferentFileNameRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPutMultipartDifferentFileNameRequestBody$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = new FormData();

        if (payload$.differentFileName !== undefined) {
            if (isBlobLike(payload$.differentFileName)) {
                body$.append("differentFileName", payload$.differentFileName);
            } else {
                body$.append(
                    "differentFileName",
                    new Blob([payload$.differentFileName.content], {
                        type: "application/octet-stream",
                    }),
                    payload$.differentFileName.fileName
                );
            }
        }

        const path$ = pathToFunc("/anything/requestBodies/put/multipart/differentFileName")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPutMultipartDifferentFileName",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPutMultipartDifferentFileNameRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPutMultipartDifferentFileNameRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPutMultipartFile(
        request: operations.RequestBodyPutMultipartFileRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartFileRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPutMultipartFileRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = new FormData();

        if (payload$.file !== undefined) {
            if (isBlobLike(payload$.file)) {
                body$.append("file", payload$.file);
            } else {
                body$.append(
                    "file",
                    new Blob([payload$.file.content], { type: "application/octet-stream" }),
                    payload$.file.fileName
                );
            }
        }

        const path$ = pathToFunc("/anything/requestBodies/put/multipart/file")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPutMultipartFile",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPutMultipartFileRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPutMultipartFileRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPutMultipartOptionalRequestBody(
        request?: operations.RequestBodyPutMultipartOptionalRequestBodyRequestBody | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartOptionalRequestBodyRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPutMultipartOptionalRequestBodyRequestBody$outboundSchema.optional().parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = new FormData();
        if (payload$ != null) {
            if (payload$?.sampleField !== undefined) {
                body$.append("sampleField", payload$?.sampleField);
            }
            if (payload$?.sampleFile !== undefined) {
                if (isBlobLike(payload$?.sampleFile)) {
                    body$.append("sampleFile", payload$?.sampleFile);
                } else {
                    body$.append(
                        "sampleFile",
                        new Blob([payload$?.sampleFile.content], {
                            type: "application/octet-stream",
                        }),
                        payload$?.sampleFile.fileName
                    );
                }
            }
        }

        const path$ = pathToFunc("/anything/requestBodies/put/multipart/optionalRequestBody")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPutMultipartOptionalRequestBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPutMultipartOptionalRequestBodyRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPutMultipartOptionalRequestBodyRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPutMultipartSimple(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartSimpleRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.SimpleObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = new FormData();

        body$.append("bool", String(payload$.bool));
        body$.append("date", payload$.date);
        body$.append("dateTime", payload$.dateTime);
        body$.append("enum", payload$.enum);
        body$.append("float32", String(payload$.float32));
        body$.append("int", String(payload$.int));
        body$.append("int32", String(payload$.int32));
        body$.append("int32Enum", String(payload$.int32Enum));
        body$.append("intEnum", String(payload$.intEnum));
        body$.append("num", String(payload$.num));
        body$.append("str", payload$.str);
        if (payload$.any !== undefined) {
            body$.append("any", String(payload$.any));
        }
        if (payload$.bigint !== undefined) {
            body$.append("bigint", String(payload$.bigint));
        }
        if (payload$.bigintStr !== undefined) {
            body$.append("bigintStr", payload$.bigintStr);
        }
        if (payload$.boolOpt !== undefined) {
            body$.append("boolOpt", String(payload$.boolOpt));
        }
        if (payload$.decimal !== undefined) {
            body$.append("decimal", String(payload$.decimal));
        }
        if (payload$.decimalStr !== undefined) {
            body$.append("decimalStr", payload$.decimalStr);
        }
        if (payload$.float64Str !== undefined) {
            body$.append("float64Str", payload$.float64Str);
        }
        if (payload$.int64Str !== undefined) {
            body$.append("int64Str", payload$.int64Str);
        }
        if (payload$.intOptNull !== undefined) {
            body$.append("intOptNull", String(payload$.intOptNull));
        }
        if (payload$.numOptNull !== undefined) {
            body$.append("numOptNull", String(payload$.numOptNull));
        }
        if (payload$.strOpt !== undefined) {
            body$.append("strOpt", payload$.strOpt);
        }

        const path$ = pathToFunc("/anything/requestBodies/put/multipart/simple")();

        const headers$ = new Headers({
            Accept: "application/json",
            any: encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" }),
            bigint: encodeSimple$("bigint", payload$.bigint, {
                explode: false,
                charEncoding: "none",
            }),
            bigintStr: encodeSimple$("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            }),
            bool: encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" }),
            boolOpt: encodeSimple$("boolOpt", payload$.boolOpt, {
                explode: false,
                charEncoding: "none",
            }),
            date: encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" }),
            dateTime: encodeSimple$("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            }),
            decimal: encodeSimple$("decimal", payload$.decimal, {
                explode: false,
                charEncoding: "none",
            }),
            decimalStr: encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            }),
            enum: encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" }),
            float32: encodeSimple$("float32", payload$.float32, {
                explode: false,
                charEncoding: "none",
            }),
            float64Str: encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            }),
            int: encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" }),
            int32: encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" }),
            int32Enum: encodeSimple$("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            }),
            int64Str: encodeSimple$("int64Str", payload$.int64Str, {
                explode: false,
                charEncoding: "none",
            }),
            intEnum: encodeSimple$("intEnum", payload$.intEnum, {
                explode: false,
                charEncoding: "none",
            }),
            intOptNull: encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            num: encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" }),
            numOptNull: encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            str: encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" }),
            strOpt: encodeSimple$("strOpt", payload$.strOpt, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPutMultipartSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPutMultipartSimpleRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPutMultipartSimpleRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPutString(
        request: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutStringRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.string().parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = payload$;

        const path$ = pathToFunc("/anything/requestBodies/put/string")();

        const headers$ = new Headers({
            "Content-Type": "text/plain",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPutString",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPutStringRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPutStringRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyPutStringWithParams(
        requestBody: string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutStringWithParamsRes> {
        const input$: operations.RequestBodyPutStringWithParamsRequest = {
            requestBody: requestBody,
            queryStringParam: queryStringParam,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.RequestBodyPutStringWithParamsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = payload$.RequestBody;

        const path$ = pathToFunc("/anything/requestBodies/put/stringWithParams")();

        const query$ = encodeFormQuery$({
            queryStringParam: payload$.queryStringParam,
        });

        const headers$ = new Headers({
            "Content-Type": "text/plain",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyPutStringWithParams",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.RequestBodyPutStringWithParamsRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.RequestBodyPutStringWithParamsRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyReadAndWrite(
        request: shared.ReadWriteObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.ReadWriteObjectOutput> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.ReadWriteObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyReadAndWriteServerList[0], { charEncoding: "percent" })();

        const path$ = pathToFunc("/readonlyandwriteonly")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyReadAndWrite",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            shared.ReadWriteObjectOutput,
            SDKError | SDKValidationError
        >(
            m$.json(200, shared.ReadWriteObjectOutput$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyReadOnlyInput(
        request: shared.ReadOnlyObjectInput,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.ReadOnlyObject> {
        const input$ = request;
        void input$; // request input is unused

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyReadOnlyInputServerList[0], { charEncoding: "percent" })();

        const path$ = pathToFunc("/readonlyorwriteonly#readOnlyInput")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyReadOnlyInput",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<shared.ReadOnlyObject, SDKError | SDKValidationError>(
            m$.json(200, shared.ReadOnlyObject$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyReadOnlyUnion(
        request: shared.WeaklyTypedOneOfReadOnlyObjectInput,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.WeaklyTypedOneOfReadOnlyObject> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.WeaklyTypedOneOfReadOnlyObjectInput$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyReadOnlyUnionServerList[0], { charEncoding: "percent" })();

        const path$ = pathToFunc("/readonlyorwriteonly#readOnlyUnion")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyReadOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            shared.WeaklyTypedOneOfReadOnlyObject,
            SDKError | SDKValidationError
        >(
            m$.json(200, shared.WeaklyTypedOneOfReadOnlyObject$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyReadWriteOnlyUnion(
        request: shared.WeaklyTypedOneOfReadWriteObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.WeaklyTypedOneOfReadWriteObjectOutput> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.WeaklyTypedOneOfReadWriteObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyReadWriteOnlyUnionServerList[0], { charEncoding: "percent" })();

        const path$ = pathToFunc("/readonlyandwriteonly#readWriteOnlyUnion")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyReadWriteOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            shared.WeaklyTypedOneOfReadWriteObjectOutput,
            SDKError | SDKValidationError
        >(
            m$.json(200, shared.WeaklyTypedOneOfReadWriteObjectOutput$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyWriteOnly(
        request: shared.WriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.ReadOnlyObject> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.WriteOnlyObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyWriteOnlyServerList[0], { charEncoding: "percent" })();

        const path$ = pathToFunc("/readonlyorwriteonly#writeOnly")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyWriteOnly",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<shared.ReadOnlyObject, SDKError | SDKValidationError>(
            m$.json(200, shared.ReadOnlyObject$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyWriteOnlyOutput(
        request: shared.WriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.WriteOnlyObjectOutput> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.WriteOnlyObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyWriteOnlyOutputServerList[0], { charEncoding: "percent" })();

        const path$ = pathToFunc("/writeonlyoutput#writeOnlyOutput")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyWriteOnlyOutput",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            shared.WriteOnlyObjectOutput,
            SDKError | SDKValidationError
        >(
            m$.json(200, shared.WriteOnlyObjectOutput$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async requestBodyWriteOnlyUnion(
        request: shared.WeaklyTypedOneOfWriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.WeaklyTypedOneOfWriteOnlyObjectOutput> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.WeaklyTypedOneOfWriteOnlyObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(RequestBodyWriteOnlyUnionServerList[0], { charEncoding: "percent" })();

        const path$ = pathToFunc("/writeonlyoutput#writeOnlyUnion")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "requestBodyWriteOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            shared.WeaklyTypedOneOfWriteOnlyObjectOutput,
            SDKError | SDKValidationError
        >(
            m$.json(200, shared.WeaklyTypedOneOfWriteOnlyObjectOutput$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }
}
