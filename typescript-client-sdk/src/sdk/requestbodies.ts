/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import * as b64$ from "../lib/base64.js";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeBodyForm as encodeBodyForm$,
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeSimple as encodeSimple$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "./models/operations/index.js";
import { RequestBodyPostApplicationJsonArrayServerList } from "./models/operations/requestbodypostapplicationjsonarray.js";
import { RequestBodyPostApplicationJsonArrayCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonarraycamelcase.js";
import { RequestBodyPostApplicationJsonArrayOfArrayServerList } from "./models/operations/requestbodypostapplicationjsonarrayofarray.js";
import { RequestBodyPostApplicationJsonArrayOfArrayCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonarrayofarraycamelcase.js";
import { RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonarrayofarrayofprimitive.js";
import { RequestBodyPostApplicationJsonArrayOfMapServerList } from "./models/operations/requestbodypostapplicationjsonarrayofmap.js";
import { RequestBodyPostApplicationJsonArrayOfMapCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonarrayofmapcamelcase.js";
import { RequestBodyPostApplicationJsonArrayOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonarrayofprimitive.js";
import { RequestBodyPostApplicationJsonMapServerList } from "./models/operations/requestbodypostapplicationjsonmap.js";
import { RequestBodyPostApplicationJsonMapCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonmapcamelcase.js";
import { RequestBodyPostApplicationJsonMapOfArrayServerList } from "./models/operations/requestbodypostapplicationjsonmapofarray.js";
import { RequestBodyPostApplicationJsonMapOfArrayCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonmapofarraycamelcase.js";
import { RequestBodyPostApplicationJsonMapOfMapServerList } from "./models/operations/requestbodypostapplicationjsonmapofmap.js";
import { RequestBodyPostApplicationJsonMapOfMapCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonmapofmapcamelcase.js";
import { RequestBodyPostApplicationJsonMapOfMapOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonmapofmapofprimitive.js";
import { RequestBodyPostApplicationJsonMapOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonmapofprimitive.js";
import { RequestBodyReadAndWriteServerList } from "./models/operations/requestbodyreadandwrite.js";
import { RequestBodyReadOnlyInputServerList } from "./models/operations/requestbodyreadonlyinput.js";
import { RequestBodyReadOnlyUnionServerList } from "./models/operations/requestbodyreadonlyunion.js";
import { RequestBodyReadWriteOnlyUnionServerList } from "./models/operations/requestbodyreadwriteonlyunion.js";
import { RequestBodyWriteOnlyServerList } from "./models/operations/requestbodywriteonly.js";
import { RequestBodyWriteOnlyOutputServerList } from "./models/operations/requestbodywriteonlyoutput.js";
import { RequestBodyWriteOnlyUnionServerList } from "./models/operations/requestbodywriteonlyunion.js";
import * as shared from "./models/shared/index.js";
import { isBlobLike } from "./types/blobs.js";
import { Decimal as Decimal$ } from "./types/decimal.js";
import { RFCDate } from "./types/rfcdate.js";
import * as z from "zod";

export class RequestBodies extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    async nullEnumPost(
        request: shared.ObjectWithNullEnums,
        options?: RequestOptions
    ): Promise<operations.NullEnumPostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ObjectWithNullEnums$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/nullEnum")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullEnumPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.NullEnumPostResponse>()
            .json(200, operations.NullEnumPostResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async nullableObjectPost(
        request: shared.NullableObject | null,
        options?: RequestOptions
    ): Promise<operations.NullableObjectPostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.nullable(shared.NullableObject$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredObject"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.NullableObjectPostResponse>()
            .json(200, operations.NullableObjectPostResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async nullableRequiredEmptyObjectPost(
        request: operations.NullableRequiredEmptyObjectPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredEmptyObjectPostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.NullableRequiredEmptyObjectPostRequestBody$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredEmptyObject"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableRequiredEmptyObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.NullableRequiredEmptyObjectPostResponse>()
            .json(200, operations.NullableRequiredEmptyObjectPostResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async nullableRequiredPropertyPost(
        request: operations.NullableRequiredPropertyPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredPropertyPostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.NullableRequiredPropertyPostRequestBody$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredProperty"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableRequiredPropertyPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.NullableRequiredPropertyPostResponse>()
            .json(200, operations.NullableRequiredPropertyPostResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async nullableRequiredSharedObjectPost(
        request: operations.NullableRequiredSharedObjectPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredSharedObjectPostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.NullableRequiredSharedObjectPostRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredSharedObject"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableRequiredSharedObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.NullableRequiredSharedObjectPostResponse>()
            .json(200, operations.NullableRequiredSharedObjectPostResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonArray(
        request: Array<shared.SimpleObject>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(shared.SimpleObject$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonArrayServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#array")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonArrayResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonArrayResponse$, { key: "res" })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonArrayCamelCase(
        request: Array<shared.SimpleObjectCamelCase>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayCamelCaseResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(shared.SimpleObjectCamelCase$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonArrayCamelCaseServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#arrayCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonArrayCamelCaseResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonArrayCamelCaseResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonArrayObj(
        request: Array<shared.SimpleObject>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonArrayObjResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(shared.SimpleObject$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/array/objResponse"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayObj",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonArrayObjResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonArrayObjResponse$, {
                    key: "arrObjValue",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonArrayObjCamelCase(
        request: Array<shared.SimpleObjectCamelCase>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonArrayObjCamelCaseResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(shared.SimpleObjectCamelCase$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/array/objResponseCamelCase"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayObjCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonArrayObjCamelCaseResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonArrayObjCamelCaseResponse$, {
                    key: "arrObjValueCamelCase",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfArray(
        request: Array<Array<shared.SimpleObject>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfArrayResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.array(shared.SimpleObject$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonArrayOfArrayServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#arrayOfArrays")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonArrayOfArrayResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonArrayOfArrayResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfArrayCamelCase(
        request: Array<Array<shared.SimpleObjectCamelCase>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfArrayCamelCaseResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z.array(z.array(shared.SimpleObjectCamelCase$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonArrayOfArrayCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfArraysCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonArrayOfArrayCamelCaseResponse>()
                .json(
                    200,
                    operations.RequestBodyPostApplicationJsonArrayOfArrayCamelCaseResponse$,
                    { key: "res" }
                )
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfArrayOfPrimitive(
        request: Array<Array<string>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.array(z.string())).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfArraysOfPrimitives")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArrayOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveResponse>()
                .json(
                    200,
                    operations.RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveResponse$,
                    { key: "res" }
                )
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfMap(
        request: Array<{ [k: string]: shared.SimpleObject }>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfMapResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.record(shared.SimpleObject$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonArrayOfMapServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#arrayOfMaps")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonArrayOfMapResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonArrayOfMapResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfMapCamelCase(
        request: Array<{ [k: string]: shared.SimpleObjectCamelCase }>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfMapCamelCaseResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z.array(z.record(shared.SimpleObjectCamelCase$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonArrayOfMapCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfMapsCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonArrayOfMapCamelCaseResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonArrayOfMapCamelCaseResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfPrimitive(
        request: Array<string>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfPrimitiveResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonArrayOfPrimitiveServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#arrayOfPrimitives")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonArrayOfPrimitiveResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonArrayOfPrimitiveResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonDeep(
        request: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonDeepResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DeepObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/deep"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonDeepResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonDeepResponse$, { key: "res" })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonDeepCamelCase(
        request: shared.DeepObjectCamelCase,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonDeepCamelCaseResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DeepObjectCamelCase$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/deep/camelcase"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonDeepCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonDeepCamelCaseResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonDeepCamelCaseResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonMap(
        request: { [k: string]: shared.SimpleObject },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(shared.SimpleObject$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonMapServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#map")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPostApplicationJsonMapResponse>()
            .json(200, operations.RequestBodyPostApplicationJsonMapResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonMapCamelCase(
        request: { [k: string]: shared.SimpleObjectCamelCase },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapCamelCaseResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(shared.SimpleObjectCamelCase$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonMapCamelCaseServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#mapCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonMapCamelCaseResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonMapCamelCaseResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonMapObj(
        request: { [k: string]: shared.SimpleObject },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonMapObjResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(shared.SimpleObject$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/map/objResponse"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapObj",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonMapObjResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonMapObjResponse$, {
                    key: "mapObjValue",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonMapObjCamelCase(
        request: { [k: string]: shared.SimpleObjectCamelCase },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonMapObjCamelCaseResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(shared.SimpleObjectCamelCase$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/map/objResponseCamelCase"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapObjCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonMapObjCamelCaseResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonMapObjCamelCaseResponse$, {
                    key: "mapObjValueCamelCase",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfArray(
        request: { [k: string]: Array<shared.SimpleObject> },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfArrayResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.array(shared.SimpleObject$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonMapOfArrayServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#mapOfArrays")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonMapOfArrayResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonMapOfArrayResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfArrayCamelCase(
        request: { [k: string]: Array<shared.SimpleObjectCamelCase> },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfArrayCamelCaseResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z.record(z.array(shared.SimpleObjectCamelCase$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonMapOfArrayCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfArraysCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonMapOfArrayCamelCaseResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonMapOfArrayCamelCaseResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfMap(
        request: { [k: string]: { [k: string]: shared.SimpleObject } },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfMapResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.record(shared.SimpleObject$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonMapOfMapServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#mapOfMaps")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonMapOfMapResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonMapOfMapResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfMapCamelCase(
        request: { [k: string]: { [k: string]: shared.SimpleObjectCamelCase } },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfMapCamelCaseResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z.record(z.record(shared.SimpleObjectCamelCase$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonMapOfMapCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfMapsCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonMapOfMapCamelCaseResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonMapOfMapCamelCaseResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfMapOfPrimitive(
        request: { [k: string]: { [k: string]: string } },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfMapOfPrimitiveResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.record(z.string())).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonMapOfMapOfPrimitiveServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfMapsOfPrimitives")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMapOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonMapOfMapOfPrimitiveResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonMapOfMapOfPrimitiveResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfPrimitive(
        request: { [k: string]: string },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfPrimitiveResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonMapOfPrimitiveServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#mapOfPrimitives")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonMapOfPrimitiveResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonMapOfPrimitiveResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonMultipleJsonFiltered(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonMultipleJsonFilteredResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/multiple/json/filtered"
        )();

        const query$ = "";

        headers$.set(
            "any",
            encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            encodeSimple$("bigint", payload$.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            encodeSimple$("bigintStr", payload$.bigintStr, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bool",
            encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            encodeSimple$("boolOpt", payload$.boolOpt, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "date",
            encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            encodeSimple$("dateTime", payload$.dateTime, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimal",
            encodeSimple$("decimal", payload$.decimal, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimalStr",
            encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            encodeSimple$("float32", payload$.float32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float64Str",
            encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "int",
            encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            encodeSimple$("int32Enum", payload$.int32Enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int64Str",
            encodeSimple$("int64Str", payload$.int64Str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intEnum",
            encodeSimple$("intEnum", payload$.intEnum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intOptNull",
            encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            encodeSimple$("strOpt", payload$.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMultipleJsonFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonMultipleJsonFilteredResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonMultipleJsonFilteredResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonSimple(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonSimpleResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/simple"
        )();

        const query$ = "";

        headers$.set(
            "any",
            encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            encodeSimple$("bigint", payload$.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            encodeSimple$("bigintStr", payload$.bigintStr, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bool",
            encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            encodeSimple$("boolOpt", payload$.boolOpt, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "date",
            encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            encodeSimple$("dateTime", payload$.dateTime, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimal",
            encodeSimple$("decimal", payload$.decimal, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimalStr",
            encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            encodeSimple$("float32", payload$.float32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float64Str",
            encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "int",
            encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            encodeSimple$("int32Enum", payload$.int32Enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int64Str",
            encodeSimple$("int64Str", payload$.int64Str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intEnum",
            encodeSimple$("intEnum", payload$.intEnum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intOptNull",
            encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            encodeSimple$("strOpt", payload$.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonSimpleResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonSimpleResponse$, { key: "res" })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostApplicationJsonSimpleCamelCase(
        request: shared.SimpleObjectCamelCase,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonSimpleCamelCaseResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObjectCamelCase$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/camelcase"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonSimpleCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonSimpleCamelCaseResponse>()
                .json(200, operations.RequestBodyPostApplicationJsonSimpleCamelCaseResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostComplexNumberTypes(
        request: operations.RequestBodyPostComplexNumberTypesRequest,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostComplexNumberTypesResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostComplexNumberTypesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.complexNumberTypes, { explode: true });

        const pathParams$ = {
            pathBigInt: encodeSimple$("pathBigInt", payload$.pathBigInt, {
                explode: false,
                charEncoding: "percent",
            }),
            pathBigIntStr: encodeSimple$("pathBigIntStr", payload$.pathBigIntStr, {
                explode: false,
                charEncoding: "percent",
            }),
            pathDecimal: encodeSimple$("pathDecimal", payload$.pathDecimal, {
                explode: false,
                charEncoding: "percent",
            }),
            pathDecimalStr: encodeSimple$("pathDecimalStr", payload$.pathDecimalStr, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/{pathBigInt}/{pathBigIntStr}/{pathDecimal}/{pathDecimalStr}/complex-number-types"
        )(pathParams$);

        const query$ = encodeFormQuery$({
            queryBigInt: payload$.queryBigInt,
            queryBigIntStr: payload$.queryBigIntStr,
            queryDecimal: payload$.queryDecimal,
            queryDecimalStr: payload$.queryDecimalStr,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostComplexNumberTypes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPostComplexNumberTypesResponse>()
            .json(200, operations.RequestBodyPostComplexNumberTypesResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostDefaultsAndConsts(
        request: shared.DefaultsAndConsts,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostDefaultsAndConstsResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DefaultsAndConsts$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/defaultsAndConsts")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostDefaultsAndConsts",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPostDefaultsAndConstsResponse>()
            .json(200, operations.RequestBodyPostDefaultsAndConstsResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostEmptyObject(
        request: operations.RequestBodyPostEmptyObjectRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostEmptyObjectResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostEmptyObjectRequestBody$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/empty-object")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostEmptyObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPostEmptyObjectResponse>()
            .json(200, operations.RequestBodyPostEmptyObjectResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostFormDeep(
        request: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormDeepResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/x-www-form-urlencoded");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DeepObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent("/anything/requestBodies/post/form/deep")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostFormDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPostFormDeepResponse>()
            .json(200, operations.RequestBodyPostFormDeepResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostFormMapPrimitive(
        request: { [k: string]: string },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormMapPrimitiveResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/x-www-form-urlencoded");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/form/map/primitive"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostFormMapPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPostFormMapPrimitiveResponse>()
            .json(200, operations.RequestBodyPostFormMapPrimitiveResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostFormSimple(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormSimpleResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/x-www-form-urlencoded");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent("/anything/requestBodies/post/form/simple")();

        const query$ = "";

        headers$.set(
            "any",
            encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            encodeSimple$("bigint", payload$.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            encodeSimple$("bigintStr", payload$.bigintStr, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bool",
            encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            encodeSimple$("boolOpt", payload$.boolOpt, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "date",
            encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            encodeSimple$("dateTime", payload$.dateTime, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimal",
            encodeSimple$("decimal", payload$.decimal, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimalStr",
            encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            encodeSimple$("float32", payload$.float32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float64Str",
            encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "int",
            encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            encodeSimple$("int32Enum", payload$.int32Enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int64Str",
            encodeSimple$("int64Str", payload$.int64Str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intEnum",
            encodeSimple$("intEnum", payload$.intEnum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intOptNull",
            encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            encodeSimple$("strOpt", payload$.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostFormSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPostFormSimpleResponse>()
            .json(200, operations.RequestBodyPostFormSimpleResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesArrayBigInt(
        request: Array<bigint>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayBigIntResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.bigint().transform((v) => Number(v))).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/array/bigInt"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayBigInt",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesArrayBigIntResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesArrayBigIntResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesArrayDate(
        request: Array<RFCDate>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayDateResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.instanceof(RFCDate).transform((v) => v.toString())).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/array/date"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayDate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesArrayDateResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesArrayDateResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesArrayDecimalStr(
        request: Array<Decimal$ | number>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayDecimalStrResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .array(z.union([z.instanceof(Decimal$), z.number()]).transform((v) => `${v}`))
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/array/decimalStr"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayDecimalStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesArrayDecimalStrResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesArrayDecimalStrResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesBigInt(
        request: bigint,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBigIntResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .bigint()
                    .transform((v) => Number(v))
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/bigint"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesBigInt",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesBigIntResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesBigIntResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesBigIntStr(
        request: bigint,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBigIntStrResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .bigint()
                    .transform((v) => `${v}`)
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/bigintStr"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesBigIntStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesBigIntStrResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesBigIntStrResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesBoolean(
        request: boolean,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBooleanResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.boolean().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/boolean"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesBoolean",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesBooleanResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesBooleanResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesComplexNumberArrays(
        request: shared.ComplexNumberArrays,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesComplexNumberArraysResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ComplexNumberArrays$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/complexNumberArrays"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesComplexNumberArrays",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesComplexNumberArraysResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesComplexNumberArraysResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesComplexNumberMaps(
        request: shared.ComplexNumberMaps,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesComplexNumberMapsResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ComplexNumberMaps$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/complexNumberMaps"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesComplexNumberMaps",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesComplexNumberMapsResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesComplexNumberMapsResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesDate(
        request: RFCDate,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDateResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .instanceof(RFCDate)
                    .transform((v) => v.toString())
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/date"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPostJsonDataTypesDateResponse>()
            .json(200, operations.RequestBodyPostJsonDataTypesDateResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesDateTime(
        request: Date,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDateTimeResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .date()
                    .transform((v) => v.toISOString())
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/dateTime"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDateTime",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesDateTimeResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesDateTimeResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesDecimal(
        request: Decimal$ | number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDecimalResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .union([z.instanceof(Decimal$), z.number()])
                    .transform((v) => (typeof v === "number" ? v : v.toNumber()))
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/decimal"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDecimal",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesDecimalResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesDecimalResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesDecimalStr(
        request: Decimal$ | number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDecimalStrResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .union([z.instanceof(Decimal$), z.number()])
                    .transform((v) => `${v}`)
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/decimalStr"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDecimalStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesDecimalStrResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesDecimalStrResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesFloat32(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesFloat32Response> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.number().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/float32"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesFloat32",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesFloat32Response>()
                .json(200, operations.RequestBodyPostJsonDataTypesFloat32Response$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesInt32(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesInt32Response> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.number().int().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/int32"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesInt32",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPostJsonDataTypesInt32Response>()
            .json(200, operations.RequestBodyPostJsonDataTypesInt32Response$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesInteger(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesIntegerResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.number().int().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/integer"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesInteger",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesIntegerResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesIntegerResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesMapBigIntStr(
        request: { [k: string]: bigint },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapBigIntStrResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.bigint().transform((v) => `${v}`)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/map/bigIntStr"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesMapBigIntStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesMapBigIntStrResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesMapBigIntStrResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesMapDateTime(
        request: { [k: string]: Date },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapDateTimeResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.date().transform((v) => v.toISOString())).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/map/dateTime"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesMapDateTime",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesMapDateTimeResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesMapDateTimeResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesMapDecimal(
        request: { [k: string]: Decimal$ | number },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapDecimalResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .record(
                        z
                            .union([z.instanceof(Decimal$), z.number()])
                            .transform((v) => (typeof v === "number" ? v : v.toNumber()))
                    )
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/map/decimal"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesMapDecimal",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesMapDecimalResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesMapDecimalResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesNumber(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesNumberResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.number().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/number"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesNumber",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesNumberResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesNumberResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostJsonDataTypesString(
        request: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesStringResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.string().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/string"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesString",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesStringResponse>()
                .json(200, operations.RequestBodyPostJsonDataTypesStringResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostMultipleContentTypesComponentFiltered(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesComponentFilteredResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/component/filtered"
        )();

        const query$ = "";

        headers$.set(
            "any",
            encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            encodeSimple$("bigint", payload$.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            encodeSimple$("bigintStr", payload$.bigintStr, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bool",
            encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            encodeSimple$("boolOpt", payload$.boolOpt, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "date",
            encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            encodeSimple$("dateTime", payload$.dateTime, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimal",
            encodeSimple$("decimal", payload$.decimal, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimalStr",
            encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            encodeSimple$("float32", payload$.float32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float64Str",
            encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "int",
            encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            encodeSimple$("int32Enum", payload$.int32Enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int64Str",
            encodeSimple$("int64Str", payload$.int64Str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intEnum",
            encodeSimple$("intEnum", payload$.intEnum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intOptNull",
            encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            encodeSimple$("strOpt", payload$.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesComponentFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesComponentFilteredResponse>()
                .json(
                    200,
                    operations.RequestBodyPostMultipleContentTypesComponentFilteredResponse$,
                    { key: "res" }
                )
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostMultipleContentTypesInlineFiltered(
        request: operations.RequestBodyPostMultipleContentTypesInlineFilteredRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesInlineFilteredResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesInlineFilteredRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/inline/filtered"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesInlineFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesInlineFilteredResponse>()
                .json(200, operations.RequestBodyPostMultipleContentTypesInlineFilteredResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitParamForm(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamFormRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamFormResponse> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamFormRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/x-www-form-urlencoded");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamFormRequest$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$.RequestBody || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = encodeFormQuery$({
            paramStr: payload$.paramStr,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_form",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitParamFormResponse>()
                .json(200, operations.RequestBodyPostMultipleContentTypesSplitParamFormResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitParamJson(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamJsonResponse> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequest$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = encodeFormQuery$({
            paramStr: payload$.paramStr,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_json",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitParamJsonResponse>()
                .json(200, operations.RequestBodyPostMultipleContentTypesSplitParamJsonResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitParamMultipart(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamMultipartResponse> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequest$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("bool2", String(payload$.RequestBody.bool2));
        body$.append("num2", String(payload$.RequestBody.num2));
        body$.append("str2", payload$.RequestBody.str2);

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = encodeFormQuery$({
            paramStr: payload$.paramStr,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_multipart",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitParamMultipartResponse>()
                .json(
                    200,
                    operations.RequestBodyPostMultipleContentTypesSplitParamMultipartResponse$,
                    { key: "res" }
                )
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitForm(
        request: operations.RequestBodyPostMultipleContentTypesSplitFormRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitFormResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/x-www-form-urlencoded");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitFormRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_form",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitFormResponse>()
                .json(200, operations.RequestBodyPostMultipleContentTypesSplitFormResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitJson(
        request: operations.RequestBodyPostMultipleContentTypesSplitJsonRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitJsonResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitJsonRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_json",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitJsonResponse>()
                .json(200, operations.RequestBodyPostMultipleContentTypesSplitJsonResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitMultipart(
        request: operations.RequestBodyPostMultipleContentTypesSplitMultipartRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitMultipartResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitMultipartRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("bool2", String(payload$.bool2));
        body$.append("num2", String(payload$.num2));
        body$.append("str2", payload$.str2);

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_multipart",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitMultipartResponse>()
                .json(200, operations.RequestBodyPostMultipleContentTypesSplitMultipartResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostNotNullableNotRequiredStringBody(
        request?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNotNullableNotRequiredStringBodyResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.string().optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/notnullable/notrequired/string"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNotNullableNotRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostNotNullableNotRequiredStringBodyResponse>()
                .json(200, operations.RequestBodyPostNotNullableNotRequiredStringBodyResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostNullArray(
        request: Array<string>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullArrayResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/null-array")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPostNullArrayResponse>()
            .json(200, operations.RequestBodyPostNullArrayResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostNullDictionary(
        request: { [k: string]: string },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullDictionaryResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/null-dictionary")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullDictionary",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPostNullDictionaryResponse>()
            .json(200, operations.RequestBodyPostNullDictionaryResponse$, { key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostNullableNotRequiredStringBody(
        request?: string | null | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullableNotRequiredStringBodyResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.nullable(z.string()).optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullable/notrequired/string"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullableNotRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostNullableNotRequiredStringBodyResponse>()
                .json(200, operations.RequestBodyPostNullableNotRequiredStringBodyResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPostNullableRequiredStringBody(
        request: string | null,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullableRequiredStringBodyResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.nullable(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullable/required/string"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullableRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPostNullableRequiredStringBodyResponse>()
                .json(200, operations.RequestBodyPostNullableRequiredStringBodyResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPutBytes(
        request: Uint8Array | string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutBytesResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/octet-stream");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => b64$.zodOutbound.parse(value$),
            "Input validation failed"
        );
        const body$ = payload$;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/bytes")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutBytes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPutBytesResponse>()
            .json(200, operations.RequestBodyPutBytesResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPutBytesWithParams(
        requestBody: Uint8Array | string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutBytesWithParamsResponse> {
        const input$: operations.RequestBodyPutBytesWithParamsRequest = {
            requestBody: requestBody,
            queryStringParam: queryStringParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/octet-stream");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutBytesWithParamsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = payload$.RequestBody;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/bytesWithParams")();

        const query$ = encodeFormQuery$({
            queryStringParam: payload$.queryStringParam,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutBytesWithParams",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPutBytesWithParamsResponse>()
            .json(200, operations.RequestBodyPutBytesWithParamsResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPutMultipartDeep(
        request: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartDeepResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DeepObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("any", encodeJSON$("any", payload$.any, { explode: true }));
        body$.append("arr", encodeJSON$("arr", payload$.arr, { explode: true }));
        body$.append("bool", String(payload$.bool));
        body$.append("int", String(payload$.int));
        body$.append("map", encodeJSON$("map", payload$.map, { explode: true }));
        body$.append("num", String(payload$.num));
        body$.append("obj", encodeJSON$("obj", payload$.obj, { explode: true }));
        body$.append("str", payload$.str);
        if (payload$.type !== undefined) {
            body$.append("type", payload$.type);
        }

        const path$ = this.templateURLComponent("/anything/requestBodies/put/multipart/deep")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPutMultipartDeepResponse>()
            .json(200, operations.RequestBodyPutMultipartDeepResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPutMultipartDifferentFileName(
        request: operations.RequestBodyPutMultipartDifferentFileNameRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartDifferentFileNameResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutMultipartDifferentFileNameRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = new FormData();

        if (payload$.differentFileName !== undefined) {
            if (isBlobLike(payload$.differentFileName)) {
                body$.append("differentFileName", payload$.differentFileName);
            } else {
                body$.append(
                    "differentFileName",
                    new Blob([payload$.differentFileName.content], {
                        type: "application/octet-stream",
                    }),
                    payload$.differentFileName.fileName
                );
            }
        }

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/put/multipart/differentFileName"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartDifferentFileName",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPutMultipartDifferentFileNameResponse>()
                .json(200, operations.RequestBodyPutMultipartDifferentFileNameResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPutMultipartFile(
        request: operations.RequestBodyPutMultipartFileRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartFileResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutMultipartFileRequestBody$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();

        if (payload$.file !== undefined) {
            if (isBlobLike(payload$.file)) {
                body$.append("file", payload$.file);
            } else {
                body$.append(
                    "file",
                    new Blob([payload$.file.content], { type: "application/octet-stream" }),
                    payload$.file.fileName
                );
            }
        }

        const path$ = this.templateURLComponent("/anything/requestBodies/put/multipart/file")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartFile",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPutMultipartFileResponse>()
            .json(200, operations.RequestBodyPutMultipartFileResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPutMultipartOptionalRequestBody(
        request?: operations.RequestBodyPutMultipartOptionalRequestBodyRequestBody | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartOptionalRequestBodyResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutMultipartOptionalRequestBodyRequestBody$.outboundSchema
                    .optional()
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();
        if (payload$ != null) {
            if (payload$?.sampleField !== undefined) {
                body$.append("sampleField", payload$?.sampleField);
            }
            if (payload$?.sampleFile !== undefined) {
                if (isBlobLike(payload$?.sampleFile)) {
                    body$.append("sampleFile", payload$?.sampleFile);
                } else {
                    body$.append(
                        "sampleFile",
                        new Blob([payload$?.sampleFile.content], {
                            type: "application/octet-stream",
                        }),
                        payload$?.sampleFile.fileName
                    );
                }
            }
        }

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/put/multipart/optionalRequestBody"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartOptionalRequestBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.RequestBodyPutMultipartOptionalRequestBodyResponse>()
                .json(200, operations.RequestBodyPutMultipartOptionalRequestBodyResponse$, {
                    key: "res",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPutMultipartSimple(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartSimpleResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("bool", String(payload$.bool));
        body$.append("date", payload$.date);
        body$.append("dateTime", payload$.dateTime);
        body$.append("enum", payload$.enum);
        body$.append("float32", String(payload$.float32));
        body$.append("int", String(payload$.int));
        body$.append("int32", String(payload$.int32));
        body$.append("int32Enum", String(payload$.int32Enum));
        body$.append("intEnum", String(payload$.intEnum));
        body$.append("num", String(payload$.num));
        body$.append("str", payload$.str);
        if (payload$.any !== undefined) {
            body$.append("any", String(payload$.any));
        }
        if (payload$.bigint !== undefined) {
            body$.append("bigint", String(payload$.bigint));
        }
        if (payload$.bigintStr !== undefined) {
            body$.append("bigintStr", payload$.bigintStr);
        }
        if (payload$.boolOpt !== undefined) {
            body$.append("boolOpt", String(payload$.boolOpt));
        }
        if (payload$.decimal !== undefined) {
            body$.append("decimal", String(payload$.decimal));
        }
        if (payload$.decimalStr !== undefined) {
            body$.append("decimalStr", payload$.decimalStr);
        }
        if (payload$.float64Str !== undefined) {
            body$.append("float64Str", payload$.float64Str);
        }
        if (payload$.int64Str !== undefined) {
            body$.append("int64Str", payload$.int64Str);
        }
        if (payload$.intOptNull !== undefined) {
            body$.append("intOptNull", String(payload$.intOptNull));
        }
        if (payload$.numOptNull !== undefined) {
            body$.append("numOptNull", String(payload$.numOptNull));
        }
        if (payload$.strOpt !== undefined) {
            body$.append("strOpt", payload$.strOpt);
        }

        const path$ = this.templateURLComponent("/anything/requestBodies/put/multipart/simple")();

        const query$ = "";

        headers$.set(
            "any",
            encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            encodeSimple$("bigint", payload$.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            encodeSimple$("bigintStr", payload$.bigintStr, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bool",
            encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            encodeSimple$("boolOpt", payload$.boolOpt, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "date",
            encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            encodeSimple$("dateTime", payload$.dateTime, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimal",
            encodeSimple$("decimal", payload$.decimal, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimalStr",
            encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            encodeSimple$("float32", payload$.float32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float64Str",
            encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "int",
            encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            encodeSimple$("int32Enum", payload$.int32Enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int64Str",
            encodeSimple$("int64Str", payload$.int64Str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intEnum",
            encodeSimple$("intEnum", payload$.intEnum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intOptNull",
            encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            encodeSimple$("strOpt", payload$.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPutMultipartSimpleResponse>()
            .json(200, operations.RequestBodyPutMultipartSimpleResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPutString(
        request: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutStringResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "text/plain");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.string().parse(value$),
            "Input validation failed"
        );
        const body$ = payload$;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/string")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutString",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPutStringResponse>()
            .json(200, operations.RequestBodyPutStringResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyPutStringWithParams(
        requestBody: string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutStringWithParamsResponse> {
        const input$: operations.RequestBodyPutStringWithParamsRequest = {
            requestBody: requestBody,
            queryStringParam: queryStringParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "text/plain");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutStringWithParamsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = payload$.RequestBody;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/stringWithParams")();

        const query$ = encodeFormQuery$({
            queryStringParam: payload$.queryStringParam,
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutStringWithParams",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyPutStringWithParamsResponse>()
            .json(200, operations.RequestBodyPutStringWithParamsResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyReadAndWrite(
        request: shared.ReadWriteObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyReadAndWriteResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ReadWriteObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyReadAndWriteServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyandwriteonly")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadAndWrite",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyReadAndWriteResponse>()
            .json(200, operations.RequestBodyReadAndWriteResponse$, { key: "readWriteObject" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyReadOnlyInput(
        request: shared.ReadOnlyObjectInput,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyReadOnlyInputResponse> {
        const input$ = request;
        void input$; // request input is unused
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyReadOnlyInputServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyorwriteonly#readOnlyInput")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadOnlyInput",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyReadOnlyInputResponse>()
            .json(200, operations.RequestBodyReadOnlyInputResponse$, { key: "readOnlyObject" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyReadOnlyUnion(
        request: shared.WeaklyTypedOneOfReadOnlyObjectInput,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyReadOnlyUnionResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.WeaklyTypedOneOfReadOnlyObjectInput$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyReadOnlyUnionServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyorwriteonly#readOnlyUnion")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyReadOnlyUnionResponse>()
            .json(200, operations.RequestBodyReadOnlyUnionResponse$, {
                key: "weaklyTypedOneOfReadOnlyObject",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyReadWriteOnlyUnion(
        request: shared.WeaklyTypedOneOfReadWriteObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyReadWriteOnlyUnionResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.WeaklyTypedOneOfReadWriteObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyReadWriteOnlyUnionServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyandwriteonly#readWriteOnlyUnion")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadWriteOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyReadWriteOnlyUnionResponse>()
            .json(200, operations.RequestBodyReadWriteOnlyUnionResponse$, {
                key: "weaklyTypedOneOfReadWriteObject",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyWriteOnly(
        request: shared.WriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyWriteOnlyResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.WriteOnlyObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyWriteOnlyServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyorwriteonly#writeOnly")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyWriteOnly",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyWriteOnlyResponse>()
            .json(200, operations.RequestBodyWriteOnlyResponse$, { key: "readOnlyObject" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyWriteOnlyOutput(
        request: shared.WriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyWriteOnlyOutputResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.WriteOnlyObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyWriteOnlyOutputServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/writeonlyoutput#writeOnlyOutput")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyWriteOnlyOutput",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyWriteOnlyOutputResponse>()
            .json(200, operations.RequestBodyWriteOnlyOutputResponse$, { key: "writeOnlyObject" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async requestBodyWriteOnlyUnion(
        request: shared.WeaklyTypedOneOfWriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyWriteOnlyUnionResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.WeaklyTypedOneOfWriteOnlyObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyWriteOnlyUnionServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/writeonlyoutput#writeOnlyUnion")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyWriteOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.RequestBodyWriteOnlyUnionResponse>()
            .json(200, operations.RequestBodyWriteOnlyUnionResponse$, {
                key: "weaklyTypedOneOfWriteOnlyObject",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }
}
