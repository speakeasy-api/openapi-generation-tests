/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks";
import * as b64$ from "../lib/base64";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import * as schemas$ from "../lib/schemas";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as errors from "../sdk/models/errors";
import * as operations from "../sdk/models/operations";
import * as shared from "../sdk/models/shared";
import { Decimal as Decimal$, isBlobLike, RFCDate } from "../sdk/types";
import * as z from "zod";

export class RequestBodies extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    async nullEnumPost(
        input: shared.ObjectWithNullEnums,
        options?: RequestOptions
    ): Promise<operations.NullEnumPostResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.ObjectWithNullEnums$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/nullEnum")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullEnumPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.NullEnumPostResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async nullableObjectPost(
        input: shared.NullableObject | null,
        options?: RequestOptions
    ): Promise<operations.NullableObjectPostResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.nullable(shared.NullableObject$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredObject"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.NullableObjectPostResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async nullableRequiredEmptyObjectPost(
        input: operations.NullableRequiredEmptyObjectPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredEmptyObjectPostResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.NullableRequiredEmptyObjectPostRequestBody$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredEmptyObject"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableRequiredEmptyObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.NullableRequiredEmptyObjectPostResponse$.inboundSchema.parse({
                        ...responseFields$,
                        object: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async nullableRequiredPropertyPost(
        input: operations.NullableRequiredPropertyPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredPropertyPostResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.NullableRequiredPropertyPostRequestBody$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredProperty"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableRequiredPropertyPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.NullableRequiredPropertyPostResponse$.inboundSchema.parse({
                        ...responseFields$,
                        object: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async nullableRequiredSharedObjectPost(
        input: operations.NullableRequiredSharedObjectPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredSharedObjectPostResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.NullableRequiredSharedObjectPostRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredSharedObject"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableRequiredSharedObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.NullableRequiredSharedObjectPostResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonArray(
        input: Array<shared.SimpleObject>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.array(shared.SimpleObject$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(operations.RequestBodyPostApplicationJsonArrayServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#array")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonArrayResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonArrayCamelCase(
        input: Array<shared.SimpleObjectCamelCase>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayCamelCaseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.array(shared.SimpleObjectCamelCase$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonArrayCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonArrayCamelCaseResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonArrayObj(
        input: Array<shared.SimpleObject>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonArrayObjResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.array(shared.SimpleObject$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/array/objResponse"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayObj",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonArrayObjResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            arrObjValue: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonArrayObjCamelCase(
        input: Array<shared.SimpleObjectCamelCase>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonArrayObjCamelCaseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.array(shared.SimpleObjectCamelCase$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/array/objResponseCamelCase"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayObjCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonArrayObjCamelCaseResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            arrObjValueCamelCase: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonArrayOfArray(
        input: Array<Array<shared.SimpleObject>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfArrayResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.array(z.array(shared.SimpleObject$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonArrayOfArrayServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfArrays")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonArrayOfArrayResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonArrayOfArrayCamelCase(
        input: Array<Array<shared.SimpleObjectCamelCase>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfArrayCamelCaseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z.array(z.array(shared.SimpleObjectCamelCase$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonArrayOfArrayCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfArraysCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonArrayOfArrayCamelCaseResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonArrayOfArrayOfPrimitive(
        input: Array<Array<string>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.array(z.array(z.string())).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfArraysOfPrimitives")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArrayOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonArrayOfMap(
        input: Array<Record<string, shared.SimpleObject>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfMapResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.array(z.record(shared.SimpleObject$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonArrayOfMapServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfMaps")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonArrayOfMapResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonArrayOfMapCamelCase(
        input: Array<Record<string, shared.SimpleObjectCamelCase>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfMapCamelCaseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z.array(z.record(shared.SimpleObjectCamelCase$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonArrayOfMapCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfMapsCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonArrayOfMapCamelCaseResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonArrayOfPrimitive(
        input: Array<string>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonArrayOfPrimitiveResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.array(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonArrayOfPrimitiveServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfPrimitives")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonArrayOfPrimitiveResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonDeep(
        input: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonDeepResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.DeepObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/deep"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonDeepResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonDeepCamelCase(
        input: shared.DeepObjectCamelCase,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonDeepCamelCaseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.DeepObjectCamelCase$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/deep/camelcase"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonDeepCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonDeepCamelCaseResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonMap(
        input: Record<string, shared.SimpleObject>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(shared.SimpleObject$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(operations.RequestBodyPostApplicationJsonMapServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#map")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonMapResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonMapCamelCase(
        input: Record<string, shared.SimpleObjectCamelCase>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapCamelCaseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(shared.SimpleObjectCamelCase$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonMapCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonMapCamelCaseResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonMapObj(
        input: Record<string, shared.SimpleObject>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonMapObjResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(shared.SimpleObject$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/map/objResponse"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapObj",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonMapObjResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            mapObjValue: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonMapObjCamelCase(
        input: Record<string, shared.SimpleObjectCamelCase>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonMapObjCamelCaseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(shared.SimpleObjectCamelCase$.outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/map/objResponseCamelCase"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapObjCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonMapObjCamelCaseResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            mapObjValueCamelCase: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonMapOfArray(
        input: Record<string, Array<shared.SimpleObject>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfArrayResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(z.array(shared.SimpleObject$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonMapOfArrayServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfArrays")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonMapOfArrayResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonMapOfArrayCamelCase(
        input: Record<string, Array<shared.SimpleObjectCamelCase>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfArrayCamelCaseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z.record(z.array(shared.SimpleObjectCamelCase$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonMapOfArrayCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfArraysCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonMapOfArrayCamelCaseResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonMapOfMap(
        input: Record<string, Record<string, shared.SimpleObject>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfMapResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(z.record(shared.SimpleObject$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonMapOfMapServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfMaps")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonMapOfMapResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonMapOfMapCamelCase(
        input: Record<string, Record<string, shared.SimpleObjectCamelCase>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfMapCamelCaseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z.record(z.record(shared.SimpleObjectCamelCase$.outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonMapOfMapCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfMapsCamelCase")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonMapOfMapCamelCaseResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonMapOfMapOfPrimitive(
        input: Record<string, Record<string, string>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfMapOfPrimitiveResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(z.record(z.string())).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonMapOfMapOfPrimitiveServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfMapsOfPrimitives")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMapOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonMapOfMapOfPrimitiveResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonMapOfPrimitive(
        input: Record<string, string>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyPostApplicationJsonMapOfPrimitiveResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                operations.RequestBodyPostApplicationJsonMapOfPrimitiveServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfPrimitives")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonMapOfPrimitiveResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonMultipleJsonFiltered(
        input: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonMultipleJsonFilteredResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.SimpleObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/multiple/json/filtered"
        )();

        const query$ = "";

        headers$.set(
            "any",
            enc$.encodeSimple("any", payload$.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            enc$.encodeSimple("bigint", payload$.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            enc$.encodeSimple("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "bool",
            enc$.encodeSimple("bool", payload$.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            enc$.encodeSimple("boolOpt", payload$.boolOpt, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "date",
            enc$.encodeSimple("date", payload$.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            enc$.encodeSimple("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "decimal",
            enc$.encodeSimple("decimal", payload$.decimal, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimalStr",
            enc$.encodeSimple("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            enc$.encodeSimple("enum", payload$.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            enc$.encodeSimple("float32", payload$.float32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int",
            enc$.encodeSimple("int", payload$.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            enc$.encodeSimple("int32", payload$.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            enc$.encodeSimple("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "intEnum",
            enc$.encodeSimple("intEnum", payload$.intEnum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intOptNull",
            enc$.encodeSimple("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            enc$.encodeSimple("num", payload$.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            enc$.encodeSimple("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            enc$.encodeSimple("str", payload$.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            enc$.encodeSimple("strOpt", payload$.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMultipleJsonFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonMultipleJsonFilteredResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonSimple(
        input: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonSimpleResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.SimpleObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/simple"
        )();

        const query$ = "";

        headers$.set(
            "any",
            enc$.encodeSimple("any", payload$.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            enc$.encodeSimple("bigint", payload$.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            enc$.encodeSimple("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "bool",
            enc$.encodeSimple("bool", payload$.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            enc$.encodeSimple("boolOpt", payload$.boolOpt, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "date",
            enc$.encodeSimple("date", payload$.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            enc$.encodeSimple("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "decimal",
            enc$.encodeSimple("decimal", payload$.decimal, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimalStr",
            enc$.encodeSimple("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            enc$.encodeSimple("enum", payload$.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            enc$.encodeSimple("float32", payload$.float32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int",
            enc$.encodeSimple("int", payload$.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            enc$.encodeSimple("int32", payload$.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            enc$.encodeSimple("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "intEnum",
            enc$.encodeSimple("intEnum", payload$.intEnum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intOptNull",
            enc$.encodeSimple("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            enc$.encodeSimple("num", payload$.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            enc$.encodeSimple("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            enc$.encodeSimple("str", payload$.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            enc$.encodeSimple("strOpt", payload$.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonSimpleResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostApplicationJsonSimpleCamelCase(
        input: shared.SimpleObjectCamelCase,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonSimpleCamelCaseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.SimpleObjectCamelCase$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/camelcase"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonSimpleCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostApplicationJsonSimpleCamelCaseResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostComplexNumberTypes(
        input: operations.RequestBodyPostComplexNumberTypesRequest,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostComplexNumberTypesResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.RequestBodyPostComplexNumberTypesRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.complexNumberTypes, { explode: true });

        const pathParams$ = {
            pathBigInt: enc$.encodeSimple("pathBigInt", payload$.pathBigInt, {
                explode: false,
                charEncoding: "percent",
            }),
            pathBigIntStr: enc$.encodeSimple("pathBigIntStr", payload$.pathBigIntStr, {
                explode: false,
                charEncoding: "percent",
            }),
            pathDecimal: enc$.encodeSimple("pathDecimal", payload$.pathDecimal, {
                explode: false,
                charEncoding: "percent",
            }),
            pathDecimalStr: enc$.encodeSimple("pathDecimalStr", payload$.pathDecimalStr, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/{pathBigInt}/{pathBigIntStr}/{pathDecimal}/{pathDecimalStr}/complex-number-types"
        )(pathParams$);

        const query$ = [
            enc$.encodeForm("queryBigInt", payload$.queryBigInt, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("queryBigIntStr", payload$.queryBigIntStr, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("queryDecimal", payload$.queryDecimal, {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("queryDecimalStr", payload$.queryDecimalStr, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostComplexNumberTypes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostComplexNumberTypesResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostDefaultsAndConsts(
        input: shared.DefaultsAndConsts,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostDefaultsAndConstsResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.DefaultsAndConsts$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/defaultsAndConsts")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostDefaultsAndConsts",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostDefaultsAndConstsResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostEmptyObject(
        input: operations.RequestBodyPostEmptyObjectRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostEmptyObjectResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.RequestBodyPostEmptyObjectRequestBody$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/empty-object")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostEmptyObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostEmptyObjectResponse$.inboundSchema.parse({
                        ...responseFields$,
                        object: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostFormDeep(
        input: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormDeepResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/x-www-form-urlencoded");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.DeepObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return enc$.encodeBodyForm(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent("/anything/requestBodies/post/form/deep")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostFormDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostFormDeepResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostFormMapPrimitive(
        input: Record<string, string>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormMapPrimitiveResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/x-www-form-urlencoded");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return enc$.encodeBodyForm(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/form/map/primitive"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostFormMapPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostFormMapPrimitiveResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostFormSimple(
        input: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormSimpleResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/x-www-form-urlencoded");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.SimpleObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return enc$.encodeBodyForm(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent("/anything/requestBodies/post/form/simple")();

        const query$ = "";

        headers$.set(
            "any",
            enc$.encodeSimple("any", payload$.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            enc$.encodeSimple("bigint", payload$.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            enc$.encodeSimple("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "bool",
            enc$.encodeSimple("bool", payload$.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            enc$.encodeSimple("boolOpt", payload$.boolOpt, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "date",
            enc$.encodeSimple("date", payload$.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            enc$.encodeSimple("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "decimal",
            enc$.encodeSimple("decimal", payload$.decimal, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimalStr",
            enc$.encodeSimple("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            enc$.encodeSimple("enum", payload$.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            enc$.encodeSimple("float32", payload$.float32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int",
            enc$.encodeSimple("int", payload$.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            enc$.encodeSimple("int32", payload$.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            enc$.encodeSimple("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "intEnum",
            enc$.encodeSimple("intEnum", payload$.intEnum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intOptNull",
            enc$.encodeSimple("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            enc$.encodeSimple("num", payload$.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            enc$.encodeSimple("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            enc$.encodeSimple("str", payload$.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            enc$.encodeSimple("strOpt", payload$.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostFormSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostFormSimpleResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesArrayBigInt(
        input: Array<bigint>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayBigIntResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.array(z.bigint().transform((v) => Number(v))).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/array/bigInt"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayBigInt",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesArrayBigIntResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesArrayDate(
        input: Array<RFCDate>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayDateResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.array(z.instanceof(RFCDate).transform((v) => v.toString())).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/array/date"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayDate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesArrayDateResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesArrayDecimalStr(
        input: Array<Decimal$ | number>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayDecimalStrResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z
                    .array(z.union([z.instanceof(Decimal$), z.number()]).transform((v) => `${v}`))
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/array/decimalStr"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayDecimalStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesArrayDecimalStrResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesBigInt(
        input: bigint,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBigIntResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z
                    .bigint()
                    .transform((v) => Number(v))
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/bigint"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesBigInt",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesBigIntResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesBigIntStr(
        input: bigint,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBigIntStrResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z
                    .bigint()
                    .transform((v) => `${v}`)
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/bigintStr"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesBigIntStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesBigIntStrResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesBoolean(
        input: boolean,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBooleanResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.boolean().parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/boolean"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesBoolean",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesBooleanResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesComplexNumberArrays(
        input: shared.ComplexNumberArrays,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesComplexNumberArraysResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.ComplexNumberArrays$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/complexNumberArrays"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesComplexNumberArrays",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesComplexNumberArraysResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesComplexNumberMaps(
        input: shared.ComplexNumberMaps,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesComplexNumberMapsResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.ComplexNumberMaps$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/complexNumberMaps"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesComplexNumberMaps",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesComplexNumberMapsResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesDate(
        input: RFCDate,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDateResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z
                    .instanceof(RFCDate)
                    .transform((v) => v.toString())
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/date"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesDateResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesDateTime(
        input: Date,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDateTimeResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z
                    .date()
                    .transform((v) => v.toISOString())
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/dateTime"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDateTime",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesDateTimeResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesDecimal(
        input: Decimal$ | number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDecimalResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z
                    .union([z.instanceof(Decimal$), z.number()])
                    .transform((v) => (typeof v === "number" ? v : v.toNumber()))
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/decimal"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDecimal",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesDecimalResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesDecimalStr(
        input: Decimal$ | number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDecimalStrResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z
                    .union([z.instanceof(Decimal$), z.number()])
                    .transform((v) => `${v}`)
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/decimalStr"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDecimalStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesDecimalStrResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesFloat32(
        input: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesFloat32Response> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.number().parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/float32"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesFloat32",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesFloat32Response$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesInt32(
        input: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesInt32Response> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.number().int().parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/int32"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesInt32",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesInt32Response$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesInteger(
        input: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesIntegerResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.number().int().parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/integer"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesInteger",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesIntegerResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesMapBigIntStr(
        input: Record<string, bigint>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapBigIntStrResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(z.bigint().transform((v) => `${v}`)).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/map/bigIntStr"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesMapBigIntStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesMapBigIntStrResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesMapDateTime(
        input: Record<string, Date>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapDateTimeResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(z.date().transform((v) => v.toISOString())).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/map/dateTime"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesMapDateTime",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesMapDateTimeResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesMapDecimal(
        input: Record<string, Decimal$ | number>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapDecimalResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                z
                    .record(
                        z
                            .union([z.instanceof(Decimal$), z.number()])
                            .transform((v) => (typeof v === "number" ? v : v.toNumber()))
                    )
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/map/decimal"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesMapDecimal",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesMapDecimalResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesNumber(
        input: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesNumberResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.number().parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/number"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesNumber",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesNumberResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostJsonDataTypesString(
        input: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesStringResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.string().parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/string"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesString",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostJsonDataTypesStringResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostMultipleContentTypesComponentFiltered(
        input: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesComponentFilteredResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.SimpleObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/component/filtered"
        )();

        const query$ = "";

        headers$.set(
            "any",
            enc$.encodeSimple("any", payload$.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            enc$.encodeSimple("bigint", payload$.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            enc$.encodeSimple("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "bool",
            enc$.encodeSimple("bool", payload$.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            enc$.encodeSimple("boolOpt", payload$.boolOpt, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "date",
            enc$.encodeSimple("date", payload$.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            enc$.encodeSimple("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "decimal",
            enc$.encodeSimple("decimal", payload$.decimal, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimalStr",
            enc$.encodeSimple("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            enc$.encodeSimple("enum", payload$.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            enc$.encodeSimple("float32", payload$.float32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int",
            enc$.encodeSimple("int", payload$.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            enc$.encodeSimple("int32", payload$.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            enc$.encodeSimple("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "intEnum",
            enc$.encodeSimple("intEnum", payload$.intEnum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intOptNull",
            enc$.encodeSimple("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            enc$.encodeSimple("num", payload$.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            enc$.encodeSimple("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            enc$.encodeSimple("str", payload$.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            enc$.encodeSimple("strOpt", payload$.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesComponentFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostMultipleContentTypesComponentFilteredResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostMultipleContentTypesInlineFiltered(
        input: operations.RequestBodyPostMultipleContentTypesInlineFilteredRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesInlineFilteredResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesInlineFilteredRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/inline/filtered"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesInlineFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostMultipleContentTypesInlineFilteredResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostMultipleContentTypesSplitParamForm(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamFormRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamFormResponse> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamFormRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/x-www-form-urlencoded");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamFormRequest$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$.RequestBody || {})
            .map(([k, v]) => {
                return enc$.encodeBodyForm(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = [
            enc$.encodeForm("paramStr", payload$.paramStr, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_form",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostMultipleContentTypesSplitParamFormResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostMultipleContentTypesSplitParamJson(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamJsonResponse> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequest$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$.RequestBody, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = [
            enc$.encodeForm("paramStr", payload$.paramStr, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_json",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostMultipleContentTypesSplitParamJsonResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostMultipleContentTypesSplitParamMultipart(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamMultipartResponse> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequest$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("bool2", String(payload$.RequestBody.bool2));
        body$.append("num2", String(payload$.RequestBody.num2));
        body$.append("str2", payload$.RequestBody.str2);

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = [
            enc$.encodeForm("paramStr", payload$.paramStr, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_multipart",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostMultipleContentTypesSplitParamMultipartResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostMultipleContentTypesSplitForm(
        input: operations.RequestBodyPostMultipleContentTypesSplitFormRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitFormResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/x-www-form-urlencoded");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitFormRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return enc$.encodeBodyForm(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_form",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostMultipleContentTypesSplitFormResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostMultipleContentTypesSplitJson(
        input: operations.RequestBodyPostMultipleContentTypesSplitJsonRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitJsonResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitJsonRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_json",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostMultipleContentTypesSplitJsonResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostMultipleContentTypesSplitMultipart(
        input: operations.RequestBodyPostMultipleContentTypesSplitMultipartRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitMultipartResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitMultipartRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("bool2", String(payload$.bool2));
        body$.append("num2", String(payload$.num2));
        body$.append("str2", payload$.str2);

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_multipart",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostMultipleContentTypesSplitMultipartResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostNotNullableNotRequiredStringBody(
        input: string | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNotNullableNotRequiredStringBodyResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.string().optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/notnullable/notrequired/string"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNotNullableNotRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostNotNullableNotRequiredStringBodyResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostNullArray(
        input: Array<string>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullArrayResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.array(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/null-array")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostNullArrayResponse$.inboundSchema.parse({
                        ...responseFields$,
                        object: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostNullDictionary(
        input: Record<string, string>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullDictionaryResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/null-dictionary")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullDictionary",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostNullDictionaryResponse$.inboundSchema.parse({
                        ...responseFields$,
                        object: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostNullableNotRequiredStringBody(
        input: string | null | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullableNotRequiredStringBodyResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.nullable(z.string()).optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullable/notrequired/string"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullableNotRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostNullableNotRequiredStringBodyResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPostNullableRequiredStringBody(
        input: string | null,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullableRequiredStringBodyResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.nullable(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullable/required/string"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullableRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPostNullableRequiredStringBodyResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            object: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPutBytes(
        input: Uint8Array | string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutBytesResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/octet-stream");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => b64$.zodOutbound.parse(value$),
            "Input validation failed"
        );
        const body$ = payload$;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/bytes")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutBytes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPutBytesResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPutBytesWithParams(
        requestBody: Uint8Array | string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutBytesWithParamsResponse> {
        const input$: operations.RequestBodyPutBytesWithParamsRequest = {
            requestBody: requestBody,
            queryStringParam: queryStringParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/octet-stream");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutBytesWithParamsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = payload$.RequestBody;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/bytesWithParams")();

        const query$ = [
            enc$.encodeForm("queryStringParam", payload$.queryStringParam, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutBytesWithParams",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPutBytesWithParamsResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPutMultipartDeep(
        input: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartDeepResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.DeepObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("any", enc$.encodeJSON("any", payload$.any, { explode: true }));
        body$.append("arr", enc$.encodeJSON("arr", payload$.arr, { explode: true }));
        body$.append("bool", String(payload$.bool));
        body$.append("int", String(payload$.int));
        body$.append("map", enc$.encodeJSON("map", payload$.map, { explode: true }));
        body$.append("num", String(payload$.num));
        body$.append("obj", enc$.encodeJSON("obj", payload$.obj, { explode: true }));
        body$.append("str", payload$.str);
        if (payload$.type !== undefined) {
            body$.append("type", payload$.type);
        }

        const path$ = this.templateURLComponent("/anything/requestBodies/put/multipart/deep")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPutMultipartDeepResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPutMultipartDifferentFileName(
        input: operations.RequestBodyPutMultipartDifferentFileNameRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartDifferentFileNameResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.RequestBodyPutMultipartDifferentFileNameRequestBody$.outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = new FormData();

        if (payload$.differentFileName !== undefined) {
            if (isBlobLike(payload$.differentFileName)) {
                body$.append("differentFileName", payload$.differentFileName);
            } else {
                body$.append(
                    "differentFileName",
                    new Blob([payload$.differentFileName.content], {
                        type: "application/octet-stream",
                    }),
                    payload$.differentFileName.fileName
                );
            }
        }

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/put/multipart/differentFileName"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartDifferentFileName",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPutMultipartDifferentFileNameResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPutMultipartFile(
        input: operations.RequestBodyPutMultipartFileRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartFileResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.RequestBodyPutMultipartFileRequestBody$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();

        if (payload$.file !== undefined) {
            if (isBlobLike(payload$.file)) {
                body$.append("file", payload$.file);
            } else {
                body$.append(
                    "file",
                    new Blob([payload$.file.content], { type: "application/octet-stream" }),
                    payload$.file.fileName
                );
            }
        }

        const path$ = this.templateURLComponent("/anything/requestBodies/put/multipart/file")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartFile",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPutMultipartFileResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPutMultipartOptionalRequestBody(
        input: operations.RequestBodyPutMultipartOptionalRequestBodyRequestBody | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartOptionalRequestBodyResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) =>
                operations.RequestBodyPutMultipartOptionalRequestBodyRequestBody$.outboundSchema
                    .optional()
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();
        if (payload$ != null) {
            if (payload$?.sampleField !== undefined) {
                body$.append("sampleField", payload$?.sampleField);
            }
            if (payload$?.sampleFile !== undefined) {
                if (isBlobLike(payload$?.sampleFile)) {
                    body$.append("sampleFile", payload$?.sampleFile);
                } else {
                    body$.append(
                        "sampleFile",
                        new Blob([payload$?.sampleFile.content], {
                            type: "application/octet-stream",
                        }),
                        payload$?.sampleFile.fileName
                    );
                }
            }
        }

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/put/multipart/optionalRequestBody"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartOptionalRequestBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPutMultipartOptionalRequestBodyResponse$.inboundSchema.parse(
                        {
                            ...responseFields$,
                            res: val$,
                        }
                    );
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPutMultipartSimple(
        input: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartSimpleResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.SimpleObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("bool", String(payload$.bool));
        body$.append("date", payload$.date);
        body$.append("dateTime", payload$.dateTime);
        body$.append("enum", String(payload$.enum));
        body$.append("float32", String(payload$.float32));
        body$.append("int", String(payload$.int));
        body$.append("int32", String(payload$.int32));
        body$.append("int32Enum", String(payload$.int32Enum));
        body$.append("intEnum", String(payload$.intEnum));
        body$.append("num", String(payload$.num));
        body$.append("str", payload$.str);
        if (payload$.any !== undefined) {
            body$.append("any", String(payload$.any));
        }
        if (payload$.bigint !== undefined) {
            body$.append("bigint", String(payload$.bigint));
        }
        if (payload$.bigintStr !== undefined) {
            body$.append("bigintStr", payload$.bigintStr);
        }
        if (payload$.boolOpt !== undefined) {
            body$.append("boolOpt", String(payload$.boolOpt));
        }
        if (payload$.decimal !== undefined) {
            body$.append("decimal", String(payload$.decimal));
        }
        if (payload$.decimalStr !== undefined) {
            body$.append("decimalStr", payload$.decimalStr);
        }
        if (payload$.intOptNull !== undefined) {
            body$.append("intOptNull", String(payload$.intOptNull));
        }
        if (payload$.numOptNull !== undefined) {
            body$.append("numOptNull", String(payload$.numOptNull));
        }
        if (payload$.strOpt !== undefined) {
            body$.append("strOpt", payload$.strOpt);
        }

        const path$ = this.templateURLComponent("/anything/requestBodies/put/multipart/simple")();

        const query$ = "";

        headers$.set(
            "any",
            enc$.encodeSimple("any", payload$.any, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigint",
            enc$.encodeSimple("bigint", payload$.bigint, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "bigintStr",
            enc$.encodeSimple("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "bool",
            enc$.encodeSimple("bool", payload$.bool, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "boolOpt",
            enc$.encodeSimple("boolOpt", payload$.boolOpt, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "date",
            enc$.encodeSimple("date", payload$.date, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "dateTime",
            enc$.encodeSimple("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "decimal",
            enc$.encodeSimple("decimal", payload$.decimal, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "decimalStr",
            enc$.encodeSimple("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "enum",
            enc$.encodeSimple("enum", payload$.enum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "float32",
            enc$.encodeSimple("float32", payload$.float32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int",
            enc$.encodeSimple("int", payload$.int, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32",
            enc$.encodeSimple("int32", payload$.int32, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "int32Enum",
            enc$.encodeSimple("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "intEnum",
            enc$.encodeSimple("intEnum", payload$.intEnum, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "intOptNull",
            enc$.encodeSimple("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "num",
            enc$.encodeSimple("num", payload$.num, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "numOptNull",
            enc$.encodeSimple("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            })
        );
        headers$.set(
            "str",
            enc$.encodeSimple("str", payload$.str, { explode: false, charEncoding: "none" })
        );
        headers$.set(
            "strOpt",
            enc$.encodeSimple("strOpt", payload$.strOpt, { explode: false, charEncoding: "none" })
        );

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPutMultipartSimpleResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPutString(
        input: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutStringResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "text/plain");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => z.string().parse(value$),
            "Input validation failed"
        );
        const body$ = payload$;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/string")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutString",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPutStringResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyPutStringWithParams(
        requestBody: string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutStringWithParamsResponse> {
        const input$: operations.RequestBodyPutStringWithParamsRequest = {
            requestBody: requestBody,
            queryStringParam: queryStringParam,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "text/plain");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutStringWithParamsRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = payload$.RequestBody;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/stringWithParams")();

        const query$ = [
            enc$.encodeForm("queryStringParam", payload$.queryStringParam, {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutStringWithParams",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyPutStringWithParamsResponse$.inboundSchema.parse({
                        ...responseFields$,
                        res: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyReadAndWrite(
        input: shared.ReadWriteObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyReadAndWriteResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.ReadWriteObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(operations.RequestBodyReadAndWriteServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyandwriteonly")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadAndWrite",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyReadAndWriteResponse$.inboundSchema.parse({
                        ...responseFields$,
                        readWriteObject: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyReadOnlyInput(
        _input: shared.ReadOnlyObjectInput,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyReadOnlyInputResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(operations.RequestBodyReadOnlyInputServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyorwriteonly#readOnlyInput")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadOnlyInput",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyReadOnlyInputResponse$.inboundSchema.parse({
                        ...responseFields$,
                        readOnlyObject: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyReadOnlyUnion(
        input: shared.WeaklyTypedOneOfReadOnlyObjectInput,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyReadOnlyUnionResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.WeaklyTypedOneOfReadOnlyObjectInput$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(operations.RequestBodyReadOnlyUnionServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyorwriteonly#readOnlyUnion")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyReadOnlyUnionResponse$.inboundSchema.parse({
                        ...responseFields$,
                        weaklyTypedOneOfReadOnlyObject: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyReadWriteOnlyUnion(
        input: shared.WeaklyTypedOneOfReadWriteObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyReadWriteOnlyUnionResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.WeaklyTypedOneOfReadWriteObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(operations.RequestBodyReadWriteOnlyUnionServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyandwriteonly#readWriteOnlyUnion")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadWriteOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyReadWriteOnlyUnionResponse$.inboundSchema.parse({
                        ...responseFields$,
                        weaklyTypedOneOfReadWriteObject: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyWriteOnly(
        input: shared.WriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyWriteOnlyResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.WriteOnlyObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(operations.RequestBodyWriteOnlyServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyorwriteonly#writeOnly")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyWriteOnly",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyWriteOnlyResponse$.inboundSchema.parse({
                        ...responseFields$,
                        readOnlyObject: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyWriteOnlyOutput(
        input: shared.WriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyWriteOnlyOutputResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.WriteOnlyObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(operations.RequestBodyWriteOnlyOutputServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/writeonlyoutput#writeOnlyOutput")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyWriteOnlyOutput",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyWriteOnlyOutputResponse$.inboundSchema.parse({
                        ...responseFields$,
                        writeOnlyObject: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }

    async requestBodyWriteOnlyUnion(
        input: shared.WeaklyTypedOneOfWriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.RequestBodyWriteOnlyUnionResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input,
            (value$) => shared.WeaklyTypedOneOfWriteOnlyObject$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(operations.RequestBodyWriteOnlyUnionServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/writeonlyoutput#writeOnlyUnion")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyWriteOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request = this.createRequest$(
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
        };

        if (this.matchResponse(response, 200, "application/json")) {
            const responseBody = await response.json();
            const result = schemas$.parse(
                responseBody,
                (val$) => {
                    return operations.RequestBodyWriteOnlyUnionResponse$.inboundSchema.parse({
                        ...responseFields$,
                        weaklyTypedOneOfWriteOnlyObject: val$,
                    });
                },
                "Response validation failed"
            );
            return result;
        } else {
            const responseBody = await response.text();
            throw new errors.SDKError("Unexpected API response", response, responseBody);
        }
    }
}
