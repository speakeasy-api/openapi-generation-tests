/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import * as b64$ from "../lib/base64.js";
import { SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeBodyForm as encodeBodyForm$,
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
    encodeSimple as encodeSimple$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "./models/operations/index.js";
import { RequestBodyPostApplicationJsonArrayServerList } from "./models/operations/requestbodypostapplicationjsonarray.js";
import { RequestBodyPostApplicationJsonArrayCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonarraycamelcase.js";
import { RequestBodyPostApplicationJsonArrayOfArrayServerList } from "./models/operations/requestbodypostapplicationjsonarrayofarray.js";
import { RequestBodyPostApplicationJsonArrayOfArrayCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonarrayofarraycamelcase.js";
import { RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonarrayofarrayofprimitive.js";
import { RequestBodyPostApplicationJsonArrayOfMapServerList } from "./models/operations/requestbodypostapplicationjsonarrayofmap.js";
import { RequestBodyPostApplicationJsonArrayOfMapCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonarrayofmapcamelcase.js";
import { RequestBodyPostApplicationJsonArrayOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonarrayofprimitive.js";
import { RequestBodyPostApplicationJsonMapServerList } from "./models/operations/requestbodypostapplicationjsonmap.js";
import { RequestBodyPostApplicationJsonMapCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonmapcamelcase.js";
import { RequestBodyPostApplicationJsonMapOfArrayServerList } from "./models/operations/requestbodypostapplicationjsonmapofarray.js";
import { RequestBodyPostApplicationJsonMapOfArrayCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonmapofarraycamelcase.js";
import { RequestBodyPostApplicationJsonMapOfMapServerList } from "./models/operations/requestbodypostapplicationjsonmapofmap.js";
import { RequestBodyPostApplicationJsonMapOfMapCamelCaseServerList } from "./models/operations/requestbodypostapplicationjsonmapofmapcamelcase.js";
import { RequestBodyPostApplicationJsonMapOfMapOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonmapofmapofprimitive.js";
import { RequestBodyPostApplicationJsonMapOfPrimitiveServerList } from "./models/operations/requestbodypostapplicationjsonmapofprimitive.js";
import { RequestBodyReadAndWriteServerList } from "./models/operations/requestbodyreadandwrite.js";
import { RequestBodyReadOnlyInputServerList } from "./models/operations/requestbodyreadonlyinput.js";
import { RequestBodyReadOnlyUnionServerList } from "./models/operations/requestbodyreadonlyunion.js";
import { RequestBodyReadWriteOnlyUnionServerList } from "./models/operations/requestbodyreadwriteonlyunion.js";
import { RequestBodyWriteOnlyServerList } from "./models/operations/requestbodywriteonly.js";
import { RequestBodyWriteOnlyOutputServerList } from "./models/operations/requestbodywriteonlyoutput.js";
import { RequestBodyWriteOnlyUnionServerList } from "./models/operations/requestbodywriteonlyunion.js";
import * as shared from "./models/shared/index.js";
import { isBlobLike } from "./types/blobs.js";
import { Decimal as Decimal$ } from "./types/decimal.js";
import { RFCDate } from "./types/rfcdate.js";
import * as z from "zod";

export class RequestBodies extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    async nullEnumPost(
        request: shared.ObjectWithNullEnums,
        options?: RequestOptions
    ): Promise<operations.NullEnumPostRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ObjectWithNullEnums$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/nullEnum")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullEnumPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.NullEnumPostRes>()
            .json(200, operations.NullEnumPostRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async nullableObjectPost(
        request: shared.NullableObject | null,
        options?: RequestOptions
    ): Promise<operations.NullableObjectPostRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.nullable(shared.NullableObject$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredObject"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.NullableObjectPostRes>()
            .json(200, operations.NullableObjectPostRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async nullableOptionalFieldsPost(
        request: operations.NullableOptionalFieldsPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableOptionalFieldsPostResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.NullableOptionalFieldsPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableOptionalFields"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableOptionalFieldsPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.NullableOptionalFieldsPostResponseBody>()
            .json(200, operations.NullableOptionalFieldsPostResponseBody$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async nullableRequiredEmptyObjectPost(
        request: operations.NullableRequiredEmptyObjectPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredEmptyObjectPostResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.NullableRequiredEmptyObjectPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredEmptyObject"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableRequiredEmptyObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.NullableRequiredEmptyObjectPostResponseBody>()
                .json(200, operations.NullableRequiredEmptyObjectPostResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async nullableRequiredPropertyPost(
        request: operations.NullableRequiredPropertyPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredPropertyPostResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.NullableRequiredPropertyPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredProperty"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableRequiredPropertyPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.NullableRequiredPropertyPostResponseBody>()
            .json(200, operations.NullableRequiredPropertyPostResponseBody$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async nullableRequiredSharedObjectPost(
        request: operations.NullableRequiredSharedObjectPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.NullableRequiredSharedObjectPostResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.NullableRequiredSharedObjectPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullableRequiredSharedObject"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "nullableRequiredSharedObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.NullableRequiredSharedObjectPostResponseBody>()
                .json(200, operations.NullableRequiredSharedObjectPostResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonArray(
        request: Array<shared.SimpleObject>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<shared.SimpleObject>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(shared.SimpleObject$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonArrayServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#array")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<Array<shared.SimpleObject>>()
            .json(200, z.array(shared.SimpleObject$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonArrayCamelCase(
        request: Array<shared.SimpleObjectCamelCase>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<shared.SimpleObjectCamelCase>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(shared.SimpleObjectCamelCase$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonArrayCamelCaseServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#arrayCamelCase")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<Array<shared.SimpleObjectCamelCase>>()
            .json(200, z.array(shared.SimpleObjectCamelCase$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonArrayObj(
        request: Array<shared.SimpleObject>,
        options?: RequestOptions
    ): Promise<shared.ArrObjValue> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(shared.SimpleObject$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/array/objResponse"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayObj",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<shared.ArrObjValue>()
            .json(200, shared.ArrObjValue$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonArrayObjCamelCase(
        request: Array<shared.SimpleObjectCamelCase>,
        options?: RequestOptions
    ): Promise<shared.ArrObjValueCamelCase> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(shared.SimpleObjectCamelCase$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/array/objResponseCamelCase"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayObjCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<shared.ArrObjValueCamelCase>()
            .json(200, shared.ArrObjValueCamelCase$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfArray(
        request: Array<Array<shared.SimpleObject>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<Array<shared.SimpleObject>>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.array(shared.SimpleObject$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonArrayOfArrayServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#arrayOfArrays")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<Array<Array<shared.SimpleObject>>>()
            .json(200, z.array(z.array(shared.SimpleObject$inboundSchema)))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfArrayCamelCase(
        request: Array<Array<shared.SimpleObjectCamelCase>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<Array<shared.SimpleObjectCamelCase>>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.array(shared.SimpleObjectCamelCase$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonArrayOfArrayCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfArraysCamelCase")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<Array<Array<shared.SimpleObjectCamelCase>>>()
            .json(200, z.array(z.array(shared.SimpleObjectCamelCase$inboundSchema)))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfArrayOfPrimitive(
        request: Array<Array<string>>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<Array<string>>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.array(z.string())).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonArrayOfArrayOfPrimitiveServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfArraysOfPrimitives")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfArrayOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<Array<Array<string>>>()
            .json(200, z.array(z.array(z.string())))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfMap(
        request: Array<{ [k: string]: shared.SimpleObject }>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<{ [k: string]: shared.SimpleObject }>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.record(shared.SimpleObject$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonArrayOfMapServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#arrayOfMaps")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<Array<{ [k: string]: shared.SimpleObject }>>()
            .json(200, z.array(z.record(shared.SimpleObject$inboundSchema)))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfMapCamelCase(
        request: Array<{ [k: string]: shared.SimpleObjectCamelCase }>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<{ [k: string]: shared.SimpleObjectCamelCase }>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z.array(z.record(shared.SimpleObjectCamelCase$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonArrayOfMapCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#arrayOfMapsCamelCase")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<Array<{ [k: string]: shared.SimpleObjectCamelCase }>>()
            .json(200, z.array(z.record(shared.SimpleObjectCamelCase$inboundSchema)))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonArrayOfPrimitive(
        request: Array<string>,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Array<string>> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonArrayOfPrimitiveServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#arrayOfPrimitives")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonArrayOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<Array<string>>()
            .json(200, z.array(z.string()))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonDeep(
        request: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonDeepRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DeepObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/deep"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPostApplicationJsonDeepRes>()
            .json(200, operations.RequestBodyPostApplicationJsonDeepRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonDeepCamelCase(
        request: shared.DeepObjectCamelCase,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonDeepCamelCaseRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DeepObjectCamelCase$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/deep/camelcase"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonDeepCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonDeepCamelCaseRes>()
                .json(200, operations.RequestBodyPostApplicationJsonDeepCamelCaseRes$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonMap(
        request: { [k: string]: shared.SimpleObject },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: shared.SimpleObject }> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(shared.SimpleObject$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonMapServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#map")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<{ [k: string]: shared.SimpleObject }>()
            .json(200, z.record(shared.SimpleObject$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonMapCamelCase(
        request: { [k: string]: shared.SimpleObjectCamelCase },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: shared.SimpleObjectCamelCase }> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(shared.SimpleObjectCamelCase$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonMapCamelCaseServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#mapCamelCase")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<{ [k: string]: shared.SimpleObjectCamelCase }>()
            .json(200, z.record(shared.SimpleObjectCamelCase$inboundSchema))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonMapObj(
        request: { [k: string]: shared.SimpleObject },
        options?: RequestOptions
    ): Promise<shared.MapObjValue> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(shared.SimpleObject$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/map/objResponse"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapObj",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<shared.MapObjValue>()
            .json(200, shared.MapObjValue$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonMapObjCamelCase(
        request: { [k: string]: shared.SimpleObjectCamelCase },
        options?: RequestOptions
    ): Promise<shared.MapObjValueCamelCase> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(shared.SimpleObjectCamelCase$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/map/objResponseCamelCase"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapObjCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<shared.MapObjValueCamelCase>()
            .json(200, shared.MapObjValueCamelCase$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfArray(
        request: { [k: string]: Array<shared.SimpleObject> },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: Array<shared.SimpleObject> }> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.array(shared.SimpleObject$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonMapOfArrayServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#mapOfArrays")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<{ [k: string]: Array<shared.SimpleObject> }>()
            .json(200, z.record(z.array(shared.SimpleObject$inboundSchema)))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfArrayCamelCase(
        request: { [k: string]: Array<shared.SimpleObjectCamelCase> },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: Array<shared.SimpleObjectCamelCase> }> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z.record(z.array(shared.SimpleObjectCamelCase$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonMapOfArrayCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfArraysCamelCase")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfArrayCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<{ [k: string]: Array<shared.SimpleObjectCamelCase> }>()
            .json(200, z.record(z.array(shared.SimpleObjectCamelCase$inboundSchema)))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfMap(
        request: { [k: string]: { [k: string]: shared.SimpleObject } },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: { [k: string]: shared.SimpleObject } }> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.record(shared.SimpleObject$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonMapOfMapServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#mapOfMaps")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<{
            [k: string]: { [k: string]: shared.SimpleObject };
        }>()
            .json(200, z.record(z.record(shared.SimpleObject$inboundSchema)))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfMapCamelCase(
        request: { [k: string]: { [k: string]: shared.SimpleObjectCamelCase } },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: { [k: string]: shared.SimpleObjectCamelCase } }> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z.record(z.record(shared.SimpleObjectCamelCase$outboundSchema)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonMapOfMapCamelCaseServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfMapsCamelCase")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMapCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<{
            [k: string]: { [k: string]: shared.SimpleObjectCamelCase };
        }>()
            .json(200, z.record(z.record(shared.SimpleObjectCamelCase$inboundSchema)))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfMapOfPrimitive(
        request: { [k: string]: { [k: string]: string } },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: { [k: string]: string } }> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.record(z.string())).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(
                RequestBodyPostApplicationJsonMapOfMapOfPrimitiveServerList[0],
                { charEncoding: "percent" }
            )();

        const path$ = this.templateURLComponent("/requestbody#mapOfMapsOfPrimitives")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfMapOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<{ [k: string]: { [k: string]: string } }>()
            .json(200, z.record(z.record(z.string())))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonMapOfPrimitive(
        request: { [k: string]: string },
        options?: RequestOptions & { serverURL?: string }
    ): Promise<{ [k: string]: string }> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyPostApplicationJsonMapOfPrimitiveServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/requestbody#mapOfPrimitives")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMapOfPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<{ [k: string]: string }>()
            .json(200, z.record(z.string()))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonMultipleJsonFiltered(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonMultipleJsonFilteredRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/multiple/json/filtered"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            any: encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" }),
            bigint: encodeSimple$("bigint", payload$.bigint, {
                explode: false,
                charEncoding: "none",
            }),
            bigintStr: encodeSimple$("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            }),
            bool: encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" }),
            boolOpt: encodeSimple$("boolOpt", payload$.boolOpt, {
                explode: false,
                charEncoding: "none",
            }),
            date: encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" }),
            dateTime: encodeSimple$("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            }),
            decimal: encodeSimple$("decimal", payload$.decimal, {
                explode: false,
                charEncoding: "none",
            }),
            decimalStr: encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            }),
            enum: encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" }),
            float32: encodeSimple$("float32", payload$.float32, {
                explode: false,
                charEncoding: "none",
            }),
            float64Str: encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            }),
            int: encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" }),
            int32: encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" }),
            int32Enum: encodeSimple$("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            }),
            int64Str: encodeSimple$("int64Str", payload$.int64Str, {
                explode: false,
                charEncoding: "none",
            }),
            intEnum: encodeSimple$("intEnum", payload$.intEnum, {
                explode: false,
                charEncoding: "none",
            }),
            intOptNull: encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            num: encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" }),
            numOptNull: encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            str: encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" }),
            strOpt: encodeSimple$("strOpt", payload$.strOpt, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonMultipleJsonFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonMultipleJsonFilteredRes>()
                .json(
                    200,
                    operations.RequestBodyPostApplicationJsonMultipleJsonFilteredRes$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonSimple(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonSimpleRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/simple"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            any: encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" }),
            bigint: encodeSimple$("bigint", payload$.bigint, {
                explode: false,
                charEncoding: "none",
            }),
            bigintStr: encodeSimple$("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            }),
            bool: encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" }),
            boolOpt: encodeSimple$("boolOpt", payload$.boolOpt, {
                explode: false,
                charEncoding: "none",
            }),
            date: encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" }),
            dateTime: encodeSimple$("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            }),
            decimal: encodeSimple$("decimal", payload$.decimal, {
                explode: false,
                charEncoding: "none",
            }),
            decimalStr: encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            }),
            enum: encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" }),
            float32: encodeSimple$("float32", payload$.float32, {
                explode: false,
                charEncoding: "none",
            }),
            float64Str: encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            }),
            int: encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" }),
            int32: encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" }),
            int32Enum: encodeSimple$("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            }),
            int64Str: encodeSimple$("int64Str", payload$.int64Str, {
                explode: false,
                charEncoding: "none",
            }),
            intEnum: encodeSimple$("intEnum", payload$.intEnum, {
                explode: false,
                charEncoding: "none",
            }),
            intOptNull: encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            num: encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" }),
            numOptNull: encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            str: encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" }),
            strOpt: encodeSimple$("strOpt", payload$.strOpt, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPostApplicationJsonSimpleRes>()
            .json(200, operations.RequestBodyPostApplicationJsonSimpleRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostApplicationJsonSimpleCamelCase(
        request: shared.SimpleObjectCamelCase,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostApplicationJsonSimpleCamelCaseRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObjectCamelCase$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/application/json/camelcase"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostApplicationJsonSimpleCamelCase",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostApplicationJsonSimpleCamelCaseRes>()
                .json(
                    200,
                    operations.RequestBodyPostApplicationJsonSimpleCamelCaseRes$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostComplexNumberTypes(
        request: operations.RequestBodyPostComplexNumberTypesRequest,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostComplexNumberTypesResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostComplexNumberTypesRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.complexNumberTypes, { explode: true });

        const pathParams$ = {
            pathBigInt: encodeSimple$("pathBigInt", payload$.pathBigInt, {
                explode: false,
                charEncoding: "percent",
            }),
            pathBigIntStr: encodeSimple$("pathBigIntStr", payload$.pathBigIntStr, {
                explode: false,
                charEncoding: "percent",
            }),
            pathDecimal: encodeSimple$("pathDecimal", payload$.pathDecimal, {
                explode: false,
                charEncoding: "percent",
            }),
            pathDecimalStr: encodeSimple$("pathDecimalStr", payload$.pathDecimalStr, {
                explode: false,
                charEncoding: "percent",
            }),
        };
        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/{pathBigInt}/{pathBigIntStr}/{pathDecimal}/{pathDecimalStr}/complex-number-types"
        )(pathParams$);

        const query$ = encodeFormQuery$({
            queryBigInt: payload$.queryBigInt,
            queryBigIntStr: payload$.queryBigIntStr,
            queryDecimal: payload$.queryDecimal,
            queryDecimalStr: payload$.queryDecimalStr,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostComplexNumberTypes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostComplexNumberTypesResponseBody>()
                .json(200, operations.RequestBodyPostComplexNumberTypesResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostDefaultsAndConsts(
        request: shared.DefaultsAndConsts,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostDefaultsAndConstsResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DefaultsAndConsts$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/defaultsAndConsts")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostDefaultsAndConsts",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostDefaultsAndConstsResponseBody>()
                .json(200, operations.RequestBodyPostDefaultsAndConstsResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostEmptyObject(
        request: operations.RequestBodyPostEmptyObjectRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostEmptyObjectResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostEmptyObjectRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/empty-object")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostEmptyObject",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPostEmptyObjectResponseBody>()
            .json(200, operations.RequestBodyPostEmptyObjectResponseBody$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostFormDeep(
        request: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormDeepRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DeepObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent("/anything/requestBodies/post/form/deep")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostFormDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPostFormDeepRes>()
            .json(200, operations.RequestBodyPostFormDeepRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostFormMapPrimitive(
        request: { [k: string]: string },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormMapPrimitiveRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/form/map/primitive"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostFormMapPrimitive",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPostFormMapPrimitiveRes>()
            .json(200, operations.RequestBodyPostFormMapPrimitiveRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostFormSimple(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostFormSimpleRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent("/anything/requestBodies/post/form/simple")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
            any: encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" }),
            bigint: encodeSimple$("bigint", payload$.bigint, {
                explode: false,
                charEncoding: "none",
            }),
            bigintStr: encodeSimple$("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            }),
            bool: encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" }),
            boolOpt: encodeSimple$("boolOpt", payload$.boolOpt, {
                explode: false,
                charEncoding: "none",
            }),
            date: encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" }),
            dateTime: encodeSimple$("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            }),
            decimal: encodeSimple$("decimal", payload$.decimal, {
                explode: false,
                charEncoding: "none",
            }),
            decimalStr: encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            }),
            enum: encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" }),
            float32: encodeSimple$("float32", payload$.float32, {
                explode: false,
                charEncoding: "none",
            }),
            float64Str: encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            }),
            int: encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" }),
            int32: encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" }),
            int32Enum: encodeSimple$("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            }),
            int64Str: encodeSimple$("int64Str", payload$.int64Str, {
                explode: false,
                charEncoding: "none",
            }),
            intEnum: encodeSimple$("intEnum", payload$.intEnum, {
                explode: false,
                charEncoding: "none",
            }),
            intOptNull: encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            num: encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" }),
            numOptNull: encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            str: encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" }),
            strOpt: encodeSimple$("strOpt", payload$.strOpt, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostFormSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPostFormSimpleRes>()
            .json(200, operations.RequestBodyPostFormSimpleRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesArrayBigInt(
        request: Array<bigint>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayBigIntResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.bigint().transform((v) => Number(v))).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/array/bigInt"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayBigInt",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesArrayBigIntResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostJsonDataTypesArrayBigIntResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesArrayDate(
        request: Array<RFCDate>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayDateResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.instanceof(RFCDate).transform((v) => v.toString())).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/array/date"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayDate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesArrayDateResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostJsonDataTypesArrayDateResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesArrayDecimalStr(
        request: Array<Decimal$ | number>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesArrayDecimalStrResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .array(z.union([z.instanceof(Decimal$), z.number()]).transform((v) => `${v}`))
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/array/decimalStr"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesArrayDecimalStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesArrayDecimalStrResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostJsonDataTypesArrayDecimalStrResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesBigInt(
        request: bigint,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBigIntResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .bigint()
                    .transform((v) => Number(v))
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/bigint"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesBigInt",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesBigIntResponseBody>()
                .json(200, operations.RequestBodyPostJsonDataTypesBigIntResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesBigIntStr(
        request: bigint,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBigIntStrResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .bigint()
                    .transform((v) => `${v}`)
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/bigintStr"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesBigIntStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesBigIntStrResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostJsonDataTypesBigIntStrResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesBoolean(
        request: boolean,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesBooleanResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.boolean().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/boolean"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesBoolean",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesBooleanResponseBody>()
                .json(200, operations.RequestBodyPostJsonDataTypesBooleanResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesComplexNumberArrays(
        request: shared.ComplexNumberArrays,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesComplexNumberArraysRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ComplexNumberArrays$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/complexNumberArrays"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesComplexNumberArrays",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesComplexNumberArraysRes>()
                .json(
                    200,
                    operations.RequestBodyPostJsonDataTypesComplexNumberArraysRes$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesComplexNumberMaps(
        request: shared.ComplexNumberMaps,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesComplexNumberMapsRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ComplexNumberMaps$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/complexNumberMaps"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesComplexNumberMaps",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesComplexNumberMapsRes>()
                .json(
                    200,
                    operations.RequestBodyPostJsonDataTypesComplexNumberMapsRes$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesDate(
        request: RFCDate,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDateResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .instanceof(RFCDate)
                    .transform((v) => v.toString())
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/date"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesDateResponseBody>()
                .json(200, operations.RequestBodyPostJsonDataTypesDateResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesDateTime(
        request: Date,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDateTimeResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .date()
                    .transform((v) => v.toISOString())
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/dateTime"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDateTime",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesDateTimeResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostJsonDataTypesDateTimeResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesDecimal(
        request: Decimal$ | number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDecimalResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .union([z.instanceof(Decimal$), z.number()])
                    .transform((v) => (typeof v === "number" ? v : v.toNumber()))
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/decimal"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDecimal",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesDecimalResponseBody>()
                .json(200, operations.RequestBodyPostJsonDataTypesDecimalResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesDecimalStr(
        request: Decimal$ | number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesDecimalStrResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .union([z.instanceof(Decimal$), z.number()])
                    .transform((v) => `${v}`)
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/decimalStr"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesDecimalStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesDecimalStrResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostJsonDataTypesDecimalStrResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesFloat32(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesFloat32ResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.number().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/float32"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesFloat32",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesFloat32ResponseBody>()
                .json(200, operations.RequestBodyPostJsonDataTypesFloat32ResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesInt32(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesInt32ResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.number().int().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/int32"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesInt32",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesInt32ResponseBody>()
                .json(200, operations.RequestBodyPostJsonDataTypesInt32ResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesInteger(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesIntegerResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.number().int().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/integer"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesInteger",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesIntegerResponseBody>()
                .json(200, operations.RequestBodyPostJsonDataTypesIntegerResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesMapBigIntStr(
        request: { [k: string]: bigint },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapBigIntStrResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.bigint().transform((v) => `${v}`)).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/map/bigIntStr"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesMapBigIntStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesMapBigIntStrResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostJsonDataTypesMapBigIntStrResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesMapDateTime(
        request: { [k: string]: Date },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapDateTimeResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.date().transform((v) => v.toISOString())).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/map/dateTime"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesMapDateTime",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesMapDateTimeResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostJsonDataTypesMapDateTimeResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesMapDecimal(
        request: { [k: string]: Decimal$ | number },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesMapDecimalResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .record(
                        z
                            .union([z.instanceof(Decimal$), z.number()])
                            .transform((v) => (typeof v === "number" ? v : v.toNumber()))
                    )
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/map/decimal"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesMapDecimal",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesMapDecimalResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostJsonDataTypesMapDecimalResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesNumber(
        request: number,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesNumberResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.number().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/number"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesNumber",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesNumberResponseBody>()
                .json(200, operations.RequestBodyPostJsonDataTypesNumberResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostJsonDataTypesString(
        request: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostJsonDataTypesStringResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.string().parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/jsonDataTypes/string"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostJsonDataTypesString",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostJsonDataTypesStringResponseBody>()
                .json(200, operations.RequestBodyPostJsonDataTypesStringResponseBody$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostMultipleContentTypesComponentFiltered(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesComponentFilteredRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/component/filtered"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            any: encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" }),
            bigint: encodeSimple$("bigint", payload$.bigint, {
                explode: false,
                charEncoding: "none",
            }),
            bigintStr: encodeSimple$("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            }),
            bool: encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" }),
            boolOpt: encodeSimple$("boolOpt", payload$.boolOpt, {
                explode: false,
                charEncoding: "none",
            }),
            date: encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" }),
            dateTime: encodeSimple$("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            }),
            decimal: encodeSimple$("decimal", payload$.decimal, {
                explode: false,
                charEncoding: "none",
            }),
            decimalStr: encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            }),
            enum: encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" }),
            float32: encodeSimple$("float32", payload$.float32, {
                explode: false,
                charEncoding: "none",
            }),
            float64Str: encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            }),
            int: encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" }),
            int32: encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" }),
            int32Enum: encodeSimple$("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            }),
            int64Str: encodeSimple$("int64Str", payload$.int64Str, {
                explode: false,
                charEncoding: "none",
            }),
            intEnum: encodeSimple$("intEnum", payload$.intEnum, {
                explode: false,
                charEncoding: "none",
            }),
            intOptNull: encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            num: encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" }),
            numOptNull: encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            str: encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" }),
            strOpt: encodeSimple$("strOpt", payload$.strOpt, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesComponentFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesComponentFilteredRes>()
                .json(
                    200,
                    operations.RequestBodyPostMultipleContentTypesComponentFilteredRes$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostMultipleContentTypesInlineFiltered(
        request: operations.RequestBodyPostMultipleContentTypesInlineFilteredRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesInlineFilteredRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesInlineFilteredRequestBody$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/inline/filtered"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesInlineFiltered",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesInlineFilteredRes>()
                .json(
                    200,
                    operations.RequestBodyPostMultipleContentTypesInlineFilteredRes$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitParamForm(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamFormRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamFormRes> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamFormRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamFormRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$.RequestBody || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = encodeFormQuery$({
            paramStr: payload$.paramStr,
        });

        const headers$ = new Headers({
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_form",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitParamFormRes>()
                .json(
                    200,
                    operations.RequestBodyPostMultipleContentTypesSplitParamFormRes$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitParamJson(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamJsonRes> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamJsonRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$.RequestBody, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = encodeFormQuery$({
            paramStr: payload$.paramStr,
        });

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_json",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitParamJsonRes>()
                .json(
                    200,
                    operations.RequestBodyPostMultipleContentTypesSplitParamJsonRes$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitParamMultipart(
        requestBody: operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequestBody,
        paramStr: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRes> {
        const input$: operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequest = {
            requestBody: requestBody,
            paramStr: paramStr,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRequest$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("bool2", String(payload$.RequestBody.bool2));
        body$.append("num2", String(payload$.RequestBody.num2));
        body$.append("str2", payload$.RequestBody.str2);

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split/param"
        )();

        const query$ = encodeFormQuery$({
            paramStr: payload$.paramStr,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplitParam_multipart",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRes>()
                .json(
                    200,
                    operations.RequestBodyPostMultipleContentTypesSplitParamMultipartRes$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitForm(
        request: operations.RequestBodyPostMultipleContentTypesSplitFormRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitFormRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitFormRequestBody$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = Object.entries(payload$ || {})
            .map(([k, v]) => {
                return encodeBodyForm$(k, v, { charEncoding: "percent" });
            })
            .join("&");

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/x-www-form-urlencoded",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_form",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitFormRes>()
                .json(200, operations.RequestBodyPostMultipleContentTypesSplitFormRes$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitJson(
        request: operations.RequestBodyPostMultipleContentTypesSplitJsonRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitJsonRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitJsonRequestBody$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_json",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitJsonRes>()
                .json(200, operations.RequestBodyPostMultipleContentTypesSplitJsonRes$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostMultipleContentTypesSplitMultipart(
        request: operations.RequestBodyPostMultipleContentTypesSplitMultipartRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostMultipleContentTypesSplitMultipartRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPostMultipleContentTypesSplitMultipartRequestBody$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("bool2", String(payload$.bool2));
        body$.append("num2", String(payload$.num2));
        body$.append("str2", payload$.str2);

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/multiple/contentTypes/split"
        )();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostMultipleContentTypesSplit_multipart",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostMultipleContentTypesSplitMultipartRes>()
                .json(
                    200,
                    operations.RequestBodyPostMultipleContentTypesSplitMultipartRes$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostNotNullableNotRequiredStringBody(
        request?: string | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNotNullableNotRequiredStringBodyResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.string().optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/notnullable/notrequired/string"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNotNullableNotRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostNotNullableNotRequiredStringBodyResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostNotNullableNotRequiredStringBodyResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostNullArray(
        request: Array<string>,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullArrayResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.array(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/null-array")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullArray",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPostNullArrayResponseBody>()
            .json(200, operations.RequestBodyPostNullArrayResponseBody$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostNullDictionary(
        request: { [k: string]: string },
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullDictionaryResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.record(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/requestBodies/post/null-dictionary")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullDictionary",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPostNullDictionaryResponseBody>()
            .json(200, operations.RequestBodyPostNullDictionaryResponseBody$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPostNullableNotRequiredStringBody(
        request?: string | null | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullableNotRequiredStringBodyResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.nullable(z.string()).optional().parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullable/notrequired/string"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullableNotRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostNullableNotRequiredStringBodyResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostNullableNotRequiredStringBodyResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPostNullableRequiredStringBody(
        request: string | null,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPostNullableRequiredStringBodyResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.nullable(z.string()).parse(value$),
            "Input validation failed"
        );
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/post/nullable/required/string"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPostNullableRequiredStringBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPostNullableRequiredStringBodyResponseBody>()
                .json(
                    200,
                    operations.RequestBodyPostNullableRequiredStringBodyResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPutBytes(
        request: Uint8Array | string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutBytesRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => b64$.zodOutbound.parse(value$),
            "Input validation failed"
        );
        const body$ = payload$;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/bytes")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/octet-stream",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutBytes",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPutBytesRes>()
            .json(200, operations.RequestBodyPutBytesRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPutBytesWithParams(
        requestBody: Uint8Array | string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutBytesWithParamsRes> {
        const input$: operations.RequestBodyPutBytesWithParamsRequest = {
            requestBody: requestBody,
            queryStringParam: queryStringParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutBytesWithParamsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = payload$.RequestBody;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/bytesWithParams")();

        const query$ = encodeFormQuery$({
            queryStringParam: payload$.queryStringParam,
        });

        const headers$ = new Headers({
            "Content-Type": "application/octet-stream",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutBytesWithParams",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPutBytesWithParamsRes>()
            .json(200, operations.RequestBodyPutBytesWithParamsRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPutMultipartDeep(
        request: shared.DeepObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartDeepRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.DeepObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("any", encodeJSON$("any", payload$.any, { explode: true }));
        body$.append("arr", encodeJSON$("arr", payload$.arr, { explode: true }));
        body$.append("bool", String(payload$.bool));
        body$.append("int", String(payload$.int));
        body$.append("map", encodeJSON$("map", payload$.map, { explode: true }));
        body$.append("num", String(payload$.num));
        body$.append("obj", encodeJSON$("obj", payload$.obj, { explode: true }));
        body$.append("str", payload$.str);
        if (payload$.type !== undefined) {
            body$.append("type", payload$.type);
        }

        const path$ = this.templateURLComponent("/anything/requestBodies/put/multipart/deep")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartDeep",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPutMultipartDeepRes>()
            .json(200, operations.RequestBodyPutMultipartDeepRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPutMultipartDifferentFileName(
        request: operations.RequestBodyPutMultipartDifferentFileNameRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartDifferentFileNameRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutMultipartDifferentFileNameRequestBody$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = new FormData();

        if (payload$.differentFileName !== undefined) {
            if (isBlobLike(payload$.differentFileName)) {
                body$.append("differentFileName", payload$.differentFileName);
            } else {
                body$.append(
                    "differentFileName",
                    new Blob([payload$.differentFileName.content], {
                        type: "application/octet-stream",
                    }),
                    payload$.differentFileName.fileName
                );
            }
        }

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/put/multipart/differentFileName"
        )();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartDifferentFileName",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPutMultipartDifferentFileNameRes>()
                .json(200, operations.RequestBodyPutMultipartDifferentFileNameRes$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPutMultipartFile(
        request: operations.RequestBodyPutMultipartFileRequestBody,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartFileRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutMultipartFileRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();

        if (payload$.file !== undefined) {
            if (isBlobLike(payload$.file)) {
                body$.append("file", payload$.file);
            } else {
                body$.append(
                    "file",
                    new Blob([payload$.file.content], { type: "application/octet-stream" }),
                    payload$.file.fileName
                );
            }
        }

        const path$ = this.templateURLComponent("/anything/requestBodies/put/multipart/file")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartFile",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPutMultipartFileRes>()
            .json(200, operations.RequestBodyPutMultipartFileRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPutMultipartOptionalRequestBody(
        request?: operations.RequestBodyPutMultipartOptionalRequestBodyRequestBody | undefined,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartOptionalRequestBodyRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutMultipartOptionalRequestBodyRequestBody$outboundSchema.optional().parse(
                    value$
                ),
            "Input validation failed"
        );
        const body$ = new FormData();
        if (payload$ != null) {
            if (payload$?.sampleField !== undefined) {
                body$.append("sampleField", payload$?.sampleField);
            }
            if (payload$?.sampleFile !== undefined) {
                if (isBlobLike(payload$?.sampleFile)) {
                    body$.append("sampleFile", payload$?.sampleFile);
                } else {
                    body$.append(
                        "sampleFile",
                        new Blob([payload$?.sampleFile.content], {
                            type: "application/octet-stream",
                        }),
                        payload$?.sampleFile.fileName
                    );
                }
            }
        }

        const path$ = this.templateURLComponent(
            "/anything/requestBodies/put/multipart/optionalRequestBody"
        )();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartOptionalRequestBody",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] =
            await this.matcher<operations.RequestBodyPutMultipartOptionalRequestBodyRes>()
                .json(200, operations.RequestBodyPutMultipartOptionalRequestBodyRes$inboundSchema)
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async requestBodyPutMultipartSimple(
        request: shared.SimpleObject,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutMultipartSimpleRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.SimpleObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = new FormData();

        body$.append("bool", String(payload$.bool));
        body$.append("date", payload$.date);
        body$.append("dateTime", payload$.dateTime);
        body$.append("enum", payload$.enum);
        body$.append("float32", String(payload$.float32));
        body$.append("int", String(payload$.int));
        body$.append("int32", String(payload$.int32));
        body$.append("int32Enum", String(payload$.int32Enum));
        body$.append("intEnum", String(payload$.intEnum));
        body$.append("num", String(payload$.num));
        body$.append("str", payload$.str);
        if (payload$.any !== undefined) {
            body$.append("any", String(payload$.any));
        }
        if (payload$.bigint !== undefined) {
            body$.append("bigint", String(payload$.bigint));
        }
        if (payload$.bigintStr !== undefined) {
            body$.append("bigintStr", payload$.bigintStr);
        }
        if (payload$.boolOpt !== undefined) {
            body$.append("boolOpt", String(payload$.boolOpt));
        }
        if (payload$.decimal !== undefined) {
            body$.append("decimal", String(payload$.decimal));
        }
        if (payload$.decimalStr !== undefined) {
            body$.append("decimalStr", payload$.decimalStr);
        }
        if (payload$.float64Str !== undefined) {
            body$.append("float64Str", payload$.float64Str);
        }
        if (payload$.int64Str !== undefined) {
            body$.append("int64Str", payload$.int64Str);
        }
        if (payload$.intOptNull !== undefined) {
            body$.append("intOptNull", String(payload$.intOptNull));
        }
        if (payload$.numOptNull !== undefined) {
            body$.append("numOptNull", String(payload$.numOptNull));
        }
        if (payload$.strOpt !== undefined) {
            body$.append("strOpt", payload$.strOpt);
        }

        const path$ = this.templateURLComponent("/anything/requestBodies/put/multipart/simple")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
            any: encodeSimple$("any", payload$.any, { explode: false, charEncoding: "none" }),
            bigint: encodeSimple$("bigint", payload$.bigint, {
                explode: false,
                charEncoding: "none",
            }),
            bigintStr: encodeSimple$("bigintStr", payload$.bigintStr, {
                explode: false,
                charEncoding: "none",
            }),
            bool: encodeSimple$("bool", payload$.bool, { explode: false, charEncoding: "none" }),
            boolOpt: encodeSimple$("boolOpt", payload$.boolOpt, {
                explode: false,
                charEncoding: "none",
            }),
            date: encodeSimple$("date", payload$.date, { explode: false, charEncoding: "none" }),
            dateTime: encodeSimple$("dateTime", payload$.dateTime, {
                explode: false,
                charEncoding: "none",
            }),
            decimal: encodeSimple$("decimal", payload$.decimal, {
                explode: false,
                charEncoding: "none",
            }),
            decimalStr: encodeSimple$("decimalStr", payload$.decimalStr, {
                explode: false,
                charEncoding: "none",
            }),
            enum: encodeSimple$("enum", payload$.enum, { explode: false, charEncoding: "none" }),
            float32: encodeSimple$("float32", payload$.float32, {
                explode: false,
                charEncoding: "none",
            }),
            float64Str: encodeSimple$("float64Str", payload$.float64Str, {
                explode: false,
                charEncoding: "none",
            }),
            int: encodeSimple$("int", payload$.int, { explode: false, charEncoding: "none" }),
            int32: encodeSimple$("int32", payload$.int32, { explode: false, charEncoding: "none" }),
            int32Enum: encodeSimple$("int32Enum", payload$.int32Enum, {
                explode: false,
                charEncoding: "none",
            }),
            int64Str: encodeSimple$("int64Str", payload$.int64Str, {
                explode: false,
                charEncoding: "none",
            }),
            intEnum: encodeSimple$("intEnum", payload$.intEnum, {
                explode: false,
                charEncoding: "none",
            }),
            intOptNull: encodeSimple$("intOptNull", payload$.intOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            num: encodeSimple$("num", payload$.num, { explode: false, charEncoding: "none" }),
            numOptNull: encodeSimple$("numOptNull", payload$.numOptNull, {
                explode: false,
                charEncoding: "none",
            }),
            str: encodeSimple$("str", payload$.str, { explode: false, charEncoding: "none" }),
            strOpt: encodeSimple$("strOpt", payload$.strOpt, {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutMultipartSimple",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPutMultipartSimpleRes>()
            .json(200, operations.RequestBodyPutMultipartSimpleRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPutString(
        request: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutStringRes> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => z.string().parse(value$),
            "Input validation failed"
        );
        const body$ = payload$;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/string")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "text/plain",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutString",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPutStringRes>()
            .json(200, operations.RequestBodyPutStringRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyPutStringWithParams(
        requestBody: string,
        queryStringParam: string,
        options?: RequestOptions
    ): Promise<operations.RequestBodyPutStringWithParamsRes> {
        const input$: operations.RequestBodyPutStringWithParamsRequest = {
            requestBody: requestBody,
            queryStringParam: queryStringParam,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.RequestBodyPutStringWithParamsRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = payload$.RequestBody;

        const path$ = this.templateURLComponent("/anything/requestBodies/put/stringWithParams")();

        const query$ = encodeFormQuery$({
            queryStringParam: payload$.queryStringParam,
        });

        const headers$ = new Headers({
            "Content-Type": "text/plain",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyPutStringWithParams",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PUT",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<operations.RequestBodyPutStringWithParamsRes>()
            .json(200, operations.RequestBodyPutStringWithParamsRes$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyReadAndWrite(
        request: shared.ReadWriteObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.ReadWriteObjectOutput> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ReadWriteObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyReadAndWriteServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyandwriteonly")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadAndWrite",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<shared.ReadWriteObjectOutput>()
            .json(200, shared.ReadWriteObjectOutput$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyReadOnlyInput(
        request: shared.ReadOnlyObjectInput,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.ReadOnlyObject> {
        const input$ = request;
        void input$; // request input is unused

        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyReadOnlyInputServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyorwriteonly#readOnlyInput")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadOnlyInput",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<shared.ReadOnlyObject>()
            .json(200, shared.ReadOnlyObject$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyReadOnlyUnion(
        request: shared.WeaklyTypedOneOfReadOnlyObjectInput,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.WeaklyTypedOneOfReadOnlyObject> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.WeaklyTypedOneOfReadOnlyObjectInput$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyReadOnlyUnionServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyorwriteonly#readOnlyUnion")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<shared.WeaklyTypedOneOfReadOnlyObject>()
            .json(200, shared.WeaklyTypedOneOfReadOnlyObject$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyReadWriteOnlyUnion(
        request: shared.WeaklyTypedOneOfReadWriteObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.WeaklyTypedOneOfReadWriteObjectOutput> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.WeaklyTypedOneOfReadWriteObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyReadWriteOnlyUnionServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyandwriteonly#readWriteOnlyUnion")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyReadWriteOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<shared.WeaklyTypedOneOfReadWriteObjectOutput>()
            .json(200, shared.WeaklyTypedOneOfReadWriteObjectOutput$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyWriteOnly(
        request: shared.WriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.ReadOnlyObject> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.WriteOnlyObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyWriteOnlyServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyorwriteonly#writeOnly")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyWriteOnly",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<shared.ReadOnlyObject>()
            .json(200, shared.ReadOnlyObject$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyWriteOnlyOutput(
        request: shared.WriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.WriteOnlyObjectOutput> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.WriteOnlyObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyWriteOnlyOutputServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/writeonlyoutput#writeOnlyOutput")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyWriteOnlyOutput",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<shared.WriteOnlyObjectOutput>()
            .json(200, shared.WriteOnlyObjectOutput$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async requestBodyWriteOnlyUnion(
        request: shared.WeaklyTypedOneOfWriteOnlyObject,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.WeaklyTypedOneOfWriteOnlyObjectOutput> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.WeaklyTypedOneOfWriteOnlyObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(RequestBodyWriteOnlyUnionServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/writeonlyoutput#writeOnlyUnion")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "requestBodyWriteOnlyUnion",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, { context, errorCodes: ["4XX", "5XX"] });

        const [result$] = await this.matcher<shared.WeaklyTypedOneOfWriteOnlyObjectOutput>()
            .json(200, shared.WeaklyTypedOneOfWriteOnlyObjectOutput$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }
}
