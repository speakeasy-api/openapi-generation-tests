/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import {
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
} from "../lib/encodings.js";
import * as m$ from "../lib/matchers.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { SDKError } from "./models/errors/sdkerror.js";
import { SDKValidationError } from "./models/errors/sdkvalidationerror.js";
import * as operations from "./models/operations/index.js";
import { ResponseBodyDecimalStrServerList } from "./models/operations/responsebodydecimalstr.js";
import { ResponseBodyOptionalGetServerList } from "./models/operations/responsebodyoptionalget.js";
import { ResponseBodyReadOnlyServerList } from "./models/operations/responsebodyreadonly.js";
import * as shared from "./models/shared/index.js";
import { Decimal as Decimal$ } from "./types/decimal.js";
import { unwrap as unwrap$ } from "./types/fp.js";
import { createPageIterator, PageIterator, Paginator } from "./types/operations.js";
import jp from "jsonpath";
import * as z from "zod";

export enum ResponseBodyOptionalGetAcceptEnum {
    applicationJson = "application/json",
    textPlain = "text/plain",
}

export class ResponseBodies extends ClientSDK {
    async flattenedEnvelopePaginationResponse(
        cursor?: string | undefined,
        options?: RequestOptions
    ): Promise<PageIterator<operations.FlattenedEnvelopePaginationResponseResponse>> {
        const input$: operations.FlattenedEnvelopePaginationResponseRequest = {
            cursor: cursor,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                operations.FlattenedEnvelopePaginationResponseRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/anything/flattenedEnvelopePaginationResponse")();

        const query$ = encodeFormQuery$({
            cursor: payload$.cursor,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "flattenedEnvelopePaginationResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$, raw$] = await m$.match<
            operations.FlattenedEnvelopePaginationResponseResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.FlattenedEnvelopePaginationResponseResponse$inboundSchema, {
                key: "Result",
            }),
            m$.fail(["4XX", "5XX"])
        )(response, { extraFields: responseFields$ });

        const nextFunc = (
            responseData: unknown
        ): Paginator<operations.FlattenedEnvelopePaginationResponseResponse> => {
            const nextCursor = jp.value(responseData, "$.resultArray[(@.length-1)]");

            if (nextCursor == null) {
                return () => null;
            }

            return () => this.flattenedEnvelopePaginationResponse(nextCursor, options);
        };

        const page$ = { ...unwrap$(result$), next: nextFunc(raw$) };
        return { ...page$, ...createPageIterator(page$, !result$.ok) };
    }

    async flattenedEnvelopeResponse(
        options?: RequestOptions
    ): Promise<operations.FlattenedEnvelopeResponseResponse> {
        const path$ = pathToFunc("/anything/flattenedEnvelopeResponse")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "flattenedEnvelopeResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await m$.match<
            operations.FlattenedEnvelopeResponseResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.FlattenedEnvelopeResponseResponse$inboundSchema, {
                hdrs: true,
                key: "Result",
            }),
            m$.fail(["4XX", "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    async flattenedEnvelopeUnionResponse(
        options?: RequestOptions
    ): Promise<operations.FlattenedEnvelopeUnionResponseResponse> {
        const path$ = pathToFunc("/anything/flattenedEnvelopeUnionResponse")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "flattenedEnvelopeUnionResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await m$.match<
            operations.FlattenedEnvelopeUnionResponseResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.FlattenedEnvelopeUnionResponseResponse$inboundSchema, {
                hdrs: true,
                key: "Result",
            }),
            m$.json(201, operations.FlattenedEnvelopeUnionResponseResponse$inboundSchema, {
                key: "Result",
            }),
            m$.fail(["4XX", "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    async flattenedUnionResponse(
        options?: RequestOptions
    ): Promise<operations.FlattenedUnionResponseResponse> {
        const path$ = pathToFunc("/anything/flattenedUnionResponse")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "flattenedUnionResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.FlattenedUnionResponseResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.FlattenedUnionResponseResponse$inboundSchema),
            m$.json(201, operations.FlattenedUnionResponseResponse$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async overriddenFieldNamesPost(
        request: operations.OverriddenFieldNamesPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.OverriddenFieldNamesPostResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.OverriddenFieldNamesPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/overriddenFieldNames")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "overriddenFieldNamesPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.OverriddenFieldNamesPostResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.OverriddenFieldNamesPostResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async responseBodyAdditionalPropertiesAnyPost(
        request: shared.ObjWithAnyAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesAnyPostResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.ObjWithAnyAdditionalProperties$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/responseBodies/additionalPropertiesAny")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyAdditionalPropertiesAnyPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.ResponseBodyAdditionalPropertiesAnyPostResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.ResponseBodyAdditionalPropertiesAnyPostResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async responseBodyAdditionalPropertiesComplexNumbersPost(
        request: shared.ObjWithComplexNumbersAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesComplexNumbersPostResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                shared.ObjWithComplexNumbersAdditionalProperties$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/responseBodies/additionalPropertiesComplexNumbers")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyAdditionalPropertiesComplexNumbersPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.ResponseBodyAdditionalPropertiesComplexNumbersPostResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.ResponseBodyAdditionalPropertiesComplexNumbersPostResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async responseBodyAdditionalPropertiesDatePost(
        request: shared.ObjWithDateAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesDatePostResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.ObjWithDateAdditionalProperties$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/responseBodies/additionalPropertiesDate")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyAdditionalPropertiesDatePost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.ResponseBodyAdditionalPropertiesDatePostResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.ResponseBodyAdditionalPropertiesDatePostResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async responseBodyAdditionalPropertiesObjectPost(
        request: shared.ObjWithObjAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesObjectPostResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.ObjWithObjAdditionalProperties$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/responseBodies/additionalPropertiesObject")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyAdditionalPropertiesObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.ResponseBodyAdditionalPropertiesObjectPostResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.ResponseBodyAdditionalPropertiesObjectPostResponseBody$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async responseBodyAdditionalPropertiesPost(
        request: shared.ObjWithStringAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesPostResponseBody> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.ObjWithStringAdditionalProperties$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/responseBodies/additionalProperties")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyAdditionalPropertiesPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.ResponseBodyAdditionalPropertiesPostResponseBody,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.ResponseBodyAdditionalPropertiesPostResponseBody$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async responseBodyBytesGet(options?: RequestOptions): Promise<ReadableStream<Uint8Array>> {
        const path$ = pathToFunc("/bytes/100")();

        const headers$ = new Headers({
            Accept: "application/octet-stream",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyBytesGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<ReadableStream<Uint8Array>, SDKError | SDKValidationError>(
            m$.stream(200, z.instanceof(ReadableStream<Uint8Array>)),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async responseBodyDecimalStr(
        request: Decimal$ | number,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Decimal$> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z
                    .union([z.instanceof(Decimal$), z.number()])
                    .transform((v) => `${v}`)
                    .parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const baseURL$ =
            options?.serverURL ||
            pathToFunc(ResponseBodyDecimalStrServerList[0], { charEncoding: "percent" })();

        const path$ = pathToFunc("/reflect#decimalStr")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyDecimalStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<Decimal$, SDKError | SDKValidationError>(
            m$.json(
                200,
                z.string().transform((v) => new Decimal$(v))
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async responseBodyEmptyWithHeaders(
        xNumberHeader: number,
        xStringHeader: string,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyEmptyWithHeadersResponse | undefined> {
        const input$: operations.ResponseBodyEmptyWithHeadersRequest = {
            xNumberHeader: xNumberHeader,
            xStringHeader: xStringHeader,
        };

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.ResponseBodyEmptyWithHeadersRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = null;

        const path$ = pathToFunc("/response-headers")();

        const query$ = encodeFormQuery$({
            "X-Number-Header": payload$["X-Number-Header"],
            "X-String-Header": payload$["X-String-Header"],
        });

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyEmptyWithHeaders",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await m$.match<
            operations.ResponseBodyEmptyWithHeadersResponse | undefined,
            SDKError | SDKValidationError
        >(
            m$.nil(200, operations.ResponseBodyEmptyWithHeadersResponse$inboundSchema.optional(), {
                hdrs: true,
            }),
            m$.fail(["4XX", "5XX"])
        )(response, { extraFields: responseFields$ });

        return unwrap$(result$);
    }

    async responseBodyMissing2xxOr3xxGet(options?: RequestOptions): Promise<void> {
        const path$ = pathToFunc("/anything/responseBodies/missing2xxOr3xx")();

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyMissing2xxOr3xxGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "500", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<void, SDKError | SDKValidationError>(
            m$.fail(["4XX", 500, "5XX"]),
            m$.nil("2XX", z.void())
        )(response);

        return unwrap$(result$);
    }

    async responseBodyOptionalGet(
        options?: RequestOptions & {
            acceptHeaderOverride?: ResponseBodyOptionalGetAcceptEnum;
            serverURL?: string;
        }
    ): Promise<operations.ResponseBodyOptionalGetResponse> {
        const baseURL$ =
            options?.serverURL ||
            pathToFunc(ResponseBodyOptionalGetServerList[0], { charEncoding: "percent" })();

        const path$ = pathToFunc("/optional")();

        const headers$ = new Headers({
            Accept: options?.acceptHeaderOverride || "application/json;q=1, text/plain;q=0",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyOptionalGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.ResponseBodyOptionalGetResponse,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.ResponseBodyOptionalGetResponse$inboundSchema),
            m$.text(200, operations.ResponseBodyOptionalGetResponse$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async responseBodyReadOnly(
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.ReadOnlyObject> {
        const baseURL$ =
            options?.serverURL ||
            pathToFunc(ResponseBodyReadOnlyServerList[0], { charEncoding: "percent" })();

        const path$ = pathToFunc("/readonlyorwriteonly#readOnly")();

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyReadOnly",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<shared.ReadOnlyObject, SDKError | SDKValidationError>(
            m$.json(200, shared.ReadOnlyObject$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async responseBodyStringGet(options?: RequestOptions): Promise<string> {
        const path$ = pathToFunc("/html")();

        const headers$ = new Headers({
            Accept: "text/html",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyStringGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<string, SDKError | SDKValidationError>(
            m$.text(200, z.string(), { ctype: "text/html" }),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async responseBodyXmlGet(options?: RequestOptions): Promise<string> {
        const path$ = pathToFunc("/xml")();

        const headers$ = new Headers({
            Accept: "application/xml",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "responseBodyXmlGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<string, SDKError | SDKValidationError>(
            m$.text(200, z.string(), { ctype: "application/xml" }),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }
}
