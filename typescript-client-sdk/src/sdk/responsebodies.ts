/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks";
import { SDK_METADATA, SDKOptions, serverURLFromOptions } from "../lib/config";
import * as enc$ from "../lib/encodings";
import { HTTPClient } from "../lib/http";
import * as schemas$ from "../lib/schemas";
import { ClientSDK, RequestOptions } from "../lib/sdks";
import * as operations from "./models/operations";
import * as shared from "./models/shared";
import { createPageIterator, PageIterator, Paginator } from "./types";
import jp from "jsonpath";

export enum ResponseBodyOptionalGetAcceptEnum {
    applicationJson = "application/json",
    textPlain = "text/plain",
}

export class ResponseBodies extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    async flattenedEnvelopePaginationResponse(
        cursor?: string | undefined,
        options?: RequestOptions
    ): Promise<PageIterator<operations.FlattenedEnvelopePaginationResponseResponse>> {
        const input$: operations.FlattenedEnvelopePaginationResponseRequest = {
            cursor: cursor,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.FlattenedEnvelopePaginationResponseRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/flattenedEnvelopePaginationResponse")();

        const query$ = [
            enc$.encodeForm("cursor", payload$.cursor, { explode: true, charEncoding: "percent" }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "flattenedEnvelopePaginationResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$, raw$] =
            await this.matcher<operations.FlattenedEnvelopePaginationResponseResponse>()
                .json(200, operations.FlattenedEnvelopePaginationResponseResponse$, { key: "res" })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        const nextFunc = (
            responseData: unknown
        ): Paginator<operations.FlattenedEnvelopePaginationResponseResponse> => {
            const nextCursor = jp.value(responseData, "$.resultArray[(@.length-1)]");
            if (nextCursor == null) {
                return () => null;
            }

            return () => this.flattenedEnvelopePaginationResponse(nextCursor, options);
        };

        const page$ = { ...result$, next: nextFunc(raw$) };
        return { ...page$, ...createPageIterator(page$) };
    }

    async flattenedEnvelopeResponse(
        options?: RequestOptions
    ): Promise<operations.FlattenedEnvelopeResponseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/flattenedEnvelopeResponse")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "flattenedEnvelopeResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.FlattenedEnvelopeResponseResponse>()
            .json(200, operations.FlattenedEnvelopeResponseResponse$, { hdrs: true, key: "object" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async flattenedEnvelopeUnionResponse(
        options?: RequestOptions
    ): Promise<operations.FlattenedEnvelopeUnionResponseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/flattenedEnvelopeUnionResponse")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "flattenedEnvelopeUnionResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.FlattenedEnvelopeUnionResponseResponse>()
            .json(200, operations.FlattenedEnvelopeUnionResponseResponse$, {
                hdrs: true,
                key: "200_application/json_object",
            })
            .json(201, operations.FlattenedEnvelopeUnionResponseResponse$, {
                key: "201_application/json_object",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async flattenedUnionResponse(
        options?: RequestOptions
    ): Promise<operations.FlattenedUnionResponseResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const path$ = this.templateURLComponent("/anything/flattenedUnionResponse")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "flattenedUnionResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.FlattenedUnionResponseResponse>()
            .json(200, operations.FlattenedUnionResponseResponse$, {
                key: "200_application/json_object",
            })
            .json(201, operations.FlattenedUnionResponseResponse$, {
                key: "201_application/json_object",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyAdditionalPropertiesAnyPost(
        request: shared.ObjWithAnyAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesAnyPostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ObjWithAnyAdditionalProperties$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/responseBodies/additionalPropertiesAny"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyAdditionalPropertiesAnyPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.ResponseBodyAdditionalPropertiesAnyPostResponse>()
                .json(200, operations.ResponseBodyAdditionalPropertiesAnyPostResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyAdditionalPropertiesComplexNumbersPost(
        request: shared.ObjWithComplexNumbersAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesComplexNumbersPostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                shared.ObjWithComplexNumbersAdditionalProperties$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/responseBodies/additionalPropertiesComplexNumbers"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyAdditionalPropertiesComplexNumbersPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.ResponseBodyAdditionalPropertiesComplexNumbersPostResponse>()
                .json(200, operations.ResponseBodyAdditionalPropertiesComplexNumbersPostResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyAdditionalPropertiesDatePost(
        request: shared.ObjWithDateAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesDatePostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ObjWithDateAdditionalProperties$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/responseBodies/additionalPropertiesDate"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyAdditionalPropertiesDatePost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.ResponseBodyAdditionalPropertiesDatePostResponse>()
                .json(200, operations.ResponseBodyAdditionalPropertiesDatePostResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyAdditionalPropertiesObjectPost(
        request: shared.ObjWithObjAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesObjectPostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ObjWithObjAdditionalProperties$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/responseBodies/additionalPropertiesObject"
        )();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyAdditionalPropertiesObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.ResponseBodyAdditionalPropertiesObjectPostResponse>()
                .json(200, operations.ResponseBodyAdditionalPropertiesObjectPostResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyAdditionalPropertiesPost(
        request: shared.ObjWithStringAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesPostResponse> {
        const input$ = request;
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Content-Type", "application/json");
        headers$.set("Accept", "application/json");

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ObjWithStringAdditionalProperties$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = enc$.encodeJSON("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/responseBodies/additionalProperties")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyAdditionalPropertiesPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] =
            await this.matcher<operations.ResponseBodyAdditionalPropertiesPostResponse>()
                .json(200, operations.ResponseBodyAdditionalPropertiesPostResponse$, {
                    key: "object",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyBytesGet(
        options?: RequestOptions
    ): Promise<operations.ResponseBodyBytesGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/octet-stream");

        const path$ = this.templateURLComponent("/bytes/100")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyBytesGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.ResponseBodyBytesGetResponse>()
            .stream(200, operations.ResponseBodyBytesGetResponse$, { key: "bytes" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyEmptyWithHeaders(
        xNumberHeader: number,
        xStringHeader: string,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyEmptyWithHeadersResponse> {
        const input$: operations.ResponseBodyEmptyWithHeadersRequest = {
            xNumberHeader: xNumberHeader,
            xStringHeader: xStringHeader,
        };
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.ResponseBodyEmptyWithHeadersRequest$.outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/response-headers")();

        const query$ = [
            enc$.encodeForm("X-Number-Header", payload$["X-Number-Header"], {
                explode: true,
                charEncoding: "percent",
            }),
            enc$.encodeForm("X-String-Header", payload$["X-String-Header"], {
                explode: true,
                charEncoding: "percent",
            }),
        ]
            .filter(Boolean)
            .join("&");

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyEmptyWithHeaders",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.ResponseBodyEmptyWithHeadersResponse>()
            .void(200, operations.ResponseBodyEmptyWithHeadersResponse$, { hdrs: true })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyMissing2xxOr3xxGet(
        options?: RequestOptions
    ): Promise<operations.ResponseBodyMissing2xxOr3xxGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "*/*");

        const path$ = this.templateURLComponent("/anything/responseBodies/missing2xxOr3xx")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyMissing2xxOr3xxGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "500", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.ResponseBodyMissing2xxOr3xxGetResponse>()
            .void("2XX", operations.ResponseBodyMissing2xxOr3xxGetResponse$)
            .fail(["4XX", 500, "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyOptionalGet(
        options?: RequestOptions & {
            acceptHeaderOverride?: ResponseBodyOptionalGetAcceptEnum;
            serverURL?: string;
        }
    ): Promise<operations.ResponseBodyOptionalGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);

        const accept = options?.acceptHeaderOverride || "application/json;q=1, text/plain;q=0";
        headers$.set("Accept", accept);

        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(operations.ResponseBodyOptionalGetServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/optional")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyOptionalGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.ResponseBodyOptionalGetResponse>()
            .json(200, operations.ResponseBodyOptionalGetResponse$, { key: "typedObject1" })
            .text(200, operations.ResponseBodyOptionalGetResponse$, { key: "res" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyReadOnly(
        options?: RequestOptions & { serverURL?: string }
    ): Promise<operations.ResponseBodyReadOnlyResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/json");

        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(operations.ResponseBodyReadOnlyServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyorwriteonly#readOnly")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyReadOnly",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.ResponseBodyReadOnlyResponse>()
            .json(200, operations.ResponseBodyReadOnlyResponse$, { key: "readOnlyObject" })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyStringGet(
        options?: RequestOptions
    ): Promise<operations.ResponseBodyStringGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "text/html");

        const path$ = this.templateURLComponent("/html")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyStringGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.ResponseBodyStringGetResponse>()
            .text(200, operations.ResponseBodyStringGetResponse$, {
                ctype: "text/html",
                key: "html",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyXmlGet(
        options?: RequestOptions
    ): Promise<operations.ResponseBodyXmlGetResponse> {
        const headers$ = new Headers();
        headers$.set("x-speakeasy-user-agent", SDK_METADATA.userAgent);
        headers$.set("Accept", "application/xml");

        const path$ = this.templateURLComponent("/xml")();

        const query$ = "";

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyXmlGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const doOptions = { context, errorCodes: ["4XX", "5XX"] };
        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
            },
            options
        );

        const response = await this.do$(request$, doOptions);

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.ResponseBodyXmlGetResponse>()
            .text(200, operations.ResponseBodyXmlGetResponse$, {
                ctype: "application/xml",
                key: "xml",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }
}
