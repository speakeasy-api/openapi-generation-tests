/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDKOptions, serverURLFromOptions } from "../lib/config.js";
import {
    encodeFormQuery as encodeFormQuery$,
    encodeJSON as encodeJSON$,
} from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as operations from "./models/operations/index.js";
import { ResponseBodyDecimalStrServerList } from "./models/operations/responsebodydecimalstr.js";
import { ResponseBodyOptionalGetServerList } from "./models/operations/responsebodyoptionalget.js";
import { ResponseBodyReadOnlyServerList } from "./models/operations/responsebodyreadonly.js";
import * as shared from "./models/shared/index.js";
import { Decimal as Decimal$ } from "./types/decimal.js";
import { createPageIterator, PageIterator, Paginator } from "./types/operations.js";
import jp from "jsonpath";
import * as z from "zod";

export enum ResponseBodyOptionalGetAcceptEnum {
    applicationJson = "application/json",
    textPlain = "text/plain",
}

export class ResponseBodies extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    async flattenedEnvelopePaginationResponse(
        cursor?: string | undefined,
        options?: RequestOptions
    ): Promise<PageIterator<operations.FlattenedEnvelopePaginationResponseResponse>> {
        const input$: operations.FlattenedEnvelopePaginationResponseRequest = {
            cursor: cursor,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                operations.FlattenedEnvelopePaginationResponseRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/anything/flattenedEnvelopePaginationResponse")();

        const query$ = encodeFormQuery$({
            cursor: payload$.cursor,
        });

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "flattenedEnvelopePaginationResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$, raw$] =
            await this.matcher<operations.FlattenedEnvelopePaginationResponseResponse>()
                .json(200, operations.FlattenedEnvelopePaginationResponseResponse$inboundSchema, {
                    key: "Result",
                })
                .fail(["4XX", "5XX"])
                .match(response, { extraFields: responseFields$ });

        const nextFunc = (
            responseData: unknown
        ): Paginator<operations.FlattenedEnvelopePaginationResponseResponse> => {
            const nextCursor = jp.value(responseData, "$.resultArray[(@.length-1)]");

            if (nextCursor == null) {
                return () => null;
            }

            return () => this.flattenedEnvelopePaginationResponse(nextCursor, options);
        };

        const page$ = { ...result$, next: nextFunc(raw$) };
        return { ...page$, ...createPageIterator(page$) };
    }

    async flattenedEnvelopeResponse(
        options?: RequestOptions
    ): Promise<operations.FlattenedEnvelopeResponseResponse> {
        const path$ = this.templateURLComponent("/anything/flattenedEnvelopeResponse")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "flattenedEnvelopeResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.FlattenedEnvelopeResponseResponse>()
            .json(200, operations.FlattenedEnvelopeResponseResponse$inboundSchema, {
                hdrs: true,
                key: "Result",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async flattenedEnvelopeUnionResponse(
        options?: RequestOptions
    ): Promise<operations.FlattenedEnvelopeUnionResponseResponse> {
        const path$ = this.templateURLComponent("/anything/flattenedEnvelopeUnionResponse")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "flattenedEnvelopeUnionResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<operations.FlattenedEnvelopeUnionResponseResponse>()
            .json(200, operations.FlattenedEnvelopeUnionResponseResponse$inboundSchema, {
                hdrs: true,
                key: "Result",
            })
            .json(201, operations.FlattenedEnvelopeUnionResponseResponse$inboundSchema, {
                key: "Result",
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async flattenedUnionResponse(
        options?: RequestOptions
    ): Promise<operations.FlattenedUnionResponseResponse> {
        const path$ = this.templateURLComponent("/anything/flattenedUnionResponse")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "flattenedUnionResponse",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.FlattenedUnionResponseResponse>()
            .json(200, operations.FlattenedUnionResponseResponse$inboundSchema)
            .json(201, operations.FlattenedUnionResponseResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async overriddenFieldNamesPost(
        request: operations.OverriddenFieldNamesPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.OverriddenFieldNamesPostResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.OverriddenFieldNamesPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/overriddenFieldNames")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "overriddenFieldNamesPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.OverriddenFieldNamesPostResponseBody>()
            .json(200, operations.OverriddenFieldNamesPostResponseBody$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async responseBodyAdditionalPropertiesAnyPost(
        request: shared.ObjWithAnyAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesAnyPostResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ObjWithAnyAdditionalProperties$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/responseBodies/additionalPropertiesAny"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyAdditionalPropertiesAnyPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.ResponseBodyAdditionalPropertiesAnyPostResponseBody>()
                .json(
                    200,
                    operations.ResponseBodyAdditionalPropertiesAnyPostResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async responseBodyAdditionalPropertiesComplexNumbersPost(
        request: shared.ObjWithComplexNumbersAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesComplexNumbersPostResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                shared.ObjWithComplexNumbersAdditionalProperties$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/responseBodies/additionalPropertiesComplexNumbers"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyAdditionalPropertiesComplexNumbersPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.ResponseBodyAdditionalPropertiesComplexNumbersPostResponseBody>()
                .json(
                    200,
                    operations.ResponseBodyAdditionalPropertiesComplexNumbersPostResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async responseBodyAdditionalPropertiesDatePost(
        request: shared.ObjWithDateAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesDatePostResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ObjWithDateAdditionalProperties$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/responseBodies/additionalPropertiesDate"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyAdditionalPropertiesDatePost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.ResponseBodyAdditionalPropertiesDatePostResponseBody>()
                .json(
                    200,
                    operations.ResponseBodyAdditionalPropertiesDatePostResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async responseBodyAdditionalPropertiesObjectPost(
        request: shared.ObjWithObjAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesObjectPostResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ObjWithObjAdditionalProperties$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent(
            "/anything/responseBodies/additionalPropertiesObject"
        )();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyAdditionalPropertiesObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.ResponseBodyAdditionalPropertiesObjectPostResponseBody>()
                .json(
                    200,
                    operations.ResponseBodyAdditionalPropertiesObjectPostResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async responseBodyAdditionalPropertiesPost(
        request: shared.ObjWithStringAdditionalProperties,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyAdditionalPropertiesPostResponseBody> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) => shared.ObjWithStringAdditionalProperties$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = this.templateURLComponent("/anything/responseBodies/additionalProperties")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyAdditionalPropertiesPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] =
            await this.matcher<operations.ResponseBodyAdditionalPropertiesPostResponseBody>()
                .json(
                    200,
                    operations.ResponseBodyAdditionalPropertiesPostResponseBody$inboundSchema
                )
                .fail(["4XX", "5XX"])
                .match(response);

        return result$;
    }

    async responseBodyBytesGet(options?: RequestOptions): Promise<ReadableStream<Uint8Array>> {
        const path$ = this.templateURLComponent("/bytes/100")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/octet-stream",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyBytesGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<ReadableStream<Uint8Array>>()
            .stream(200, z.instanceof(ReadableStream<Uint8Array>))
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async responseBodyDecimalStr(
        request: Decimal$ | number,
        options?: RequestOptions & { serverURL?: string }
    ): Promise<Decimal$> {
        const input$ = request;

        const payload$ = schemas$.parse(
            input$,
            (value$) =>
                z
                    .union([z.instanceof(Decimal$), z.number()])
                    .transform((v) => `${v}`)
                    .parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$, { explode: true });
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(ResponseBodyDecimalStrServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/reflect#decimalStr")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyDecimalStr",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<Decimal$>()
            .json(
                200,
                z.string().transform((v) => new Decimal$(v))
            )
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async responseBodyEmptyWithHeaders(
        xNumberHeader: number,
        xStringHeader: string,
        options?: RequestOptions
    ): Promise<operations.ResponseBodyEmptyWithHeadersResponse | undefined> {
        const input$: operations.ResponseBodyEmptyWithHeadersRequest = {
            xNumberHeader: xNumberHeader,
            xStringHeader: xStringHeader,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.ResponseBodyEmptyWithHeadersRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = null;

        const path$ = this.templateURLComponent("/response-headers")();

        const query$ = encodeFormQuery$({
            "X-Number-Header": payload$["X-Number-Header"],
            "X-String-Header": payload$["X-String-Header"],
        });

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyEmptyWithHeaders",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            HttpMeta: { Response: response, Request: request$ },
        };

        const [result$] = await this.matcher<
            operations.ResponseBodyEmptyWithHeadersResponse | undefined
        >()
            .void(200, operations.ResponseBodyEmptyWithHeadersResponse$inboundSchema.optional(), {
                hdrs: true,
            })
            .fail(["4XX", "5XX"])
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    async responseBodyMissing2xxOr3xxGet(options?: RequestOptions): Promise<void> {
        const path$ = this.templateURLComponent("/anything/responseBodies/missing2xxOr3xx")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "*/*",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyMissing2xxOr3xxGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "500", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<void>()
            .fail(["4XX", 500, "5XX"])
            .void("2XX", z.void())
            .match(response);

        return result$;
    }

    async responseBodyOptionalGet(
        options?: RequestOptions & {
            acceptHeaderOverride?: ResponseBodyOptionalGetAcceptEnum;
            serverURL?: string;
        }
    ): Promise<operations.ResponseBodyOptionalGetResponse> {
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(ResponseBodyOptionalGetServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/optional")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: options?.acceptHeaderOverride || "application/json;q=1, text/plain;q=0",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyOptionalGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<operations.ResponseBodyOptionalGetResponse>()
            .json(200, operations.ResponseBodyOptionalGetResponse$inboundSchema)
            .text(200, operations.ResponseBodyOptionalGetResponse$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async responseBodyReadOnly(
        options?: RequestOptions & { serverURL?: string }
    ): Promise<shared.ReadOnlyObject> {
        const baseURL$ =
            options?.serverURL ||
            this.templateURLComponent(ResponseBodyReadOnlyServerList[0], {
                charEncoding: "percent",
            })();

        const path$ = this.templateURLComponent("/readonlyorwriteonly#readOnly")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/json",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyReadOnly",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                baseURL: baseURL$,
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<shared.ReadOnlyObject>()
            .json(200, shared.ReadOnlyObject$inboundSchema)
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async responseBodyStringGet(options?: RequestOptions): Promise<string> {
        const path$ = this.templateURLComponent("/html")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "text/html",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyStringGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<string>()
            .text(200, z.string(), { ctype: "text/html" })
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }

    async responseBodyXmlGet(options?: RequestOptions): Promise<string> {
        const path$ = this.templateURLComponent("/xml")();

        const query$ = "";

        const headers$ = new Headers({
            Accept: "application/xml",
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "responseBodyXmlGet",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "GET",
                path: path$,
                headers: headers$,
                query: query$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const [result$] = await this.matcher<string>()
            .text(200, z.string(), { ctype: "application/xml" })
            .fail(["4XX", "5XX"])
            .match(response);

        return result$;
    }
}
