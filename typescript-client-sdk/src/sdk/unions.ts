/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import { encodeJSON as encodeJSON$ } from "../lib/encodings.js";
import * as m$ from "../lib/matchers.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { extractSecurity, resolveGlobalSecurity } from "../lib/security.js";
import { pathToFunc } from "../lib/url.js";
import { SDKError } from "./models/errors/sdkerror.js";
import { SDKValidationError } from "./models/errors/sdkvalidationerror.js";
import * as operations from "./models/operations/index.js";
import * as shared from "./models/shared/index.js";
import { unwrap as unwrap$ } from "./types/fp.js";
import { RFCDate } from "./types/rfcdate.js";
import * as z from "zod";

export class Unions extends ClientSDK {
    async collectionOneOfPost(
        request: shared.CollectionOneOfObject,
        options?: RequestOptions
    ): Promise<operations.CollectionOneOfPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.CollectionOneOfObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/collectionOneOf")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "collectionOneOfPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.CollectionOneOfPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.CollectionOneOfPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async constDiscriminatedOneOf(
        request: shared.ConstDiscriminatedOneOf,
        options?: RequestOptions
    ): Promise<operations.ConstDiscriminatedOneOfRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.ConstDiscriminatedOneOf$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/constDiscriminatedOneOf")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "constDiscriminatedOneOf",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.ConstDiscriminatedOneOfRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.ConstDiscriminatedOneOfRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async discriminatedOneMultipleMemberships(
        request: shared.Vehicle,
        options?: RequestOptions
    ): Promise<operations.DiscriminatedOneMultipleMembershipsRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.Vehicle$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/discriminatedOneMultipleMemberships")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "discriminatedOneMultipleMemberships",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.DiscriminatedOneMultipleMembershipsRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.DiscriminatedOneMultipleMembershipsRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async discriminatedOneMultipleMembershipsHasWheels(
        request: shared.HasWheels,
        options?: RequestOptions
    ): Promise<operations.DiscriminatedOneMultipleMembershipsHasWheelsRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.HasWheels$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/discriminatedOneMultipleMembershipsHasWheels")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "discriminatedOneMultipleMembershipsHasWheels",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.DiscriminatedOneMultipleMembershipsHasWheelsRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.DiscriminatedOneMultipleMembershipsHasWheelsRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async flattenedTypedObjectPost(
        request: shared.FlattenedTypedObject1,
        options?: RequestOptions
    ): Promise<operations.FlattenedTypedObjectPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.FlattenedTypedObject1$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/flattenedTypedObject")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "flattenedTypedObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.FlattenedTypedObjectPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.FlattenedTypedObjectPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async infectedWithAny(
        request: shared.InfectedWithAny,
        options?: RequestOptions
    ): Promise<operations.InfectedWithAnyRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.InfectedWithAny$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/infectedWithAny")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "infectedWithAny",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.InfectedWithAnyRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.InfectedWithAnyRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async mixedTypeOneOfPost(
        request: operations.MixedTypeOneOfPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.MixedTypeOneOfPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.MixedTypeOneOfPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/mixedTypeOneOf")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "mixedTypeOneOfPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.MixedTypeOneOfPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.MixedTypeOneOfPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async nullableOneOfRefInObjectPost(
        request: shared.NullableOneOfRefInObject,
        options?: RequestOptions
    ): Promise<operations.NullableOneOfRefInObjectPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.NullableOneOfRefInObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/nullableOneOfRefInObject")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "nullableOneOfRefInObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.NullableOneOfRefInObjectPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.NullableOneOfRefInObjectPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async nullableOneOfSchemaPost(
        request: operations.NullableOneOfSchemaPostRequestBody | null,
        options?: RequestOptions
    ): Promise<operations.NullableOneOfSchemaPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z
                    .nullable(operations.NullableOneOfSchemaPostRequestBody$outboundSchema)
                    .parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/nullableOneOfSchema")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "nullableOneOfSchemaPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.NullableOneOfSchemaPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.NullableOneOfSchemaPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async nullableOneOfTypeInObjectPost(
        request: shared.NullableOneOfTypeInObject,
        options?: RequestOptions
    ): Promise<operations.NullableOneOfTypeInObjectPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.NullableOneOfTypeInObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/nullableOneOfInObject")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "nullableOneOfTypeInObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.NullableOneOfTypeInObjectPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.NullableOneOfTypeInObjectPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async nullableTypedObjectPost(
        request: shared.TypedObject1 | null,
        options?: RequestOptions
    ): Promise<operations.NullableTypedObjectPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.nullable(shared.TypedObject1$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/nullableTypedObject")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "nullableTypedObjectPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.NullableTypedObjectPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.NullableTypedObjectPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async oneOfOverlappingObjects(
        request: operations.OneOfOverlappingObjectsRequestBody,
        options?: RequestOptions
    ): Promise<operations.OneOfOverlappingObjectsRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.OneOfOverlappingObjectsRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/oneOfOverlappingObjects")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "oneOfOverlappingObjects",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.OneOfOverlappingObjectsRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.OneOfOverlappingObjectsRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async primitiveTypeOneOfPost(
        request: operations.PrimitiveTypeOneOfPostRequestBody,
        options?: RequestOptions
    ): Promise<operations.PrimitiveTypeOneOfPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.PrimitiveTypeOneOfPostRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/primitiveTypeOneOf")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "primitiveTypeOneOfPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.PrimitiveTypeOneOfPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.PrimitiveTypeOneOfPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async stronglyTypedOneOfDiscriminatedPost(
        request: shared.StronglyTypedOneOfDiscriminatedObject,
        options?: RequestOptions
    ): Promise<operations.StronglyTypedOneOfDiscriminatedPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.StronglyTypedOneOfDiscriminatedObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/stronglyTypedOneOfDiscriminated")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "stronglyTypedOneOfDiscriminatedPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.StronglyTypedOneOfDiscriminatedPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.StronglyTypedOneOfDiscriminatedPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async stronglyTypedOneOfPost(
        request: shared.StronglyTypedOneOfObject,
        options?: RequestOptions
    ): Promise<operations.StronglyTypedOneOfPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.StronglyTypedOneOfObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/stronglyTypedOneOf")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "stronglyTypedOneOfPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.StronglyTypedOneOfPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.StronglyTypedOneOfPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async stronglyTypedOneOfPostWithNonStandardDiscriminatorName(
        request: shared.StronglyTypedOneOfObjectWithNonStandardDiscriminatorName,
        options?: RequestOptions
    ): Promise<operations.StronglyTypedOneOfPostWithNonStandardDiscriminatorNameRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                shared.StronglyTypedOneOfObjectWithNonStandardDiscriminatorName$outboundSchema.parse(
                    value$
                ),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/stronglyTypedOneOfWithNonStandardDiscriminatorName")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "stronglyTypedOneOfPostWithNonStandardDiscriminatorName",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.StronglyTypedOneOfPostWithNonStandardDiscriminatorNameRes,
            SDKError | SDKValidationError
        >(
            m$.json(
                200,
                operations.StronglyTypedOneOfPostWithNonStandardDiscriminatorNameRes$inboundSchema
            ),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async typedObjectNullableOneOfPost(
        request: shared.TypedObjectNullableOneOf | null,
        options?: RequestOptions
    ): Promise<operations.TypedObjectNullableOneOfPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.nullable(shared.TypedObjectNullableOneOf$outboundSchema).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/typedObjectNullableOneOf")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "typedObjectNullableOneOfPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.TypedObjectNullableOneOfPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.TypedObjectNullableOneOfPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async typedObjectOneOfPost(
        request: shared.TypedObjectOneOf,
        options?: RequestOptions
    ): Promise<operations.TypedObjectOneOfPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.TypedObjectOneOf$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/typedObjectOneOf")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "typedObjectOneOfPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.TypedObjectOneOfPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.TypedObjectOneOfPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async unionBigIntStrDecimal(
        request: operations.UnionBigIntStrDecimalRequestBody,
        options?: RequestOptions
    ): Promise<operations.UnionBigIntStrDecimalRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UnionBigIntStrDecimalRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/unionBigIntStrDecimal")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "unionBigIntStrDecimal",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.UnionBigIntStrDecimalRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UnionBigIntStrDecimalRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async unionDateNull(
        request: RFCDate | null,
        options?: RequestOptions
    ): Promise<operations.UnionDateNullRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) =>
                z.nullable(z.instanceof(RFCDate).transform((v) => v.toString())).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/unionDateNull")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "unionDateNull",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.UnionDateNullRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UnionDateNullRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async unionDateTimeBigInt(
        request: operations.UnionDateTimeBigIntRequestBody,
        options?: RequestOptions
    ): Promise<operations.UnionDateTimeBigIntRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UnionDateTimeBigIntRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/unionDateTimeBigInt")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "unionDateTimeBigInt",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.UnionDateTimeBigIntRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UnionDateTimeBigIntRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async unionDateTimeNull(
        request: Date | null,
        options?: RequestOptions
    ): Promise<operations.UnionDateTimeNullRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => z.nullable(z.date().transform((v) => v.toISOString())).parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ =
            payload$ === undefined ? null : encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/unionDateTimeNull")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "unionDateTimeNull",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.UnionDateTimeNullRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.UnionDateTimeNullRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async unionMap(
        request: operations.UnionMapRequestBody,
        options?: RequestOptions
    ): Promise<operations.UnionMapRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => operations.UnionMapRequestBody$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/unionMap")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "unionMap",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<operations.UnionMapRes, SDKError | SDKValidationError>(
            m$.json(200, operations.UnionMapRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async weaklyTypedOneOfNullEnumPost(
        request: shared.WeaklyTypedOneOfNullEnumObject,
        options?: RequestOptions
    ): Promise<operations.WeaklyTypedOneOfNullEnumPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.WeaklyTypedOneOfNullEnumObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/weaklyTypedOneOfNullEnum")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "weaklyTypedOneOfNullEnumPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.WeaklyTypedOneOfNullEnumPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.WeaklyTypedOneOfNullEnumPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }

    async weaklyTypedOneOfPost(
        request: shared.WeaklyTypedOneOfObject,
        options?: RequestOptions
    ): Promise<operations.WeaklyTypedOneOfPostRes> {
        const input$ = request;

        const parsed$ = schemas$.safeParse(
            input$,
            (value$) => shared.WeaklyTypedOneOfObject$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const payload$ = unwrap$(parsed$);
        const body$ = encodeJSON$("body", payload$, { explode: true });

        const path$ = pathToFunc("/anything/weaklyTypedOneOf")();

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
        });

        const security$ = await extractSecurity(this.options$.security);
        const context = {
            operationID: "weaklyTypedOneOfPost",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = resolveGlobalSecurity(security$);

        const requestRes$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                body: body$,
                uaHeader: "x-speakeasy-user-agent",
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );
        const request$ = unwrap$(requestRes$);

        const doResult = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });
        const response = unwrap$(doResult);

        const [result$] = await m$.match<
            operations.WeaklyTypedOneOfPostRes,
            SDKError | SDKValidationError
        >(
            m$.json(200, operations.WeaklyTypedOneOfPostRes$inboundSchema),
            m$.fail(["4XX", "5XX"])
        )(response);

        return unwrap$(result$);
    }
}
